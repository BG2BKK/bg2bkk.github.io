<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<title> redis持久化学习笔记 &middot; BG2BKK Hugo Site </title>


<link rel="stylesheet" href="http://bg2bkk.github.io//css/slim.css">
<link rel="stylesheet" href="http://bg2bkk.github.io//css/highlight.min.css">
<link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700|Source+Code+Pro' rel='stylesheet' type='text/css'>

<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
<link rel="shortcut icon" href="/favicon.ico">


<link href="" rel="alternate" type="application/rss+xml" title="BG2BKK Hugo Site" />

</head>

<body>
  <div class="container">
    <div class="header">
  <h1 class="site-title"><a href="http://bg2bkk.github.io/">BG2BKK Hugo Site</a></h1>
  <p class="site-tagline"></p>
  <div class="nav">
    <a class="nav-btn" href="#">
      <span class="ci ci-burger"></span>
    </a>
    <ul class="nav-list">
       
	  <li class="spacer">&ac;</li>
  
    </ul>
  </div>
</div>
    <div class="content">
      <div class="posts">
        <div class="post">
          <h2 class="post-title"><a href="http://bg2bkk.github.io/post/redis%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">redis持久化学习笔记</a></h2>
          <span class="post-date">Feb 26, 2016 </span>
          <div class="post-content">
            <ul>
<li><p>虽然网络上关于redis持久化的相关内容数不胜数，但是一来作为我的学习笔记，好记性不如烂笔头；二来除去官方redis之外，很多有意义的修改或补充都非常值得讨论，所以我想做一下记录。</p></li>

<li><p>持久化用于重启后的数据恢复，而持久化的引入导致了redis可能产生的性能抖动</p></li>

<li><p>redis持久化的<a href="http://www.cnblogs.com/zhoujinyi/archive/2013/05/26/3098508.html"> 两种方法 </a></p>

<ul>
<li><p>RDB方式</p>

<ul>
<li>RDB方式是redis的默认持久化方式</li>
<li>快照RDB持久化过程:

<ul>
<li>redis调用fork，产生子进程</li>
<li>父进程继续接受用户请求；子进程负责将内存内容写入临时文件，写入完成后rename为dump文件，实现替换</li>
<li>在子进程写内存内容期间，父进程如果要修改内存数据，os将会通过写时复制为父进程创建副本，所以此时子进程写入的仍然是fork时刻的整个数据库内容</li>
</ul></li>

<li><p>不足之处在于:</p>

<ul>
<li>如果redis出现问题崩溃了，此时的rdb文件可能不是最新的数据，从上次RDB文件生成到redis崩溃这段时间的数据全部丢掉。</li>
<li>产生快照时，redis最多将占用2倍于现有数据规模的内存，因此当内存占用过多时，RDB方式可能导致系统负载过高，甚至假死。（有个说法是，当redis的内存占用超过物理内存的3/5时，进行RDB主从复制就比较危险了）</li>
</ul></li>

<li><p>主从复制过程</p>

<ul>
<li>第一次同步

<ul>
<li>slave向master发送sync同步请求，master先dump出rdb文件，并将其全量传输给slave；master将产生rdb文件之后这段时间内的修改命令缓存起来，并发送给slave。首次同步完成。</li>
</ul></li>
<li>第二次及以后的同步实现方式：

<ul>
<li>master将变量的快照（有修改的变量）直接实时发送给slave。</li>
<li>如果发生断开重连，则重复第一步第二步</li>
</ul></li>
<li>reids-2.8版本之后，重连后进行第一步时，不用全量更新了。</li>
</ul></li>
</ul></li>

<li><p>AOF方式</p>

<ul>
<li><p>AOF方式持久化过程</p>

<ul>
<li>Append Only File</li>
<li>Redis将每次收到的命令都追加到文件中，类似于mysql的binlog；当redis重启时重新执行文件中的所有命令来重建数据</li>
<li>如果将所有命令不加甄别的都写入文件中，持久化文件会越来越大，比如INCR test命令执行100次，效果与SET test 100一样。此时需要进行rewrite，合并命令。</li>
<li>Redis提供了bgrewriteaof命令，执行过程与产生RDB文件的机制类似，fork出的子进程将内存中的数据以命令的方式重写持久化文件。本质上讲，该命令是将数据库中所有数据内容以命令的方式重写进新的AOF文件</li>
</ul></li>

<li><p>AOF方式之我的想法</p>

<ul>
<li>AOF方式是redis在收到命名后将命令写入文件内，如果redis发送故障，重启时直接读取AOF文件重新执行命令即可恢复，可以克服RDB方式的缺点</li>
<li>bgrewriteaof指令是对AOF方式的一次优化，执行bgrewriteaof命令时是根据此时数据库内容来写入AOF文件，并替换旧的AOF文件。这个过程与RDB快照产生方式一样</li>
</ul></li>
</ul></li>

<li><p>RDB方式和AOF方式的对比</p>

<ul>
<li>RDB方式恢复起来快，而AOF方式需要一条条命令执行</li>
<li>RDB文件不需要经过编码，是数据库内容的直接克隆，所以文件比较小；而AOF文件内是一条条命令，需要依次执行</li>
<li>RDB文件可能会丢失部分数据，而AOF则专门解决这个问题</li>
</ul></li>

<li><p>选择哪种方式</p>

<ul>
<li>官方推荐：

<ul>
<li>如果想要很高的数据保障，则同时使用两种方式</li>
<li>如果可以接受数据丢失，则仅使用RDB方式</li>
</ul></li>
<li>通常的设计思路是

<ul>
<li>利用replication机制弥补持久化在性能和设计上的不足</li>
<li>master上不做RDB和AOF，保证读写性能</li>
<li>slave同时开启两种方式，保证数据安全性</li>
</ul></li>
</ul></li>
</ul></li>

<li><p>Redis数据恢复过程</p>

<ul>
<li>AOF优先级高于RDB方式，如果同时配置了AOF和RDB，AOF生效</li>
</ul></li>
</ul>

<pre><code class="language-cpp">    void loadDataFromDisk(void) {
        long long start = ustime();
        if (server.aof_state == REDIS_AOF_ON) {
            if (loadAppendOnlyFile(server.aof_filename) == REDIS_OK)
                redisLog(REDIS_NOTICE,&quot;DB loaded from append only file: %.3f seconds&quot;,(float)(ustime()-start)/1000000);
        } else {
            if (rdbLoad(server.rdb_filename) == REDIS_OK) {
                redisLog(REDIS_NOTICE,&quot;DB loaded from disk: %.3f seconds&quot;,
                    (float)(ustime()-start)/1000000);
            } else if (errno != ENOENT) {
                redisLog(REDIS_WARNING,&quot;Fatal error loading the DB: %s. Exiting.&quot;,strerror(errno));
                exit(1);
            }
        }
    }
</code></pre>

          </div>
        </div>
        <div class="pagination">
          <a class="btn previous " href="http://bg2bkk.github.io/post/redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"> Prev</a>  
          <a class="btn next " href="http://bg2bkk.github.io/post/tcp%20ip%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%9C%A8linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%BA%8F/"> Next</a> 
        </div>
      </div>
    </div>
    
    <div class="footer">
  <p>Powered by <a href="http://gohugo.io">Hugo</a>. This theme—Slim—is open sourced on <a href="https://github.com/zhe/hugo-theme-slim">Github</a>.</p>
</div>

  </div>
  <script src="http://bg2bkk.github.io//js/slim.js"></script>
  <script src="http://bg2bkk.github.io//js/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad();
  </script>
  
</body>

</html>
