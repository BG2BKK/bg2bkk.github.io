<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<title> pipe在内核中的实现 &middot; BG2BKK Hugo Site </title>


<link rel="stylesheet" href="https://bg2bkk.github.io//css/slim.css">
<link rel="stylesheet" href="https://bg2bkk.github.io//css/highlight.min.css">


<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
<link rel="shortcut icon" href="/favicon.ico">


<link href="" rel="alternate" type="application/rss+xml" title="BG2BKK Hugo Site" />

</head>

<body>
  <div class="container">
    <div class="header">
  <h1 class="site-title"><a href="https://bg2bkk.github.io/">BG2BKK Hugo Site</a></h1>
  <p class="site-tagline"></p>
  <div class="nav">
    <a class="nav-btn" href="#">
      <span class="ci ci-burger"></span>
    </a>
    <ul class="nav-list">
       
	  <li class="spacer">&ac;</li>
  
    </ul>
  </div>
</div>
    <div class="content">
      <div class="posts">
        <div class="post">
          <h2 class="post-title"><a href="https://bg2bkk.github.io/post/pipe%E5%9C%A8%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0/">pipe在内核中的实现</a></h2>
          <span class="post-date">Feb 27, 2016 </span>
          <div class="post-content">
            <ul>
<li>基于linux-2.4.20内核</li>
<li>new_inode()</li>
<li>register_filesystem()</li>
<li>get_empty_file</li>
<li>get_unused_fd()</li>
<li>do_pipe作为pipe系统调用函数，在/arch/i386/sys_i386.c中定义</li>
<li>pipe的module_init在initcall中调用，但是pipe.c是编译在fs.o中的，他的module_init是如何调用进去的，需要进一步查找</li>

<li><p>struct dentry在include/linux/dcache.h中定义</p></li>

<li><p>pipe文件系统初始化</p>

<ul>
<li>注册pipefs

<ul>
<li>register_filesystems</li>
</ul></li>
</ul></li>

<li><p>pipe系统调用</p>

<ul>
<li>pipe调用do_pipe</li>
<li>do_pipe()

<ul>
<li>f1&amp;f2 get_empty_filep分配filep数据结构</li>
<li>inode = get_pipe_inode()从pipe文件系统获得inode

<ul>
<li>new_inode()</li>
<li>pipe_new()新建pipe

<ul>
<li>__get_free_pages(GFP_USER)为该pipe分配一页内存（4KB）</li>
<li>inode-&gt;i_pipe = kmalloc(sizeof(struct pipe_inde_info), GFP_KERNEL)分配pipe信息结构</li>
</ul></li>
</ul></li>
<li>i&amp;j = get_unused_fd()获取两个fd</li>
<li>dentry = d_alloc()从pipefs分配dentry</li>
<li>d_add(dentry, inode)将inode插入到dentry中</li>
<li>将f1设置成O_RDONLY，将f2设置成O_WRONLY</li>
<li>进程的files列表中，files[i] = f1, files[j] = f2</li>
</ul></li>
</ul></li>

<li><p>实现函数</p>

<ul>
<li>pipe

<ul>
<li>pipe_read</li>
<li>pipe_write</li>
</ul></li>
</ul></li>

<li><p>tips</p>

<ul>
<li>pipe不允许使用seek</li>
<li>低版本linux-2.4.20在pipe写的时候是固定大小，而高版本的是会按需分配直至64KB的。</li>

<li><p>高版本kernel内核中sysctl的配置参数<strong><em>fs.pipe-max-size</em></strong> 可以设置固定的pipe大小。但是也不能超过64KB大小，即使配置数据大于这个数字，pipe大小也会限制在64KB。</p></li>

<li><p><a href="http://unix.stackexchange.com/questions/11946/how-big-is-the-pipe-buffer">测试代码</a></p></li>
</ul></li>
</ul>

<pre><code class="language-bash">#!/bin/bash
test $# -ge 1 || { echo &quot;usage: $0 write-size [wait-time]&quot;; exit 1; }
test $# -ge 2 || set -- &quot;$@&quot; 1
bytes_written=$(
{
    exec 3&gt;&amp;1
    {
        perl -e '
            $size = $ARGV[0];
            $block = q(a) x $size;
            $num_written = 0;
            sub report { print STDERR $num_written * $size, qq(\n); }
            report; while (defined syswrite STDOUT, $block) {
                $num_written++; report;
            }
        ' &quot;$1&quot; 2&gt;&amp;3
    } | (sleep &quot;$2&quot;; exec 0&lt;&amp;-);
} | tail -1
)
printf &quot;write size: %10d; bytes successfully before error: %d\n&quot; \
    &quot;$1&quot; &quot;$bytes_written&quot;

</code></pre>

<pre><code>* 测试结果
</code></pre>

<pre><code>huang@ThinkPad-X220:~/workspace/cpp$ /bin/bash -c 'for p in {0..18}; do ./pipe.sh $((2 ** $p)) 0.5; done'
write size:          1; bytes successfully before error: 65536
write size:          2; bytes successfully before error: 65536
write size:          4; bytes successfully before error: 65536
write size:          8; bytes successfully before error: 65536
write size:         16; bytes successfully before error: 65536
write size:         32; bytes successfully before error: 65536
write size:         64; bytes successfully before error: 65536
write size:        128; bytes successfully before error: 65536
write size:        256; bytes successfully before error: 65536
write size:        512; bytes successfully before error: 65536
write size:       1024; bytes successfully before error: 65536
write size:       2048; bytes successfully before error: 65536
write size:       4096; bytes successfully before error: 65536
write size:       8192; bytes successfully before error: 65536
write size:      16384; bytes successfully before error: 65536
write size:      32768; bytes successfully before error: 65536
write size:      65536; bytes successfully before error: 65536
write size:     131072; bytes successfully before error: 0
write size:     262144; bytes successfully before error: 0

</code></pre>

<pre><code>* 内核中64KB大小的限制，sysctl中fs.max_pipe_size的设置，以及ulimit -a中的&quot;pipe size            (512 bytes, -p) 8&quot;，到底都会发挥怎样的功能呢？这些还需要[进一步探讨](http://home.gna.org/pysfst/tests/pipe-limit.html)。
</code></pre>

<ul>
<li>函数分析

<ul>
<li>init_pipe_fs向文件系统注册pipe组件</li>
</ul></li>
</ul>

<pre><code class="language-cpp">static int __init init_pipe_fs(void)
{
	int err = register_filesystem(&amp;pipe_fs_type);
	if (!err) {
		pipe_mnt = kern_mount(&amp;pipe_fs_type);
		err = PTR_ERR(pipe_mnt);
		if (IS_ERR(pipe_mnt))
			unregister_filesystem(&amp;pipe_fs_type);
		else
			err = 0;
	}
	return err;
}
</code></pre>

<pre><code class="language-cpp">static DECLARE_FSTYPE(pipe_fs_type, &quot;pipefs&quot;, pipefs_read_super, FS_NOMOUNT);
</code></pre>

<pre><code class="language-cpp">#define DECLARE_FSTYPE(var,type,read,flags) \
struct file_system_type var = { \
	name:		type, \
	read_super:	read, \
	fs_flags:	flags, \
	owner:		THIS_MODULE, \
}
</code></pre>

<pre><code>* pipe源码（2.4的实现中实在没什么可讲的，比较有价值的是pipe_write和pipe_read中处理缓冲队列源码可以参考）
</code></pre>

<pre><code class="language-cpp">/*
 *  linux/fs/pipe.c
 *
 *  Copyright (C) 1991, 1992, 1999  Linus Torvalds
 */

#include &lt;linux/mm.h&gt;
#include &lt;linux/file.h&gt;
#include &lt;linux/poll.h&gt;
#include &lt;linux/slab.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/init.h&gt;

#include &lt;asm/uaccess.h&gt;
#include &lt;asm/ioctls.h&gt;

/*
 * We use a start+len construction, which provides full use of the 
 * allocated memory.
 * -- Florian Coosmann (FGC)
 * 
 * Reads with count = 0 should always return 0.
 * -- Julian Bradfield 1999-06-07.
 */

/* Drop the inode semaphore and wait for a pipe event, atomically */
void pipe_wait(struct inode * inode)
{
	DECLARE_WAITQUEUE(wait, current);
	current-&gt;state = TASK_INTERRUPTIBLE;
	add_wait_queue(PIPE_WAIT(*inode), &amp;wait);
	up(PIPE_SEM(*inode));
	schedule();
	remove_wait_queue(PIPE_WAIT(*inode), &amp;wait);
	current-&gt;state = TASK_RUNNING;
	down(PIPE_SEM(*inode));
}

static ssize_t
pipe_read(struct file *filp, char *buf, size_t count, loff_t *ppos)
{
	struct inode *inode = filp-&gt;f_dentry-&gt;d_inode;
	ssize_t size, read, ret;

	/* Seeks are not allowed on pipes.  */
	ret = -ESPIPE;
	read = 0;
	if (ppos != &amp;filp-&gt;f_pos)
		goto out_nolock;

	/* Always return 0 on null read.  */
	ret = 0;
	if (count == 0)
		goto out_nolock;

	/* Get the pipe semaphore */
	ret = -ERESTARTSYS;
	if (down_interruptible(PIPE_SEM(*inode)))
		goto out_nolock;

	if (PIPE_EMPTY(*inode)) {
do_more_read:
		ret = 0;
		if (!PIPE_WRITERS(*inode))
			goto out;

		ret = -EAGAIN;
		if (filp-&gt;f_flags &amp; O_NONBLOCK)
			goto out;

		for (;;) {
			PIPE_WAITING_READERS(*inode)++;
			pipe_wait(inode);
			PIPE_WAITING_READERS(*inode)--;
			ret = -ERESTARTSYS;
			if (signal_pending(current))
				goto out;
			ret = 0;
			if (!PIPE_EMPTY(*inode))
				break;
			if (!PIPE_WRITERS(*inode))
				goto out;
		}
	}

	/* Read what data is available.  */
	ret = -EFAULT;
	while (count &gt; 0 &amp;&amp; (size = PIPE_LEN(*inode))) {
		char *pipebuf = PIPE_BASE(*inode) + PIPE_START(*inode);
		ssize_t chars = PIPE_MAX_RCHUNK(*inode);

		if (chars &gt; count)
			chars = count;
		if (chars &gt; size)
			chars = size;

		if (copy_to_user(buf, pipebuf, chars))
			goto out;

		read += chars;
		PIPE_START(*inode) += chars;
		PIPE_START(*inode) &amp;= (PIPE_SIZE - 1);
		PIPE_LEN(*inode) -= chars;
		count -= chars;
		buf += chars;
	}

	/* Cache behaviour optimization */
	if (!PIPE_LEN(*inode))
		PIPE_START(*inode) = 0;

	if (count &amp;&amp; PIPE_WAITING_WRITERS(*inode) &amp;&amp; !(filp-&gt;f_flags &amp; O_NONBLOCK)) {
		/*
		 * We know that we are going to sleep: signal
		 * writers synchronously that there is more
		 * room.
		 */
		wake_up_interruptible_sync(PIPE_WAIT(*inode));
		if (!PIPE_EMPTY(*inode))
			BUG();
		goto do_more_read;
	}
	/* Signal writers asynchronously that there is more room.  */
	wake_up_interruptible(PIPE_WAIT(*inode));

	ret = read;
out:
	up(PIPE_SEM(*inode));
out_nolock:
	if (read)
		ret = read;

	UPDATE_ATIME(inode);
	return ret;
}

static ssize_t
pipe_write(struct file *filp, const char *buf, size_t count, loff_t *ppos)
{
	struct inode *inode = filp-&gt;f_dentry-&gt;d_inode;
	ssize_t free, written, ret;

	/* Seeks are not allowed on pipes.  */
	ret = -ESPIPE;
	written = 0;
	if (ppos != &amp;filp-&gt;f_pos)
		goto out_nolock;

	/* Null write succeeds.  */
	ret = 0;
	if (count == 0)
		goto out_nolock;

	ret = -ERESTARTSYS;
	if (down_interruptible(PIPE_SEM(*inode)))
		goto out_nolock;

	/* No readers yields SIGPIPE.  */
	if (!PIPE_READERS(*inode))
		goto sigpipe;

	/* If count &lt;= PIPE_BUF, we have to make it atomic.  */
	free = (count &lt;= PIPE_BUF ? count : 1);

	/* Wait, or check for, available space.  */
	if (filp-&gt;f_flags &amp; O_NONBLOCK) {
		ret = -EAGAIN;
		if (PIPE_FREE(*inode) &lt; free)
			goto out;
	} else {
		while (PIPE_FREE(*inode) &lt; free) {
			PIPE_WAITING_WRITERS(*inode)++;
			pipe_wait(inode);
			PIPE_WAITING_WRITERS(*inode)--;
			ret = -ERESTARTSYS;
			if (signal_pending(current))
				goto out;

			if (!PIPE_READERS(*inode))
				goto sigpipe;
		}
	}

	/* Copy into available space.  */
	ret = -EFAULT;
	while (count &gt; 0) {
		int space;
		char *pipebuf = PIPE_BASE(*inode) + PIPE_END(*inode);
		ssize_t chars = PIPE_MAX_WCHUNK(*inode);

		if ((space = PIPE_FREE(*inode)) != 0) {
			if (chars &gt; count)
				chars = count;
			if (chars &gt; space)
				chars = space;

			if (copy_from_user(pipebuf, buf, chars))
				goto out;

			written += chars;
			PIPE_LEN(*inode) += chars;
			count -= chars;
			buf += chars;
			space = PIPE_FREE(*inode);
			continue;
		}

		ret = written;
		if (filp-&gt;f_flags &amp; O_NONBLOCK)
			break;

		do {
			/*
			 * Synchronous wake-up: it knows that this process
			 * is going to give up this CPU, so it doesn't have
			 * to do idle reschedules.
			 */
			wake_up_interruptible_sync(PIPE_WAIT(*inode));
			PIPE_WAITING_WRITERS(*inode)++;
			pipe_wait(inode);
			PIPE_WAITING_WRITERS(*inode)--;
			if (signal_pending(current))
				goto out;
			if (!PIPE_READERS(*inode))
				goto sigpipe;
		} while (!PIPE_FREE(*inode));
		ret = -EFAULT;
	}

	/* Signal readers asynchronously that there is more data.  */
	wake_up_interruptible(PIPE_WAIT(*inode));

	inode-&gt;i_ctime = inode-&gt;i_mtime = CURRENT_TIME;
	mark_inode_dirty(inode);

out:
	up(PIPE_SEM(*inode));
out_nolock:
	if (written)
		ret = written;
	return ret;

sigpipe:
	if (written)
		goto out;
	up(PIPE_SEM(*inode));
	send_sig(SIGPIPE, current, 0);
	return -EPIPE;
}

static ssize_t
bad_pipe_r(struct file *filp, char *buf, size_t count, loff_t *ppos)
{
	return -EBADF;
}

static ssize_t
bad_pipe_w(struct file *filp, const char *buf, size_t count, loff_t *ppos)
{
	return -EBADF;
}

static int
pipe_ioctl(struct inode *pino, struct file *filp,
	   unsigned int cmd, unsigned long arg)
{
	switch (cmd) {
		case FIONREAD:
			return put_user(PIPE_LEN(*pino), (int *)arg);
		default:
			return -EINVAL;
	}
}

/* No kernel lock held - fine */
static unsigned int
pipe_poll(struct file *filp, poll_table *wait)
{
	unsigned int mask;
	struct inode *inode = filp-&gt;f_dentry-&gt;d_inode;

	poll_wait(filp, PIPE_WAIT(*inode), wait);

	/* Reading only -- no need for acquiring the semaphore.  */
	mask = POLLIN | POLLRDNORM;
	if (PIPE_EMPTY(*inode))
		mask = POLLOUT | POLLWRNORM;
	if (!PIPE_WRITERS(*inode) &amp;&amp; filp-&gt;f_version != PIPE_WCOUNTER(*inode))
		mask |= POLLHUP;
	if (!PIPE_READERS(*inode))
		mask |= POLLERR;

	return mask;
}

/* FIXME: most Unices do not set POLLERR for fifos */
#define fifo_poll pipe_poll

static int
pipe_release(struct inode *inode, int decr, int decw)
{
	down(PIPE_SEM(*inode));
	PIPE_READERS(*inode) -= decr;
	PIPE_WRITERS(*inode) -= decw;
	if (!PIPE_READERS(*inode) &amp;&amp; !PIPE_WRITERS(*inode)) {
		struct pipe_inode_info *info = inode-&gt;i_pipe;
		inode-&gt;i_pipe = NULL;
		free_page((unsigned long) info-&gt;base);
		kfree(info);
	} else {
		wake_up_interruptible(PIPE_WAIT(*inode));
	}
	up(PIPE_SEM(*inode));

	return 0;
}

static int
pipe_read_release(struct inode *inode, struct file *filp)
{
	return pipe_release(inode, 1, 0);
}

static int
pipe_write_release(struct inode *inode, struct file *filp)
{
	return pipe_release(inode, 0, 1);
}

static int
pipe_rdwr_release(struct inode *inode, struct file *filp)
{
	int decr, decw;

	decr = (filp-&gt;f_mode &amp; FMODE_READ) != 0;
	decw = (filp-&gt;f_mode &amp; FMODE_WRITE) != 0;
	return pipe_release(inode, decr, decw);
}

static int
pipe_read_open(struct inode *inode, struct file *filp)
{
	/* We could have perhaps used atomic_t, but this and friends
	   below are the only places.  So it doesn't seem worthwhile.  */
	down(PIPE_SEM(*inode));
	PIPE_READERS(*inode)++;
	up(PIPE_SEM(*inode));

	return 0;
}

static int
pipe_write_open(struct inode *inode, struct file *filp)
{
	down(PIPE_SEM(*inode));
	PIPE_WRITERS(*inode)++;
	up(PIPE_SEM(*inode));

	return 0;
}

static int
pipe_rdwr_open(struct inode *inode, struct file *filp)
{
	down(PIPE_SEM(*inode));
	if (filp-&gt;f_mode &amp; FMODE_READ)
		PIPE_READERS(*inode)++;
	if (filp-&gt;f_mode &amp; FMODE_WRITE)
		PIPE_WRITERS(*inode)++;
	up(PIPE_SEM(*inode));

	return 0;
}

/*
 * The file_operations structs are not static because they
 * are also used in linux/fs/fifo.c to do operations on FIFOs.
 */
struct file_operations read_fifo_fops = {
	llseek:		no_llseek,
	read:		pipe_read,
	write:		bad_pipe_w,
	poll:		fifo_poll,
	ioctl:		pipe_ioctl,
	open:		pipe_read_open,
	release:	pipe_read_release,
};

struct file_operations write_fifo_fops = {
	llseek:		no_llseek,
	read:		bad_pipe_r,
	write:		pipe_write,
	poll:		fifo_poll,
	ioctl:		pipe_ioctl,
	open:		pipe_write_open,
	release:	pipe_write_release,
};

struct file_operations rdwr_fifo_fops = {
	llseek:		no_llseek,
	read:		pipe_read,
	write:		pipe_write,
	poll:		fifo_poll,
	ioctl:		pipe_ioctl,
	open:		pipe_rdwr_open,
	release:	pipe_rdwr_release,
};

struct file_operations read_pipe_fops = {
	llseek:		no_llseek,
	read:		pipe_read,
	write:		bad_pipe_w,
	poll:		pipe_poll,
	ioctl:		pipe_ioctl,
	open:		pipe_read_open,
	release:	pipe_read_release,
};

struct file_operations write_pipe_fops = {
	llseek:		no_llseek,
	read:		bad_pipe_r,
	write:		pipe_write,
	poll:		pipe_poll,
	ioctl:		pipe_ioctl,
	open:		pipe_write_open,
	release:	pipe_write_release,
};

struct file_operations rdwr_pipe_fops = {
	llseek:		no_llseek,
	read:		pipe_read,
	write:		pipe_write,
	poll:		pipe_poll,
	ioctl:		pipe_ioctl,
	open:		pipe_rdwr_open,
	release:	pipe_rdwr_release,
};

struct inode* pipe_new(struct inode* inode)
{
	unsigned long page;

	page = __get_free_page(GFP_USER);
	if (!page)
		return NULL;

	inode-&gt;i_pipe = kmalloc(sizeof(struct pipe_inode_info), GFP_KERNEL);
	if (!inode-&gt;i_pipe)
		goto fail_page;

	init_waitqueue_head(PIPE_WAIT(*inode));
	PIPE_BASE(*inode) = (char*) page;
	PIPE_START(*inode) = PIPE_LEN(*inode) = 0;
	PIPE_READERS(*inode) = PIPE_WRITERS(*inode) = 0;
	PIPE_WAITING_READERS(*inode) = PIPE_WAITING_WRITERS(*inode) = 0;
	PIPE_RCOUNTER(*inode) = PIPE_WCOUNTER(*inode) = 1;

	return inode;
fail_page:
	free_page(page);
	return NULL;
}

static struct vfsmount *pipe_mnt;
static int pipefs_delete_dentry(struct dentry *dentry)
{
	return 1;
}
static struct dentry_operations pipefs_dentry_operations = {
	d_delete:	pipefs_delete_dentry,
};

static struct inode * get_pipe_inode(void)
{
	struct inode *inode = new_inode(pipe_mnt-&gt;mnt_sb);

	if (!inode)
		goto fail_inode;

	if(!pipe_new(inode))
		goto fail_iput;
	PIPE_READERS(*inode) = PIPE_WRITERS(*inode) = 1;
	inode-&gt;i_fop = &amp;rdwr_pipe_fops;

	/*
	 * Mark the inode dirty from the very beginning,
	 * that way it will never be moved to the dirty
	 * list because &quot;mark_inode_dirty()&quot; will think
	 * that it already _is_ on the dirty list.
	 */
	inode-&gt;i_state = I_DIRTY;
	inode-&gt;i_mode = S_IFIFO | S_IRUSR | S_IWUSR;
	inode-&gt;i_uid = current-&gt;fsuid;
	inode-&gt;i_gid = current-&gt;fsgid;
	inode-&gt;i_atime = inode-&gt;i_mtime = inode-&gt;i_ctime = CURRENT_TIME;
	inode-&gt;i_blksize = PAGE_SIZE;
	return inode;

fail_iput:
	iput(inode);
fail_inode:
	return NULL;
}

int do_pipe(int *fd)
{
	struct qstr this;
	char name[32];
	struct dentry *dentry;
	struct inode * inode;
	struct file *f1, *f2;
	int error;
	int i,j;

	error = -ENFILE;
	f1 = get_empty_filp();
	if (!f1)
		goto no_files;

	f2 = get_empty_filp();
	if (!f2)
		goto close_f1;

	inode = get_pipe_inode();
	if (!inode)
		goto close_f12;

	error = get_unused_fd();
	if (error &lt; 0)
		goto close_f12_inode;
	i = error;

	error = get_unused_fd();
	if (error &lt; 0)
		goto close_f12_inode_i;
	j = error;

	error = -ENOMEM;
	sprintf(name, &quot;[%lu]&quot;, inode-&gt;i_ino);
	this.name = name;
	this.len = strlen(name);
	this.hash = inode-&gt;i_ino; /* will go */
	dentry = d_alloc(pipe_mnt-&gt;mnt_sb-&gt;s_root, &amp;this);
	if (!dentry)
		goto close_f12_inode_i_j;
	dentry-&gt;d_op = &amp;pipefs_dentry_operations;
	d_add(dentry, inode);
	f1-&gt;f_vfsmnt = f2-&gt;f_vfsmnt = mntget(mntget(pipe_mnt));
	f1-&gt;f_dentry = f2-&gt;f_dentry = dget(dentry);

	/* read file */
	f1-&gt;f_pos = f2-&gt;f_pos = 0;
	f1-&gt;f_flags = O_RDONLY;
	f1-&gt;f_op = &amp;read_pipe_fops;
	f1-&gt;f_mode = 1;
	f1-&gt;f_version = 0;

	/* write file */
	f2-&gt;f_flags = O_WRONLY;
	f2-&gt;f_op = &amp;write_pipe_fops;
	f2-&gt;f_mode = 2;
	f2-&gt;f_version = 0;

	fd_install(i, f1);
	fd_install(j, f2);
	fd[0] = i;
	fd[1] = j;
	return 0;

close_f12_inode_i_j:
	put_unused_fd(j);
close_f12_inode_i:
	put_unused_fd(i);
close_f12_inode:
	free_page((unsigned long) PIPE_BASE(*inode));
	kfree(inode-&gt;i_pipe);
	inode-&gt;i_pipe = NULL;
	iput(inode);
close_f12:
	put_filp(f2);
close_f1:
	put_filp(f1);
no_files:
	return error;	
}

/*
 * pipefs should _never_ be mounted by userland - too much of security hassle,
 * no real gain from having the whole whorehouse mounted. So we don't need
 * any operations on the root directory. However, we need a non-trivial
 * d_name - pipe: will go nicely and kill the special-casing in procfs.
 */
static int pipefs_statfs(struct super_block *sb, struct statfs *buf)
{
	buf-&gt;f_type = PIPEFS_MAGIC;
	buf-&gt;f_bsize = 1024;
	buf-&gt;f_namelen = 255;
	return 0;
}

static struct super_operations pipefs_ops = {
	statfs:		pipefs_statfs,
};

static struct super_block * pipefs_read_super(struct super_block *sb, void *data, int silent)
{
	struct inode *root = new_inode(sb);
	if (!root)
		return NULL;
	root-&gt;i_mode = S_IFDIR | S_IRUSR | S_IWUSR;
	root-&gt;i_uid = root-&gt;i_gid = 0;
	root-&gt;i_atime = root-&gt;i_mtime = root-&gt;i_ctime = CURRENT_TIME;
	sb-&gt;s_blocksize = 1024;
	sb-&gt;s_blocksize_bits = 10;
	sb-&gt;s_magic = PIPEFS_MAGIC;
	sb-&gt;s_op	= &amp;pipefs_ops;
	sb-&gt;s_root = d_alloc(NULL, &amp;(const struct qstr) { &quot;pipe:&quot;, 5, 0 });
	if (!sb-&gt;s_root) {
		iput(root);
		return NULL;
	}
	sb-&gt;s_root-&gt;d_sb = sb;
	sb-&gt;s_root-&gt;d_parent = sb-&gt;s_root;
	d_instantiate(sb-&gt;s_root, root);
	return sb;
}

static DECLARE_FSTYPE(pipe_fs_type, &quot;pipefs&quot;, pipefs_read_super, FS_NOMOUNT);

static int __init init_pipe_fs(void)
{
	int err = register_filesystem(&amp;pipe_fs_type);
	if (!err) {
		pipe_mnt = kern_mount(&amp;pipe_fs_type);
		err = PTR_ERR(pipe_mnt);
		if (IS_ERR(pipe_mnt))
			unregister_filesystem(&amp;pipe_fs_type);
		else
			err = 0;
	}
	return err;
}

static void __exit exit_pipe_fs(void)
{
	unregister_filesystem(&amp;pipe_fs_type);
	mntput(pipe_mnt);
}

module_init(init_pipe_fs)
module_exit(exit_pipe_fs)
</code></pre>

          </div>
        </div>
        <div class="pagination">
          <a class="btn previous " href="https://bg2bkk.github.io/post/VFS%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"> Prev</a>  
          <a class="btn next " href="https://bg2bkk.github.io/post/redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"> Next</a> 
        </div>
      </div>
    </div>
    
    <div class="footer">
  <p>Powered by <a href="http://gohugo.io">Hugo</a>. This theme—Slim—is open sourced on <a href="https://github.com/zhe/hugo-theme-slim">Github</a>.</p>
</div>

  </div>
  <script src="https://bg2bkk.github.io//js/slim.js"></script>
  <script src="https://bg2bkk.github.io//js/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad();
  </script>
  
</body>

</html>
