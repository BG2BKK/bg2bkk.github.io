<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>BG2BKK Site</title>
    <link>https://bg2bkk.github.io/</link>
    <description>Recent content on BG2BKK Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 23 Oct 2016 16:43:44 +0800</lastBuildDate>
    <atom:link href="https://bg2bkk.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>怎样尽可能全面的评估一台服务器的性能</title>
      <link>https://bg2bkk.github.io/post/how%20to%20perform%20server%20performance%20evaluation/</link>
      <pubDate>Sun, 23 Oct 2016 16:43:44 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/how%20to%20perform%20server%20performance%20evaluation/</guid>
      <description>

&lt;p&gt;给你一台服务器，怎样能够全面评估它的性能？需要测试哪些指标？请写出每个指标的具体测试原理和测试代码。假设这台服务器完全处于线下。&lt;/p&gt;

&lt;p&gt;这个问题看似平常，但是细细审题的话，发现还是不一样的。我们过多关注线上机器的性能，但是如果单独拿出来一台服务器，它的性能怎样呢？&lt;/p&gt;

&lt;p&gt;评估和压榨一台服务器性能的话，找到评估的指标，然后进行压测加观察的方式，得到性能参数。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;观察哪些指标，意义何在？&lt;/li&gt;
&lt;li&gt;如何观察这些指标，测试原理，观测工具/统计代码&lt;/li&gt;
&lt;li&gt;如何进行压测，实现测试场景，压测工具/压测代码&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;bench可以分类为macro bench和micro bench;对于macro bench，很多时候我们得到的是一个整体而粗略的结果，通过top我们可以看到系统负载，这些对于我们定位线上问题，分析应用程序的性能热点很有帮助，然而这并不能精确衡量一台Linux Server的性能；应用程序多种多样，线上系统目的各不相同，所以macro bench一般用于case by case的性能分析，&lt;a href=&#34;https://github.com/BG2BKK/githubio/blob/master/content/post/macrobench.md&#34;&gt;用于解决应用的性能瓶颈&lt;/a&gt;；而micro bench可以定量的分析一台机器+操作系统的性能，采用相同的测试基准，通过无干扰的大量重复基本操作，比如从L1 Cache读取单个字节，耗时一个CPU时钟，在大量重复中得到较为宏观的结果，再排除loop损耗、取运行时间的损耗，可以用于基本衡量一台server的运行效率。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./bin/x86_64-linux-gnu/enough

结果为n=322229, u=5172，执行322229次 TEN( p = *p )，

TEN(T)表示循环展开执行10次任务T，可使loop开销对单次执行结果的影响降低1/10；

总共用时5172000ns，单次平均0.623ns；CPU主频1999.830MHz，折合一个cycle 0.500ns，数据基本可信。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;提升性能主要是把CPU喂饱，所有的性能都是从CPU的角度来衡量；内存读写快慢，单纯比较数据从内存的一个位置移动到另一个位置，这是设备厂商用来做广告用的，不是计算机系统来评估性能的；把数据从内存读到CPU，然后写到另一个地址，数据流经过CPU即是经过了计算机系统，测量这段时间才是有意义的。以数据流动为基础，其他的bench，比如pipe的性能，需要排除数据流动的时间，排除loop等时间，才是单纯pipe的带宽性能；比如context switch速度，在做bench时，需要用pipe来驱动切换进程，这里需要排除掉数据流动的时间，pipe通信的时间，其余开销时间，才是context switch的时间。&lt;/p&gt;

&lt;p&gt;性能评估主要对CPU、memory、disk IO和network IO四个指标，从带宽和时延两个角度评估。&lt;/p&gt;

&lt;p&gt;所谓带宽，不仅仅是硬件上的读写速度，而是数据从源头到达CPU，然后CPU将其送往目的地的速度，考验的是传输能力；所谓时延，更多的评估传输的效率，读取一定量的数据，数据可以在多长时间内从内存读取到CPU。&lt;/p&gt;

&lt;p&gt;所谓时延，其实也是另一种意义的速度，比如context switch，并没有吞吐量这个概念，但是通过将多个进程切换N次，得到总体时间，平均后可以获得单次切换用时，用以评估context switch的latency。&lt;/p&gt;

&lt;h2 id=&#34;测试前的准备&#34;&gt;测试前的准备&lt;/h2&gt;

&lt;p&gt;很多很重要的选项，比如设计测试场景，从逻辑上说通一个测试中都包含哪些时间开销，如何测量&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;测量数据块大小&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;测量从内存经过CPU拷贝到另一块内存时，如果数据量过小，比如32KB，可能这个数据只在最次L2 Cache中流动，那么测量结果将会比真实数据大；如果数据量过大，又有可能被从内存换到磁盘上&lt;/li&gt;
&lt;li&gt;为此的应对方法是，在循环中逐渐增大一倍数据量，列出不同数据量大小的测试数据，我们其实可以分辨出哪些是L1 Cache，哪些是Cache已经失效，因为他们之间的速度差异是巨大的；另外，当我们每次跨过一页访问该页内存，如果访问时间需要好几个us，那么说明这个内存页不在内存中&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;测量时间&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;不论用多么精确的时钟，由于benchmark时单次任务执行时间都非常短，因此用多次loop中求整体运行时间，取平均后能够得到误差较小的结果。&lt;/li&gt;
&lt;li&gt;lmbench的时间机制写的很精妙，比如针对不同的任务，在每次bench的时候，都会预估执行当前任务执行比如500000us，需要执行多少次，这就是需要loop的次数；比较精妙，能够照顾到即使是相同计算机，在负载不一样的时候，对不同任务有一定的适应能力，在运行足够时间后使得系统表现稳定，得到稳定的结果；使用lmbench对相同任务做bench的时候，每次执行结果的误差都不大，低于2%，这个结果我想还是很稳定的。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;考虑多进程，以及编译器可能导致的问题&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;测试时运行的benchmark也都比较小，其实可以视为和单处理器没有区别；或者我们可以将进程绑定到某个CPU上。&lt;/li&gt;
&lt;li&gt;用gcc编译benchmark，优化级别为 -O，可以避免优化过度；注意一些load指令，如果load结果没有被用到的话，可能会被优化掉&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;带宽性能测试&#34;&gt;带宽性能测试&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Memory: 数据从内存到CPU的带宽&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;rd

&lt;ul&gt;
&lt;li&gt;单次读取512Byte数据，即128个int整数，并做相加操作以防止编译器优化；循环展开，而非在for中挨个相加&lt;/li&gt;
&lt;li&gt;use_int(sum)等指令也是防止编译器优化的&lt;/li&gt;
&lt;li&gt;每次读取512Byte，直到读完，算是一次读取完成&lt;/li&gt;
&lt;li&gt;如果rd的数据块太小，比如32MB，很快被读完，这时需要调整连续循环读取iterations次，然后求平均；iterations的取值取决于根据系统负载情况，实时计算需要执行的次数。&lt;/li&gt;
&lt;li&gt;我的CPU是&lt;a href=&#34;http://www.cpu-world.com/CPUs/Xeon/Intel-Xeon%20E5-2620.html&#34;&gt;至强E5-2620&lt;/a&gt;，包含6*32KB的8路组相连数据L1缓存，6*256KB的8路组相连L2,15MB的20路共享L3cache&lt;/li&gt;
&lt;li&gt;根据读取的数据块大小，我们可以逻辑上推断该数据处于哪级缓存；本机的L1/L2/L3分别为192kb/1536kb/15360kb，

&lt;ul&gt;
&lt;li&gt;数据块16KB，带宽34999.46MB/s&lt;/li&gt;
&lt;li&gt;数据块32KB，带宽19191.28MB/s&lt;/li&gt;
&lt;li&gt;数据块320KB，带宽10669.75MB/s&lt;/li&gt;
&lt;li&gt;数据块8MB，带宽6394.37MB/s&lt;/li&gt;
&lt;li&gt;数据块16MB，带宽4993.96MB/s&lt;/li&gt;
&lt;li&gt;数据块1024MB，带宽4979.76MB/s

&lt;ul&gt;
&lt;li&gt;纯内存带宽&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;wr

&lt;ul&gt;
&lt;li&gt;向内存块每一个4字节写入1&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;rdwr

&lt;ul&gt;
&lt;li&gt;wr与rd的结合，性能略差
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;pipe：系统提供的IPC机制的带宽&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;测量方式：父子进程阻塞读写pipe&lt;/li&gt;
&lt;li&gt;tips

&lt;ul&gt;
&lt;li&gt;用bw_pipe，默认是64kb的块，发现采用32kb更快一些，16kb和32kb没区别；&lt;/li&gt;
&lt;li&gt;通过sar -w 1发现，64kb的时候的csw是32kb时的10倍以上&lt;/li&gt;
&lt;li&gt;最后发现，块大小是32kb - 1 和32kb +1是分水岭，&lt;/li&gt;
&lt;li&gt;正在查原因&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;mmap方式读取文件：从磁盘文件读取数据的带宽&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;mmap方式读取文件，首先要打开文件，然后通过mmap将fd映射到匿名内存页，mmap的内存页在读取时才会真正分配&lt;/li&gt;
&lt;li&gt;测量方式：

&lt;ul&gt;
&lt;li&gt;一、多次循环中，open、mmap，然后读取内容，最后close&lt;/li&gt;
&lt;li&gt;二、在测量前open文件，并进行mmap；在多次循环中，每次读取目标大小的文件数据；&lt;/li&gt;
&lt;li&gt;前者可以得到通过读取文件数据时，mmap的纯开销；后者更贴近实际情况&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;测量结果

&lt;ul&gt;
&lt;li&gt;读取1024m数据；测试采用-C标志，复制文件后再进行，可以以冷数据的方式避开文件缓存&lt;/li&gt;
&lt;li&gt;结果一：3223.58 MB/s&lt;/li&gt;
&lt;li&gt;结果二：7948.87 MB/s&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;read方式读取文件：从磁盘文件读取数据的带宽&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;测量方式

&lt;ul&gt;
&lt;li&gt;一、以及包含open、read和close的带宽&lt;/li&gt;
&lt;li&gt;二、测试单纯读文件(read)的带宽，&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;测量结果

&lt;ul&gt;
&lt;li&gt;读取1024m数据；测试采用-C标志，复制文件后再进行，可以以冷数据的方式避开文件缓存&lt;/li&gt;
&lt;li&gt;一、5526.29 MB/s&lt;/li&gt;
&lt;li&gt;二、5442.29 MB/s&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;时延性能测试&#34;&gt;时延性能测试&lt;/h2&gt;

&lt;p&gt;计算机所有的时延几乎都跟memory时延有关，做context switch时首先要store当前进程状态，然后load下一个进程。可以说准确测量计算机内存时延是评估其他时延的前提，虽然内存时延的准确测量不太容易。&lt;/p&gt;

&lt;h3 id=&#34;内存延时&#34;&gt;内存延时&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;定义:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;刨去硬件相关的内存芯片和系统总线时延外，从总线和内存空闲时读数据，和连续读数据这两种场景的差异值得探讨。&lt;/li&gt;
&lt;li&gt;总线空闲时读取内存数据

&lt;ul&gt;
&lt;li&gt;处理器等待从内存中取数据的时间

&lt;ul&gt;
&lt;li&gt;这个时间通常是一种标称值，有些处理器取数据时并不等待和停顿，因此测量延时可能显得小于标称值&lt;/li&gt;
&lt;li&gt;而压测时，由于突发读取导致cache miss，导致实际延时又比这个值大&lt;/li&gt;
&lt;li&gt;因此采用这个值也不是那么合理&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;连续繁忙读内存数据

&lt;ul&gt;
&lt;li&gt;连续读内存时，每次load都会跟着一个load。&lt;/li&gt;
&lt;li&gt;连续读可能会导致时延高于空闲读，有些系统会有&amp;rdquo;关键字优先&amp;rdquo;的机制，读取某个字时不等待整个cache line填充就把该line中的要读取数据喂给CPU，然而此时cache依然处于busy状态；如果此时再有第二次load，会因为当前cache busy而停顿等待。在UltraSPARC中空闲读和连续读的差异可达35%.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;所以lmbench采用的是测试连续读时的内存时延，一来连续读的测量比空闲读容易些，二来连续读更贴近实际情况。由于处理器速度很快，即使发生cache miss，引起的load latency也和连续读更接近。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;测量方法&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;del&gt;读取一块数据，每次读取的长度，从cache line的长度到较大的一块&lt;/del&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;调用系统组件-系统调用&#34;&gt;调用系统组件（系统调用）&lt;/h3&gt;

&lt;p&gt;调用操作系统的入口，一般指系统调用，比如读写设备的read/write，比如getpid()或getimeofday()。&lt;/p&gt;

&lt;p&gt;对于前者的bench，选择操作/dev/null设备，每次写一个字，一般为4字节，经历了用户进程发起系统调用、转入内核态、查询文件描述符、VFS层等一整个过程，测量这个过程的时间；选择该设备的原因是所有操作系统都没有对该设备进行优化&lt;/p&gt;

&lt;p&gt;而后者，系统调用比如getpid、gettimeofday，各平台不同优化，甚至是实现在用户层，不过在Linux上仍然是实现在内核态的。所以可以通过getpid()了解基本开销，通过写/dev/null设备了解整体开销。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;原理：

&lt;ul&gt;
&lt;li&gt;在循环中调用getpid()和write(fd, *buf, 1)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;结果：

&lt;ul&gt;
&lt;li&gt;getpid&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;Simple syscall: 0.0540 microseconds&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;write to /dev/null

&lt;ul&gt;
&lt;li&gt;Simple write: 0.0897 microseconds&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;信号处理耗时&#34;&gt;信号处理耗时&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;建立信号sigaction耗时&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;测量原理：

&lt;ul&gt;
&lt;li&gt;在本进程内部，调用sigaction建立信号&lt;/li&gt;
&lt;li&gt;time = sig_installation&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;测量结果：

&lt;ul&gt;
&lt;li&gt;Signal handler installation: 0.1492 microseconds&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;发送信号耗时 kill(pid, sig)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;测量原理：

&lt;ul&gt;
&lt;li&gt;设置不捕获信号，进程内向自己发送信号，kill(pid_self, SIGUSR1)&lt;/li&gt;
&lt;li&gt;time = sig_send&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;测量结果：

&lt;ul&gt;
&lt;li&gt;0.1240 microseconds&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;捕获并处理信号耗时&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;测量原理：

&lt;ul&gt;
&lt;li&gt;设置捕获信号，向自己发送信号，kill(pid_self, SIGUSR1)&lt;/li&gt;
&lt;li&gt;sig_handle = total_time - sig_installation - sig_send&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;测量结果：

&lt;ul&gt;
&lt;li&gt;Signal handler overhead: 0.9763 microseconds&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;捕获信号耗时：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;测量原理：

&lt;ul&gt;
&lt;li&gt;在bench进程中以只读方式mmap一段内存，如果试图写这块内存，则会一直触发SIGBUS和SIGSEGV信号&lt;/li&gt;
&lt;li&gt;在触发信号前设置SIGBUS和SIGSEGV的处理函数，在处理函数中不执行任务，只动态调整捕获次数；捕获次数达到一定数量时，评估单次处理用时&lt;/li&gt;
&lt;li&gt;由于重复捕获信号，并且信号处理函数里基本没有任务，可以认为这段时间是捕获信号耗时，或者说是信号传递耗时&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;测量结果:

&lt;ul&gt;
&lt;li&gt;Protection fault: 0.4928 microseconds&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;补充：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;由于第三项与第四项采用不相同的测试场景测量，前三项是一个场景，进程设置信号捕获，并向自身发送信号，然后捕获处理，第四项是产生page fault后重复触发信号，bench程序统计捕获次数和耗时计算得来。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;创建进程开销&#34;&gt;创建进程开销&lt;/h3&gt;

&lt;h3 id=&#34;上下文切换&#34;&gt;上下文切换&lt;/h3&gt;

&lt;h2 id=&#34;intel的超线程技术&#34;&gt;intel的超线程技术&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.ibm.com/developerworks/cn/linux/l-htl/&#34;&gt;CPU的超线程机制&lt;/a&gt;通过复制、分区和共享 Intel NetBurst 微结构管道中的资源，使得一个物理处理器能包含两个逻辑处理器。逻辑处理器有自己的处理器状态、指令指针、重命名逻辑以及一些较小的资源，共享的资源有乱序执行引擎和高速缓存。超线程机制HT利用各资源的速度差异，在时间上并行模拟出两份计算资源，理论上讲提供多一倍的计算能力，而代价是，既然涉及到共享，那么在一些操作中会因为共享和竞争而有性能损耗。下表是超线程对Linux API的影响，采用lmbench测试结果，这份bench报表在运行有linux-2.4.19内核的Intel Xeon处理器上，主频1.60GHz。&lt;/p&gt;

&lt;p&gt;&lt;h5 id=&#34;N100C0&#34;&gt; 超线程对 Linux API 的影响&lt;/h5&gt;
&lt;table border=&#34;1&#34; cellpadding=&#34;5&#34; cellspacing=&#34;1&#34; class=&#34;ibm-data-table&#34; summary=&#34;&#34;&gt;&lt;thead xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34;&gt;&lt;tr&gt;&lt;th&gt;&lt;strong&gt;内核函数&lt;/strong&gt;&lt;/th&gt;&lt;th&gt;&lt;strong&gt;2419s-noht&lt;/strong&gt;&lt;/th&gt;&lt;th&gt;&lt;strong&gt;2419s-ht&lt;/strong&gt;&lt;/th&gt;&lt;th&gt;&lt;strong&gt;加速&lt;/strong&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34;&gt;&lt;tr&gt;&lt;td&gt;简单的 syscall&lt;/td&gt;&lt;td&gt;1.10&lt;/td&gt;&lt;td&gt;1.10&lt;/td&gt;&lt;td&gt;0%&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;简单的 read&lt;/td&gt;&lt;td&gt;1.49&lt;/td&gt;&lt;td&gt;1.49&lt;/td&gt;&lt;td&gt;0%&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;简单的 write&lt;/td&gt;&lt;td&gt;1.40&lt;/td&gt;&lt;td&gt;1.40&lt;/td&gt;&lt;td&gt;0%&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;简单的 stat&lt;/td&gt;&lt;td&gt;5.12&lt;/td&gt;&lt;td&gt;5.14&lt;/td&gt;&lt;td&gt;0%&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;简单的 fstat&lt;/td&gt;&lt;td&gt;1.50&lt;/td&gt;&lt;td&gt;1.50&lt;/td&gt;&lt;td&gt;0%&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;简单的 open/close&lt;/td&gt;&lt;td&gt;7.38&lt;/td&gt;&lt;td&gt;7.38&lt;/td&gt;&lt;td&gt;0%&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;对 10 个 fd 的选择&lt;/td&gt;&lt;td&gt;5.41&lt;/td&gt;&lt;td&gt;5.41&lt;/td&gt;&lt;td&gt;0%&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;对 10 个 tcp fd 的选择&lt;/td&gt;&lt;td&gt;5.69&lt;/td&gt;&lt;td&gt;5.70&lt;/td&gt;&lt;td&gt;0%&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;信号处理程序安装&lt;/td&gt;&lt;td&gt;1.56&lt;/td&gt;&lt;td&gt;1.55&lt;/td&gt;&lt;td&gt;0%&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;信号处理程序开销&lt;/td&gt;&lt;td&gt;4.29&lt;/td&gt;&lt;td&gt;4.27&lt;/td&gt;&lt;td&gt;0%&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;管道延迟&lt;/td&gt;&lt;td&gt;11.16&lt;/td&gt;&lt;td&gt;11.31&lt;/td&gt;&lt;td&gt;-1%&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;进程 fork+exit&lt;/td&gt;&lt;td&gt;190.75&lt;/td&gt;&lt;td&gt;198.84&lt;/td&gt;&lt;td&gt;-4%&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;进程 fork+execve&lt;/td&gt;&lt;td&gt;581.55&lt;/td&gt;&lt;td&gt;617.11&lt;/td&gt;&lt;td&gt;-6%&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;进程 fork+/bin/sh -c&lt;/td&gt;&lt;td&gt;3051.28&lt;/td&gt;&lt;td&gt;3118.08&lt;/td&gt;&lt;td&gt;-2%&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td colspan=&#34;4&#34;&gt;注：数据用微秒表示：越小越好。&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/p&gt;

&lt;p&gt;我认为上表中，ht没有影响的API是一些lmbench单进程可以测试的项，比如read、write等，而ht有影响的选项，比如管道延迟、进程fork+exit等，是lmbench需要发起多个进程进行bench，这些进程在逻辑处理器间有竞争，导致性能有些下降。从报表中可以看到，开启ht的bench结果在有些项目中耗时加长，但是比较小，但是整个系统获得了一倍的计算资源。&lt;/p&gt;

&lt;h2 id=&#34;intel的turbo技术&#34;&gt;intel的turbo技术&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://magiclen.org/linux-intel-cpu/&#34;&gt;linux的睿频工具&lt;/a&gt;可以实时看到CPU的运行频率&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo i7z
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以笔记本CPU i5-2520M 为例，在CPU空闲时主频低至&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;        Core [core-id]  :Actual Freq (Mult.)      C0%   Halt(C1)%  C3 %   C6 %  Temp      VCore
        Core 1 [0]:       1366.96 (13.72x)      24.9    81.6    4.69       0    62      1.1008
        Core 2 [2]:       1381.01 (13.86x)      23.3    79.2    7.89       0    62      1.1008
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;甚至更低&lt;/p&gt;

&lt;p&gt;运行lmbench时，CPU满载，主频可达&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;        Core [core-id]  :Actual Freq (Mult.)      C0%   Halt(C1)%  C3 %   C6 %  Temp      VCore
        Core 1 [0]:       2989.17 (30.00x)      16.9    73.4    6.37       0    69      1.1409
        Core 2 [2]:       3050.32 (30.61x)      99.1       0       0       0    73      1.1409
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见睿频的主要作用是动态调整CPU主频适应处理任务，当我们运行lmbench时，理所应当的CPU将会满载运行，所以计算CPU主频时完全不用担心睿频导致的频率变化，总是接近最高值的。&lt;/p&gt;

&lt;h2 id=&#34;lmbench测试框架&#34;&gt;lmbench测试框架&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;fork出child进程，作为bench执行体；parent作为控制体；&lt;/li&gt;
&lt;li&gt;parent和child通过pipe互相通信，child通知parent准备好，parent通知child开始，child执行完毕后通知parent完成；parent取完执行结果，通知child结束。&lt;/li&gt;
&lt;li&gt;应用程序中child首先执行init程序，将准备工作做好；比如如果是bw_mem中的cp benchmark，需要首先分配好src内存块，然后分配dst内存块，准备好后即返回，init结束；&lt;/li&gt;
&lt;li&gt;init结束后，benchmp框架进行下一步，while循环中执行benchmark进入warmup状态&lt;/li&gt;
&lt;li&gt;child执行benchmark是以状态机方式实现的

&lt;ul&gt;
&lt;li&gt;首先是warmup状态，在该状态中childparent发送ready信号，阻塞等待parent的start信号。child收到start后，状态设置为timing_interval，取iterations为1，执行benchmark程序；执行完后重入while循环；&lt;/li&gt;
&lt;li&gt;然后切换到timing_interval状态。由于之前在warmup状态执行以iterations为1的benchmark，重入循环时满足state-&amp;gt;need_warmup == 0，所以开始统计上一次benchmark开始到现在的用时，并刨去t_overload和l_overload；进入状态机的timing_interval状态，该状态评估本次benchmark的用时是否符合期望，如果符合，将本次bench结果记录，并设置状态为cooldown；如果不符合期望，分情况，如果用时result小于150，说明单次benchmark用时太短，需要多次迭代得到总结果，因此将iterations扩大8倍去计算；如果用时大于150，说明单次benchmark执行时间是够的，但是需要微调迭代次数，按照 enough * 1.1 / (iterations / result)；所以说timing_interval状态是用来在bench过程中微调迭代次数以使执行时间符合预期的过程。&lt;/li&gt;
&lt;li&gt;在cooldown状态，child阻塞等待取结果信号，并将结果写回response管道中；执行清理函数后，得到parent发出的exit信号，结束自己。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;最终结果存储在全局变量iterations和stop_tv中，其实是通过get_time()和get_n()，以及set_time()/save_n()或者set_results()中，并在用户程序的结束时进行计算。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Understanding TCPIP Network Stack &amp; Writing Network Apps</title>
      <link>https://bg2bkk.github.io/post/Understanding%20TCPIP%20Network%20Stack%20&amp;%20Writing%20Network%20Apps/</link>
      <pubDate>Thu, 20 Oct 2016 22:21:55 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/Understanding%20TCPIP%20Network%20Stack%20&amp;%20Writing%20Network%20Apps/</guid>
      <description>

&lt;h1 id=&#34;理解tcp-ip协议栈-实现网络应用&#34;&gt;理解TCP/IP协议栈 实现网络应用&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;遇到好文章我就想给翻译下来，觉得写的很好，现在cubrid的一篇TCP/IP相关的文章&lt;a href=&#34;http://www.cubrid.org/blog/dev-platform/understanding-tcp-ip-network-stack/&#34;&gt;详细介绍了TCP协议栈，以及收发数据包的流程，非常有启发意义&lt;/a&gt;，所以我就想翻译一下，做个记录。将TCP/IP协议栈在一篇文章内讲明白是不可能的，所以本文能够做到的是讲清楚TCP/IP协议栈收发数据包的流程，我们要做的是首先了解大致流程，然后尝试根据TCP/IP协议和拿着代码去理解。由于我本人能力十分有限，译文都是我个人理解，所以会有大量错误，希望您能帮我纠正。如果您想转载，我必须提醒一句我这个译文是自己学习之用，并未取得版权方同意，因此首先做免责声明。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们不能想象没有TCP/IP，互联网服务将会是何种情况。所有我们开发和使用的Internet服务都基于一个坚实的基础：TCP/IP。理解数据如何在网络中传输可以帮助你通过优化和调试的方式来提升程序性能，引入和使用新的技术。&lt;/p&gt;

&lt;p&gt;本文将通过在linux操作系统和硬件层面的数据流和控制流来描述网络技术栈的整体执行流程。&lt;/p&gt;

&lt;h2 id=&#34;tcp-ip的关键字&#34;&gt;TCP/IP的关键字&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;我如何设计网络协议，能够在保持数据不丢失不乱序的情况下，快速传输数据？&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;TCP/IP协议为这些考虑而设计，如下是理解TCP/IP协议栈需要了解的关键字&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;确切的说，TCP和IP是两个不同的层，理应分开描述；不过惯例上一直将他俩合成一个概念来讲
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;CONNECTIONI-ORIENTED，面向连接的

&lt;ul&gt;
&lt;li&gt;首先通信双方需要建立一条连接，一条TCP连接的标识符是&lt;strong&gt;&lt;em&gt;local IP address, local port number&lt;/em&gt;&lt;/strong&gt;和&lt;strong&gt;&lt;em&gt;remote IP address, remote port number&lt;/em&gt;&lt;/strong&gt;组成的四元组&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;BIDIRECTIONAL BYTE STREAM, 双向数据流传输

&lt;ul&gt;
&lt;li&gt;使用字节流实现双向传输&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;IN-ORDER DELIVERY，顺序发送

&lt;ul&gt;
&lt;li&gt;接收方按照数据从发送方发送的顺序接收；采用32bit整型作为数据包的序号，以实现顺序传输&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;RELIABILITY THROUGH ACK，通过ACK实现可靠性

&lt;ul&gt;
&lt;li&gt;当发送方发送数据后，没有收到接收方传来的该包的ACK，发送方将重新发送该数据。因此，发送方的TCP需要将未被ACK的数据缓存起来。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;FLOW CONTROL，流控

&lt;ul&gt;
&lt;li&gt;发送方都想尽可能的发送数据给接收方，但是发送方也得能够有能力接收，因此接收方要发送自己能够接收的最大数据量给发送方知道，最终发送方发出数据量由接收方的&lt;strong&gt;&lt;em&gt;接收窗口&lt;/em&gt;&lt;/strong&gt;决定。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;CONGESTION CONTROL，拥塞控制

&lt;ul&gt;
&lt;li&gt;拥塞窗口是除接收窗口之外的另一个通过限制在途数据流大小以防止网络拥塞的方法。发送方尽可能多的发出拥塞窗口允许的数据量，该窗口大小有诸多方法可以实现，Vegas、Westwood、BIC或者CUBIC。不同于流控中的接收窗口，拥塞窗口是由发送方单独确定的。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;数据发送&#34;&gt;数据发送&lt;/h2&gt;

&lt;p&gt;如下图所示，一个网络栈有很多层，图中包含各层类型。&lt;/p&gt;

&lt;div align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/BG2BKK/githubio/master/static/operation_process_by_each_layer_of_tcp_ip.png&#34; width=&#34;70%&#34; height=&#34;70%&#34;&gt;&lt;p&gt;Figure 1: Operation Process by Each Layer of TCP/IP Network Stack for Data Transmission.&lt;/p&gt;&lt;/div&gt;

&lt;p&gt;图中虽然有多层，但可以简要分为3类：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;User area 用户区&lt;/li&gt;
&lt;li&gt;Kernel area 内核区&lt;/li&gt;
&lt;li&gt;Device area 设备区&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在user area和kerne area处理的任务都是由CPU完成的，所以user area和kernel area统称为&lt;strong&gt;&lt;em&gt;host&lt;/em&gt;&lt;/strong&gt;来与device area加以区分。在这里的device是&lt;strong&gt;&lt;em&gt;Network Interface Card(NIC)&lt;/em&gt;&lt;/strong&gt;，也就是网卡，用于收发数据，NIC是一个比我们常用的&amp;rdquo;局域网网卡&amp;rdquo;更准确的术语。&lt;/p&gt;

&lt;p&gt;让我们大致看看user area，首先应用程序准备好数据(右上角的user data灰色框)，然后调用&lt;strong&gt;&lt;em&gt;write()&lt;/em&gt;&lt;/strong&gt;系统调用发送数据。假设所用的socket(图中write调用的参数fd)合法，那么当发起系统调用后，发送流程切换到kernel area。&lt;/p&gt;

&lt;p&gt;POSIX系列操作系统例如Linux和Unix在应用程序通过一个file descriptor，即文件描述符fd来表示所用的socket。在POSIX系系统中，socket也是一种文件，应用程序使用的fd在进程中有其对应的file structure，与socket对应（file-&amp;gt;private_data指向对应的struct socket，此处不影响理解），图1中的文件层进行简单的检查(VFS对write()的权限检查)，然后通过调用socket的相关函数最终实现write()。&lt;/p&gt;

&lt;p&gt;内核中每个socket有两个buffer：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;一个是send socket buffer，发送缓冲区，用于发送&lt;/li&gt;
&lt;li&gt;一个是receive socket buffer，接收缓冲区，用于接收&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当&lt;strong&gt;&lt;em&gt;write&lt;/em&gt;&lt;/strong&gt;系统调用被调用时，待发送数据从用户空间复制到内核内存中，然后添加进发送缓冲区的链表末尾。这样就可以按顺序发出数据。图一中的&amp;rsquo;Sockets&amp;rsquo;那层对应的右边灰色的小格子指向socket send buffer中的数据。然后，调用TCP/IP协议栈。&lt;/p&gt;

&lt;p&gt;每个tcp类型的socket都有一个&lt;strong&gt;&lt;em&gt;TCP Control Block(TCB)&lt;/em&gt;&lt;/strong&gt;tcp控制块的数据结构，TCB包括了一个TCP连接所需要的成员，比如connection state连接状态(LISTEN, ESTABLISHED, TIME_WAIT等)、receive window接收窗口，congestion window拥塞窗口、sequence number包序号和resending timer重传定时器等。可以认为一个TCB 代表一条TCP连接。&lt;/p&gt;

&lt;p&gt;如果当前TCP状态允许数据传输，会新建一个新的TCP segment(packet，报文)；否则系统调用结束并返回错误码。&lt;/p&gt;

&lt;p&gt;下图是一个TCP报文，包括两个TCP片段：TCP header和Payload，如图2所示&lt;/p&gt;

&lt;div align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/BG2BKK/githubio/master/static/tcp_frame_structure.png&#34; width=&#34;70%&#34; height=&#34;70%&#34;&gt;&lt;p&gt;Figure 2: TCP Frame Structure .&lt;/p&gt;&lt;/div&gt;

&lt;p&gt;payload部分是待发送的数据，处于socket的未确认(unACK)发送缓冲区，每个包的payload的最大长度由对方接收窗口大小、拥塞窗口大小和maximum segment size（MSS，最大报文长度）共同决定。&lt;/p&gt;

&lt;p&gt;然后计算packet的checksum校验码，实际上，checksum计算目前由NIC用硬件实现，放在这里只是为了逻辑通顺。&lt;/p&gt;

&lt;p&gt;然后TCP报文进入下一层IP层处理，IP层添加IP头部和checksum，并进行IP路由选择。IP路由选择是选择下一跳的过程。当IP层计算并添加IP头部校验checksum后，将数据包发送到下一层Ethernet层，即数据链路层。Ethernet层采用ARP协议搜索查询下一跳IP的MAC地址，然后向报文添加Ethernet头部。添加完Ethernet头部后，host部分的报文就处理完毕了。&lt;/p&gt;

&lt;p&gt;在IP路由选择执行完毕后，根据结果选择哪个NIC作为传输接口；在host处理完报文后，调用NIC驱动发送数据。（一定要注意，NIC和NIC驱动不是一体的，前者是NIC网卡硬件，后者是运行在host和内核的驱动程序，硬件是CPU）&lt;/p&gt;

&lt;p&gt;此时，如果一个抓包软件比如tcpdump或者wireshark正在运行，kernel将报文从内核态复制一份到这些软件内存中。同样的，如果是抓接收到的包，也同样是从NIC驱动这里抓取的。一般来说，流量整形工具也是在这一层实现的。&lt;/p&gt;

&lt;p&gt;NIC驱动程序通过厂商制定的网卡与主机的通信协议向NIC请求发送packet。&lt;/p&gt;

&lt;p&gt;NIC收到发送网络包请求后，将报文复制到自己的内存中然后发送到网络。发送前，为遵守以太网标准，还要修改一些标志，包括packet的CRC校验码，IFG（Inter-Frame Gap）包内间隔和报文头等标志；CRC校验码用于数据保真，其他二者用于区分其实包还是中间包（需要翻译调整）。数据包传输速度根据网络物理速度和以太网流控制条件来调整，一般取低值，并留有一定余量。&lt;/p&gt;

&lt;p&gt;当NIC发出一个数据包，NIC向CPU发出中断；每个中断有其自己的中断号，操作系统根据中断号调用对应的驱动程序处理中断，驱动的中断处理函数是NIC驱动在OS启动时注册中断回调函数；当中断发生时，OS调用中断服务程序，然后中断服务程序向OS返回发送完成的数据包（编号）。&lt;/p&gt;

&lt;p&gt;至此我们讨论了应用程序数据发送的流程，贯穿kernel和NIC设备。而且，即使没有应用程序的写请求，kernel可以调用TCP/IP协议栈直接发送数据包。例如，当收到一个ACK后并且得知对端接收窗口扩大，kernel将自动的把仍在发送缓存中的数据打包，直接发出。&lt;/p&gt;

&lt;h2 id=&#34;数据接收&#34;&gt;数据接收&lt;/h2&gt;

&lt;p&gt;现在我们看看数据的接收流程，当数据包到来的时候，网络栈是如何处理的，如图3所示。&lt;/p&gt;

&lt;div align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/BG2BKK/githubio/master/static/operation_process_by_each_layer_of_tcp_ip_for_data_received.png&#34; width=&#34;70%&#34; height=&#34;70%&#34;&gt;&lt;p&gt;Figure 3: Operation Process by Each Layer of TCP/IP Network Stack for Handling Data Received.&lt;/p&gt;&lt;/div&gt;

&lt;p&gt;首先，NIC将数据包写入自身内存，检查该包是否CRC合法，然后将该包发送给host的内存，host的内存是NIC驱动事先向kernel申请的内存，用于接收数据包，当host分配成功，通过NIC驱动告诉NIC这块内存的地址和大小。如果NIC driver没有实现分配好内存，NIC收到数据包后会直接丢弃。&lt;/p&gt;

&lt;p&gt;当NIC将数据包写入到host的内存缓冲区后，NIC向host 操作系统发出中断信号。&lt;/p&gt;

&lt;p&gt;然后，NIC驱动来确认它是否可以处理这个新包，这个过程使用的是NIC和NIC驱动之间的通信协议。&lt;/p&gt;

&lt;p&gt;当驱动需要将数据包发送到上一层时，这个数据包必须被包装成OS可以理解的包格式。比如，linux上的sk_buff，BSD系列内核的mbuf结构，或者MS系统的NET_BUFFER_LIST结构。NIC驱动将封装后的数据包转给上层处理。&lt;/p&gt;

&lt;p&gt;链路层Ethernet层检查数据包是否合法，然后根据数据包头部的ethertype值选择上层网络协议。IPV4类型的值为0x0800。本层的工作就是去掉数据包的Ethernet头部，传送给上层IP层。&lt;/p&gt;

&lt;p&gt;IP层同样首先检查数据包合法性，采用检查IP头部的checksum字段的方式。在逻辑上进行IP路由选择，决定是否本机操作系统处理这个包，还是转发给另一个系统。如果本机处理数据包，那么IP层将根据IP头部的协议proto值选择上层传输层协议，比如TCP协议的proto值是6.本层的工作就是移除IP头部，发送给上层TCP层。&lt;/p&gt;

&lt;p&gt;同样的，TCP层检查数据包的checksum是否正确。之前说过，TCP的checksum也是由NIC计算得到的。（可以理解这些CRC校验的工作都是由NIC硬件实现的，如果硬件层没有校验通过，可以直接在网卡丢弃）&lt;/p&gt;

&lt;p&gt;然后开始采用IP:PORT四元组作为标志搜索这个数据包对应的TCP Control Block。找到TCP控制块后就找到了TCP连接，根据包协议处理数据包。如果是收到新数据，那么将其加入socket接收缓冲区中。根据TCP状态，协议栈发送TCP回复包（比如ACK包）。现在TCP/IP的接收数据流程完成了。&lt;/p&gt;

&lt;p&gt;socket接收缓冲区的大小是TCP接收窗口大小。数据接收时，TCP接受窗口扩大时TCP的吞吐能力增大；在此之前，socket的缓冲区大小由应用程序或者操作系统配置来调整，而现在新的网络栈具有自动调整接受缓冲区大小的功能。&lt;/p&gt;

&lt;p&gt;当应用程序调用read系统调用时，从user area切换到kernel area，数据从socket的缓冲区复制到user area，然后从socket缓冲区中释放。然后调用TCP层，因为socket缓冲区有了新的空间，所以TCP增大接受窗口。And it sends a packet according to the protocol status. If no packet is transferred, the system call is terminated.（待翻译）&lt;/p&gt;

&lt;h2 id=&#34;网络栈开发方向&#34;&gt;网络栈开发方向&lt;/h2&gt;

&lt;p&gt;以上描述的网络栈各层的功能都是一些基本的功能。90年代早期的网络栈功能比以上描述的还少。不过，目前最新的网络栈的功能更加丰富，复杂度更高，这些新功能根据用途有如下分类：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Packet Processing Procedure Manipulation, 控制修改包处理流程&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;类似于Netfilter(firewall, NAT)和流量控制。通过在数据包基本处理流程中插入用户代码可以实现不同功能。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Protocol Performance, 协议性能提升&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;目的是在同样的网络质量情况下，提升吞吐量、降低时延，提高稳定性。多种拥塞控制算法和附加TCP功能比如SACK（选择确认）就是这类功能。通过协议提升性能在本文中不作重点讨论。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Packet Processing Efficiency, 数据包处理效率&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;包处理效率相关的功能旨在提升每秒能够处理最大量的数据包，通过降低用于处理数据包的CPU使用率、内存占用和内存访问次数。目前有多种降低系统时延的尝试，包括并行处理、头部预测、零拷贝、单一副本、免校验、TSO、LRO和RSS等。&lt;/p&gt;

&lt;h2 id=&#34;网络栈的控制流&#34;&gt;网络栈的控制流&lt;/h2&gt;

&lt;p&gt;现在我们可以从更细节的角度观察linux网络栈的内部流程。就像其他非网络栈的子系统，linux的网络站以事件驱动的方式，当网络事件发生时进行相应处理，也就是说网络栈内只有一个进程或者控制流处理运行（其实就是kernel）。上文的图1和图3简单的表示了控制流的数据包，图4将显示更多细节。&lt;/p&gt;

&lt;div align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/BG2BKK/githubio/master/static/control_flow_in_stack.png&#34; width=&#34;70%&#34; height=&#34;70%&#34;&gt;&lt;p&gt;Figure 4: Control Flow in the Stack.&lt;/p&gt;&lt;/div&gt;

&lt;p&gt;图4的控制流(1)中，应用程序通过系统调用比如read()和write()调用TCP/IP协议栈，在这里没有数据包的传输，需要经过协议栈传输。控制流(2)与控制流(1)的不同之处在于，它要求调用TCP/IP协议栈后发送数据包，它创造一个数据包然后将该包发送到NIC驱动前的一个队列中，然后队列的实现方式决定何时将该包发送给NIC驱动。这其实就是linux中的队列方式，linux的流量控制功能就是操作这个队列实现的，默认的操作方式是FIFO，先进先出。通过使用其他队列控制方式，linux可以实现多种效果，比如人工控制丢包、包延迟和流量限制等等功能。在控制流(1)和(2)中，应用程序的处理流程最终将调用NIC驱动。&lt;/p&gt;

&lt;p&gt;控制流(3)表示TCP用到的一些定时器，比如当TIME_WAIT定时器超时后，TCP协议栈将响应并删除超时的连接。&lt;/p&gt;

&lt;p&gt;与控制流(3)类似，(4)表示超时后TCP将处理一系列待处理的数据包。比如，当重传定时器超时后，未得ACK确认的包将被重传。&lt;/p&gt;

&lt;p&gt;控制流(3)和(4)显示定时器软中断的处理流程。&lt;/p&gt;

&lt;p&gt;当NIC驱动收到NIC中断，它将释放已传输的数据包。大部分情况下，NIC驱动的处理流程在这里就终止了。控制流(5)表示数据包在传输队列中累积，NIC驱动请求软中断，然后软中断处理函数从发送队列中将累积的数据包发送给NIC驱动（请结合(5)左边的黑线）。&lt;/p&gt;

&lt;p&gt;当NIC驱动收到中断并且收到一个新的数据包，它将请求软中断。处理接收数据包的软中断调用NIC驱动并将收到的数据包传给上层处理。在LInux中，如上描述的处理接受数据包的处理方式称为New API(NAPI)。NAPI与轮询类似，因为NIC驱动并不直接向上层发送数据，而是上层从NIC驱动中主动拿数据包，这段代码称为NAPI poll(NAPI轮询)。&lt;/p&gt;

&lt;p&gt;控制流(6)显示TCP协议栈接受数据包的完整处理流程，控制流(7)表示请求更多数据包进行发送到过程。控制流(5)、(6)、(7)都是由NIC发起中断，软中断服务程序处理NIC中断实现的。&lt;/p&gt;

&lt;h2 id=&#34;怎样处理中断然后接受数据包&#34;&gt;怎样处理中断然后接受数据包&lt;/h2&gt;

&lt;p&gt;中断处理是复杂的，毕竟你需要理解与接受数据包有关的各个环节。图5显示了中断处理流程图。&lt;/p&gt;

&lt;div align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/BG2BKK/githubio/master/static/processing_interrupt_softirq_and_received_packet.png&#34; width=&#34;70%&#34; height=&#34;70%&#34;&gt;&lt;p&gt;Figure 5: Processing Interrupt, softirq, and Received Packet.&lt;/p&gt;&lt;/div&gt;

&lt;p&gt;想象下CPU 0正在执行应用程序，这个时候NIC收到一个数据包，向CPU 0产生一个中断。然后CPU执行内核中断处理程序。内核通过中断号调用中断处理程序，调用相应驱动的中断处理程序。NIC驱动释放已发送完成的数据包，然后调用napi_schedule()函数去接受数据包，该函数请求软中断（参考图4中(6)右边的黑线）。NIC驱动的中断处理程序结束，返回，控制权交回内核中断处理程序，内核中断处理程序执行刚才NIC驱动调用的napi_schedule()产生的软中断。硬中断上下文执行完成后，软中断开始执行（这里是内核的tasklet或者work_queue了吧，处于中断上下文的话，只能是tasklet，涉及到阻塞方法，比如与NIC设备的通信，就需要wait_queue了），软硬中断上下文都是由同一个进程执行的（linux kernle）。不过，软硬中断的执行栈不一样，硬中断将会屏蔽硬件中断，软中断执行期间是不屏蔽的（老生常谈）。&lt;/p&gt;

&lt;p&gt;软中断处理程序调用net_rx_action()处理收到的数据包，这个函数调用驱动的poll()方法。poll()方法调用netif_receive_skb()方法收取数据包，然后讲其逐层向上层传送。处理完以上软中断后，应用程序从断点继续执行，此时可以开始调用系统调用比如read读取数据。&lt;/p&gt;

&lt;p&gt;这就是CPU从收到硬中断到完成接收数据包的完整过程，Linux、BSD和MS Windows系统都是大同小异的。&lt;/p&gt;

&lt;p&gt;当你查看服务器CPU使用率时，有时你看到只有一个CPU在辛苦的执行软中断，这个现象我们上文描述的可以解释，只有CPU 0在响应网卡中断，使用多队列网卡、RSS和RPS（在软件层面模拟实现硬件的多队列网卡功能）可以解决这个问题，将软中断绑定到多个CPU上。&lt;/p&gt;

&lt;h2 id=&#34;相关数据结构&#34;&gt;相关数据结构&lt;/h2&gt;

&lt;p&gt;下文列出一些关键性的数据结构&lt;/p&gt;

&lt;h2 id=&#34;sk-buff-structure&#34;&gt;sk_buff structure&lt;/h2&gt;

&lt;p&gt;首先，sk_buff结构体或者skb结构体表示一个数据包，图6表示sk_buff结构体的主要部分。虽然sk_buff的功能越来越丰富，也越来越复杂，但图6足以说明sk_buff相关的通用方法。&lt;/p&gt;

&lt;div align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/BG2BKK/githubio/master/static/packet_structure_sk_buff.png&#34; width=&#34;70%&#34; height=&#34;70%&#34;&gt;&lt;p&gt;Figure 6: Packet Structure sk_buff.&lt;/p&gt;&lt;/div&gt;

&lt;h3 id=&#34;sk-buff包括数据包的data部分和元数据部分&#34;&gt;sk_buff包括数据包的Data部分和元数据部分&lt;/h3&gt;

&lt;p&gt;sk_buff直接包括数据包的数据部分，或者用指针指向它。在图6中，sk_buff结构体中的data成员指向一个skb_shared_info结构体的Ethernet到buffer成员之间的内存，而额外的数据由skb_shared_info的frags成员指向具体的内存页。&lt;/p&gt;

&lt;p&gt;sk_buff的一些基本信息，比如头部信息和包数据长度存在元数据区域(元数据待理解，初步认定是skb_shared_info)。如图6所示，链路层头部mac_header、网络层头部network_header和传输控制层头部transport_header都有对应的指针依次指向从元数据开始的地方。这种方式使得TCP协议处理更容易一些。&lt;/p&gt;

&lt;h3 id=&#34;如何添加或删除头部&#34;&gt;如何添加或删除头部&lt;/h3&gt;

&lt;p&gt;当在网络协议栈各层处理时，数据包的头部将会被添加或者删除，此时采用指针来移动到不同层的header位置最为方便高效，比如如果要删除Ethernet头部，只需要将头部指针，即sk_buff的head成员指向上一层IP头部位置即可。&lt;/p&gt;

&lt;h3 id=&#34;怎样合并或者分解数据包&#34;&gt;怎样合并或者分解数据包&lt;/h3&gt;

&lt;p&gt;在向socket缓冲区高效添加或者删除数据包的数据量时，采用链表的方式最为方便。sk_buffer的next和prev指针成员的目的就是在此。&lt;/p&gt;

&lt;h3 id=&#34;快速分配或者释放内存&#34;&gt;快速分配或者释放内存&lt;/h3&gt;

&lt;p&gt;当创建一个packet时，一个sk_buff结构体要被分配，这里需要快速分配器。比如，如果数据在万兆网卡传输，那么每秒最多将超过百万包被分配和释放。&lt;/p&gt;

&lt;h2 id=&#34;tcp-control-block&#34;&gt;TCP Control Block&lt;/h2&gt;

&lt;p&gt;第二，需要有一个结构体来表示一条TCP连接。此前，它被笼统的称为TCP控制块。Linux使用tcp_sock结构体表示TCP Control Block，如图7所示，你可以看到socket、tcp_socket和struct file之间的关系。&lt;/p&gt;

&lt;div align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/BG2BKK/githubio/master/static/tcp_connection_structure.png&#34; width=&#34;70%&#34; height=&#34;70%&#34;&gt;&lt;p&gt;Figure 7: TCP Connection Structure.&lt;/p&gt;&lt;/div&gt;

&lt;p&gt;当一个系统调用执行时，首先搜索进程的fd对应的struct file结构，对于类Uinx操作系统来说，一个socket、一个文件或者一个设备对于普通文件系统来说都抽象成struct file结构。因此，文件系统包括了基本信息，对于一个socket结构体来说，struct socket包含了与socket相关的信息，以及一个file指针，该socket结构体&lt;a href=&#34;http://lxr.free-electrons.com/source/include/linux/tcp.h&#34;&gt;同样有一个struct sock类型的指针sk成员，struct sock可强制类型转换到struct tcp_sock（参考tcp_sk函数）&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// socket 结构体, include/linux/net.h

/**
 *  struct socket - general BSD socket
 *  @state: socket state (%SS_CONNECTED, etc)
 *  @type: socket type (%SOCK_STREAM, etc)
 *  @flags: socket flags (%SOCK_NOSPACE, etc)
 *  @ops: protocol specific socket operations
 *  @file: File back pointer for gc
 *  @sk: internal networking protocol agnostic socket representation
 *  @wq: wait queue for several uses
 */
struct socket {
	socket_state		state;

	kmemcheck_bitfield_begin(type);
	short			type;
	kmemcheck_bitfield_end(type);

	unsigned long		flags;

	struct socket_wq __rcu	*wq;

	struct file		*file;
	struct sock		*sk;
	const struct proto_ops	*ops;
};

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;socket结构体指向的tcp_sock结构体除了支持TCP协议类型外还有别的比如sock，inet_sock等类型，这点可以视为某种意义上的多态。&lt;/p&gt;

&lt;p&gt;所有TCP协议的状态信息保存在tcp_sock结构体中，比如TCP的序号sequence number、接受窗口receive window、拥塞窗口和重传定时器等。&lt;/p&gt;

&lt;p&gt;socket发送缓冲区和socket接收缓冲区都是tcp_sock的sk_buff链表；tcp_sock的dst_entry成员，存储IP路由选择结果，避免再次进行路由选择，dst_entry可以进行ARP结果的快速检索，比如对端MAC地址。dst_entry是路由表的一部分，由于路由表的复杂结构，所以不在本文讨论，总之记住dst_entry可用来选择传输本数据包的网络设备NIC，NIC就是dst_entry指向的net_device成员。&lt;/p&gt;

&lt;p&gt;因此，通过struct file我们可以很容易的找到与TCP连接的所有信息，只占用少量内存，几KB而已（有很多功能添加进来，所以这部分内存从过去到现在不断增长）。&lt;/p&gt;

&lt;p&gt;最后，我们看下TCP连接的查找表，这是一个用于查找所收到数据包对应的TCP连接的哈希表，索引通过数据包的IP:PORT四元组进行Jenkins哈希算法计算得到。选择这个算法的原因是考虑到防范对此哈希表的攻击（待查）。&lt;/p&gt;

&lt;h2 id=&#34;追踪代码-如何发送数据&#34;&gt;追踪代码：如何发送数据&lt;/h2&gt;

&lt;p&gt;我们通过追踪阅读Linux kernel源码来学习TCP/IP协议栈如何执行，通过常用的读数据和写数据来观察。&lt;/p&gt;

&lt;p&gt;首先，应用程序调用write()来实现数据发送&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;SYSCALL_DEFINE3(write, unsigned int, fd, const char __user *, buf, ...)
{
	struct file *file;
	[...]
	file = fget_light(fd, &amp;amp;fput_needed);
	[...] ===&amp;gt;
	ret = filp-&amp;gt;f_op-&amp;gt;aio_write(&amp;amp;kiocb, &amp;amp;iov, 1, kiocb.ki_pos);
 
struct file_operations {
	[...]
	ssize_t (*aio_read) (struct kiocb *, const struct iovec *, ...)
	ssize_t (*aio_write) (struct kiocb *, const struct iovec *, ...)
	[...]
};
 
static const struct file_operations socket_file_ops = {
	[...]
	.aio_read = sock_aio_read,
	.aio_write = sock_aio_write,
	[...]
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当应用程序调用write()系统调用，内核在文件层执行write()，首先找到fd对应的struct file，然后调用file_operations中的aio_write()，它是一个函数指针，最终调用的是socket_file_ops的sock_aio_write()方法。kenerl中通过函数表的方式实现接口，这点十分常见，但是对于TCP的具体指向方式，可以以后详查(TODO LIST)。&lt;/p&gt;

&lt;p&gt;接下来是sock_aio_write()的具体调用过程。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;static ssize_t sock_aio_write(struct kiocb *iocb, const struct iovec *iov, ..)
{
	[...]
	struct socket *sock = file-&amp;gt;private_data;
	[...] ===&amp;gt;
	return sock-&amp;gt;ops-&amp;gt;sendmsg(iocb, sock, msg, size);
 
struct socket {
	[...]
	struct file *file;
	struct sock *sk;
	const struct proto_ops *ops;
};
 
const struct proto_ops inet_stream_ops = {
	.family = PF_INET,
	[...]
	.connect = inet_stream_connect,
	.accept = inet_accept,
	.listen = inet_listen,
	.sendmsg = tcp_sendmsg,
	.recvmsg = inet_recvmsg,
	[...]
};
 
struct proto_ops {
	[...]
	int (*connect) (struct socket *sock, ...)
	int (*accept) (struct socket *sock, ...)
	int (*listen) (struct socket *sock, int len);
	int (*sendmsg) (struct kiocb *iocb, struct socket *sock, ...)
	int (*recvmsg) (struct kiocb *iocb, struct socket *sock, ...)
	[...]
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;sock_aio_write()函数从struct file中获取struct socket，然后调用socket的sendmsg方法，sendmsg依然是个函数指针，指向的是struct socket中的proto_ops函数表的sendmsg，IPv4协议族的TCP类型的proto_ops操作表是inet_stream_ops，将sendmsg实现为tcp_sendmsg。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int tcp_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg, size_t size)
{
	struct sock *sk = sock-&amp;gt;sk;
	struct iovec *iov;
	struct tcp_sock *tp = tcp_sk(sk);
	struct sk_buff *skb;

	[...]

	mss_now = tcp_send_mss(sk, &amp;amp;size_goal, flags);

	/* Ok commence sending. */
	iovlen = msg-&amp;gt;msg_iovlen;
	iov = msg-&amp;gt;msg_iov;
	copied = 0;

	[...]

	while (--iovlen &amp;gt;= 0) {
		int seglen = iov-&amp;gt;iov_len;
		unsigned char __user *from = iov-&amp;gt;iov_base;
		iov++;
		while (seglen &amp;gt; 0) {
			int copy = 0;
			int max = size_goal;
	
			[...]
		
			skb = sk_stream_alloc_skb(sk, select_size(sk, sg), sk-&amp;gt;sk_allocation);
			if (!skb)
				goto wait_for_memory;
			/*
			* Check whether we can use HW checksum.
			*/
			if (sk-&amp;gt;sk_route_caps &amp;amp; NETIF_F_ALL_CSUM)
				skb-&amp;gt;ip_summed = CHECKSUM_PARTIAL;
		
			[...]
			skb_entail(sk, skb);
		
			[...]
			/* Where to copy to? */
			if (skb_tailroom(skb) &amp;gt; 0) {
		
				/* We have some space in skb head. Superb! */
				if (copy &amp;gt; skb_tailroom(skb))
					copy = skb_tailroom(skb);
				if ((err = skb_add_data(skb, from, copy)) != 0)
					goto do_fault;
				[...]
			
				if (copied)
					tcp_push(sk, flags, mss_now, tp-&amp;gt;nonagle);
			
				[...]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;tcp_sendmsg()首先从参数struct socket *sock获取tcp_sock，即TCP Control Blcok，然后将应用程序请求发送的数据复制到socket的发送缓冲区中。当复制数据到sk_buff中前，首先获取socket的Maximum Segment Size(MSS，最大消息长度)，MSS代表一个TCP包可携带的最大数据量（当然如果支持TSO或者GSO的话可以大于MSS），然后创建数据包，即sk_stream_alloc_skb()函数创建一个新的sk_buff，返回skb，skb_entail()函数将新建的skb添加到socket的发送缓冲区中（前文提到该缓冲区是一个链表）。skb_add_data函数将应用程序的数据复制到skb的buffer中。所有的数据将在重复调用这一过程中复制完成。此时，socket的发送缓冲区将以链表形式组织起MSS大小的若干个sk_buff。最后，调用tcp_push()函数将可发送的数据以数据包的形式发送出去，实现write()掉用的完整流程。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;static inline void tcp_push(struct sock *sk, int flags, int mss_now, ...)
	[...] ===&amp;gt;
	static int tcp_write_xmit(struct sock *sk, unsigned int mss_now, ...)
	int nonagle,
	{
		struct tcp_sock *tp = tcp_sk(sk);
		struct sk_buff *skb;
		[...]
		while ((skb = tcp_send_head(sk))) {
			[...]
			cwnd_quota = tcp_cwnd_test(tp, skb);
			if (!cwnd_quota)
			break;
			 
			if (unlikely(!tcp_snd_wnd_test(tp, skb, mss_now)))
			break;
			[...]
			if (unlikely(tcp_transmit_skb(sk, skb, 1, gfp)))
			break;
			 
			/* Advance the send_head. This one is sent out.
			* This call will increment packets_out.
			*/
			tcp_event_new_data_sent(sk, skb);
			[...]

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;tcp_push()函数尽可能的将TCP允许发送的sk_buff按序号发送出去。首先调用tcp_send_head()函数获取发送缓冲区队列头的sk_buff，然后tcp_cwnd_test()和tcp_snd_wnd_test()函数用来检查拥塞窗口和接收窗口是否允许新的数据包发送，如果可以，调用tcp_transmit_skb()函数新建网络数据包，用于发送。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;
static int tcp_transmit_skb(struct sock *sk, struct sk_buff *skb,int clone_it, gfp_t gfp_mask)
{
	const struct inet_connection_sock *icsk = inet_csk(sk);
	struct inet_sock *inet;
	struct tcp_sock *tp;

	[...]

	if (likely(clone_it)) {
		if (unlikely(skb_cloned(skb)))
		skb = pskb_copy(skb, gfp_mask);
		else
		skb = skb_clone(skb, gfp_mask);
		if (unlikely(!skb))
		return -ENOBUFS;
	}

	[...]

	skb_push(skb, tcp_header_size);
	skb_reset_transport_header(skb);
	skb_set_owner_w(skb, sk);

	/* Build TCP header and checksum it. */
	th = tcp_hdr(skb);
	th-&amp;gt;source = inet-&amp;gt;inet_sport;
	th-&amp;gt;dest = inet-&amp;gt;inet_dport;
	th-&amp;gt;seq = htonl(tcb-&amp;gt;seq);
	th-&amp;gt;ack_seq = htonl(tp-&amp;gt;rcv_nxt);

	[...]

	icsk-&amp;gt;icsk_af_ops-&amp;gt;send_check(sk, skb);

	[...]

	err = icsk-&amp;gt;icsk_af_ops-&amp;gt;queue_xmit(skb);
	if (likely(err &amp;lt;= 0))
		return err;
	tcp_enter_cwr(sk, 1);
	return net_xmit_eval(err);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;tcp_transmit_skb()首先调用pskb_copy()创建待发送sk_buff的副本，仅复制sk_buff的元数据；然后调用skb_push()锁定tcp头部区域，然后填充头部字段，send_check()计算TCP头部的checksum。最后，queue_xmit()将数据包skb转移到下一层IP层，IPv4的queue_xmit指针指向函数ip_queue_xmit()。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;
int ip_queue_xmit(struct sk_buff *skb)
{
	[...]
	rt = (struct rtable *)__sk_dst_check(sk, 0);
	[...]

	/* OK, we know where to send it, allocate and build IP header. */
	skb_push(skb, sizeof(struct iphdr) + (opt ? opt-&amp;gt;optlen : 0));
	skb_reset_network_header(skb);
	iph = ip_hdr(skb);
	*((__be16 *)iph) = htons((4 &amp;lt;&amp;lt; 12) | (5 &amp;lt;&amp;lt; 8) | (inet-&amp;gt;tos &amp;amp; 0xff));
	if (ip_dont_fragment(sk, &amp;amp;rt-&amp;gt;dst) &amp;amp;&amp;amp; !skb-&amp;gt;local_df)
		iph-&amp;gt;frag_off = htons(IP_DF);
	else
		iph-&amp;gt;frag_off = 0;
	iph-&amp;gt;ttl = ip_select_ttl(inet, &amp;amp;rt-&amp;gt;dst);
	iph-&amp;gt;protocol = sk-&amp;gt;sk_protocol;
	iph-&amp;gt;saddr = rt-&amp;gt;rt_src;
	iph-&amp;gt;daddr = rt-&amp;gt;rt_dst;
	[...]
	res = ip_local_out(skb);
	[...] ===&amp;gt;
	int __ip_local_out(struct sk_buff *skb)
	[...]
	ip_send_check(iph);
	return nf_hook(NFPROTO_IPV4, NF_INET_LOCAL_OUT, skb, NULL,	skb_dst(skb)-&amp;gt;dev, dst_output);

[...] ===&amp;gt;
int ip_output(struct sk_buff *skb)
{
		struct net_device *dev = skb_dst(skb)-&amp;gt;dev;
		[...]
		skb-&amp;gt;dev = dev;
		skb-&amp;gt;protocol = htons(ETH_P_IP);
		return NF_HOOK_COND(NFPROTO_IPV4, NF_INET_POST_ROUTING, skb, NULL, dev,
		ip_finish_output,

[...] ===&amp;gt;
static int ip_finish_output(struct sk_buff *skb)
{
	[...]
	if (skb-&amp;gt;len &amp;gt; ip_skb_dst_mtu(skb) &amp;amp;&amp;amp; !skb_is_gso(skb))
		return ip_fragment(skb, ip_finish_output2);
	else
		return ip_finish_output2(skb);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ip_queue_xmit()方法负责执行IP层的任务，__sk_dst_check()检查缓存的路由结果是否合法。如果此时没有缓存的路由，或者缓存路由结果过期，就会进行IP路由查找。然后调用skb_push()锁定IP包头，填充IP包头部字段。接着调用ip_send_check()计算IP头的checksum，然后使用nf_hook调用netfilter模块，nf_hook()方法设置回调函数为dst_output，该函数被调用时，作为函数指针指向的是ip_output()函数。在ip_output()函数中，设置ip_finish_output()为回调函数，当发送数据包需要被分片发送时，进行分片，否则调用ip_finish_output2()，添加Ethernet Header，进入链路层Ethernet层。这样，一个数据包最终生成。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int dev_queue_xmit(struct sk_buff *skb)
[...] ===&amp;gt;

static inline int __dev_xmit_skb(struct sk_buff *skb, struct Qdisc *q, ...)
[...]
	if (...) {
		....
	} 
	else if ((q-&amp;gt;flags &amp;amp; TCQ_F_CAN_BYPASS) &amp;amp;&amp;amp; !qdisc_qlen(q) &amp;amp;&amp;amp; qdisc_run_begin(q)) 
	{
		[...]
		if (sch_direct_xmit(skb, q, dev, txq, root_lock)) {

[...] ===&amp;gt;
int sch_direct_xmit(struct sk_buff *skb, struct Qdisc *q, ...)
	[...]
	HARD_TX_LOCK(dev, txq, smp_processor_id());
	if (!netif_tx_queue_frozen_or_stopped(txq))
		ret = dev_hard_start_xmit(skb, dev, txq);
	HARD_TX_UNLOCK(dev, txq);
	[...]
}

int dev_hard_start_xmit(struct sk_buff *skb, struct net_device *dev, ...)
	[...]
	if (!list_empty(&amp;amp;ptype_all))
		dev_queue_xmit_nit(skb, dev);
	[...]
	rc = ops-&amp;gt;ndo_start_xmit(skb, dev);
	[...]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上层最终生成数据包后，函数dev_queue_xmit()将数据包发送出去。首先，数据包以qdisc方式传递过去；如果采用默认数据包入队规则（FIFO）并且队列为空，sch_direct_xmit()函数将直接把数据包发送给网卡驱动，越过缓冲队列；该函数调用dev_hard_start_xmit()函数选择对应的驱动并发送。在调用网卡驱动前，设备的TX队列将被加锁，防止在多任务同时访问网络设备。由于kernel已经向设备的TX队列加锁，所以设备驱动的发送代码不需要额外加锁。这和接下来要讨论的并行处理紧密相关。&lt;/p&gt;

&lt;p&gt;ndo_start_xmit()函数负责调用NIC驱动代码。在调用之前你可以看到ptype_all和dev_queue_xmit_nit()语句，ptype_all是一个包括处理模块的链表，比如抓包模块，如果一个抓包程序在运行中，这个数据包将被ptype_all复制给这个程序。所以，类似于tcpdump这类软件显示的数据包，其实是发送给网卡驱动的；响应的tcpdump显示收到的数据包也是从这层拿到的。此时数据包未携带checksum，或者如果此时TSO使能的话，NIC将会操作编辑这个包。所以tcpdump抓到的包和实际发到网络的包还是有一定区别的。当完成发送数据包后，网卡驱动的终端处理程序返回发送的sk_buff。&lt;/p&gt;

&lt;h2 id=&#34;追踪代码-如何接收数据&#34;&gt;追踪代码：如何接收数据&lt;/h2&gt;

&lt;p&gt;姑且认为接收代码的流程与发送代码区别不大，所以我们先进行下一部分。&lt;/p&gt;

&lt;h2 id=&#34;nic和nic驱动是怎样通信的&#34;&gt;NIC和NIC驱动是怎样通信的&lt;/h2&gt;

&lt;p&gt;NIC和NIC驱动之间的通信属于网络栈的最底层，往往被人忽视。然而NIC目前在网络性能方面承担着越来越多的任务，了解基本的操作模式将帮你学习到更多。&lt;/p&gt;

&lt;p&gt;驱动和NIC之间是异步通信的。首先，NIC驱动请求发送一个数据包后，CPU转向执行其他任务，并不阻塞等待响应；然后NIC发送数据包，通知CPU；最后NIC驱动将发送完成的数据包返回给上层。与发送一样，数据接收也一样是异步的，首先，NIC驱动请求接收一个包，然后CPU转而执行其他任务，然后NIC收到包后，通知CPU，NIC驱动处理收到的包处理并返回（由之前图4所示，NIC驱动注册时会请求kernel提前分配好缓存收到数据包的内存，NIC接受指令将数据包写入这部分内存）。&lt;/p&gt;

&lt;p&gt;所以，有一个空间，用于存放请求和响应是很必要的。大部分NIC使用环状结构(ring structure)，环状结构与普通队列结构类似，有固定的容量，一个单位存储一个请求或者响应。使用时也是按序处理，区别在于到达队列末尾后重头开始，形成一个环。&lt;/p&gt;

&lt;p&gt;如图8所示的包发送流程图，我们可以看到ring是怎样工作的。&lt;/p&gt;

&lt;div align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/BG2BKK/githubio/master/static/driver_nic_communication_how_to_transmit_packet.png&#34; width=&#34;70%&#34; height=&#34;70%&#34;&gt;&lt;p&gt;Figure 8: Driver-NIC Communication: How to Transmit Packet.&lt;/p&gt;&lt;/div&gt;

&lt;p&gt;NIC驱动收到上层发来的数据包后，创建NIC可以理解的发送描述符(send descriptor)，发送描述符包括包大小、物理地址等信息；NIC要求通过物理地址访问NIC驱动的内存，所以NIC驱动需要将包的虚拟地址转换为物理地址。然后NIC驱动将send descriptor加入到发送环状缓冲(Send TX Ring Buffer)，如图8的流程(1)所示。&lt;/p&gt;

&lt;p&gt;然后，NIC驱动通知NIC有新的发送请求，见流程(2)，NIC驱动直接将这个请求写入到NIC的内存地址中，在这里，CPU采用Programmed I/O(PIO)的方法，直接将数据写到设备（其实这里如果开发过Linux 设备驱动，比如以前开发过的
PCIE驱动就知道，将PCIE设备的配置寄存器映射到Host的内存空间中，kernel可以像访问自身内存一样读写这些地址，进而将控制指令写入设备中）。被通知的NIC从host的内存（发送环状内存缓冲区）以DMA方式获取发送描述符，见流程(3)。拿到发送描述符后，获得数据包在host内存的的物理地址和大小，然后将数据包以DMA方式读出。&lt;/p&gt;

&lt;p&gt;NIC取得发送数据包后，计算包的checksum然后加到数据包里，然后发送，见流程(5)。发送完成后，NIC将发送的数据包数量写回host内存(流程6)；然后向CPU发起中断(流程7)。NIC驱动独处发送了哪些数据包后，将数据包返回。(The NIC sends packets (5) and then writes the number of packets that are sent to the host memory (6). Then, it sends an interrupt (7). The driver reads the number of packets that are sent and then returns the packets that have been sent so far.)&lt;/p&gt;

&lt;p&gt;如图9所示，我们可以看到读取数据包流程图.&lt;/p&gt;

&lt;div align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/BG2BKK/githubio/master/static/driver_nic_cmomunication_how_to_receive_packets.png&#34; width=&#34;70%&#34; height=&#34;70%&#34;&gt;&lt;p&gt;Figure 9: Driver-NIC Communication: How to Receive Packets.&lt;/p&gt;&lt;/div&gt;

&lt;p&gt;首先，NIC驱动在host分配用于存储接收数据包和接收描述符的内存。接收描述符包括缓冲区大小和物理地址，与发送描述符一样都是物理地址，用于DMA传输。然后，NIC驱动将接收描述符添加到RX ring中(流程1)。通过PIO，NIC驱动将新的接收描述符地址写入NIC中(流程2)，NIC从Rx ring中以DMA方式获取接收描述符，获得用于接收数据包的缓冲区的大小和物理地址并存储(流程3)。&lt;/p&gt;

&lt;p&gt;NIC收到数据包后(流程4)，NIC将数据包写入实现分配好的host内存中(流程5),如果网卡有计算数据包checksum的功能，那么NIC此时计算数据包的checksum。接收数据包的大小、checksum和其他信息存储在另一个环状buffer(the receive return ring，接收返回环 )中(流程6)。接收返回环也存储NIC处理接收到数据包的结果，比如返回包。然后NIC发出中断(流程7)，NIC驱动从接收返回包中获取包的信息，然后处理数据包。如果必要的话，NIC驱动还会继续分配内存并重复流程(1)和(2).&lt;/p&gt;

&lt;p&gt;在调优网络栈的时候，大家都认为环状缓存大小和中断设置要互相匹配。当发送环状缓存Tx ring比较大时，可以一次发出较多请求；当Rx ring比较大时，可以一次收到较多数据包。大Ring buffer可以并发大量发送操作，提高工作能力；实际实现中，NIC使用一个定时器定期收集处理中断，减少CPU中断的次数，以免CPU为处理中断而分心。&lt;/p&gt;

&lt;h2 id=&#34;缓存和流控制&#34;&gt;缓存和流控制&lt;/h2&gt;

&lt;p&gt;流控制是网络栈各层通力合作实现的。图10显示发送数据时网络栈的各级缓存。首先，应用程序创建数据，添加到socket发送缓存中，如果缓存没有内存可用，则send/write系统调用返回失败或者堵塞。因此，应用程序流向kernel的数据流速由socket缓冲区大小来限制。&lt;/p&gt;

&lt;div align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/BG2BKK/githubio/master/static/buffers_related_to_packet_transmission.png&#34; width=&#34;70%&#34; height=&#34;70%&#34;&gt;&lt;p&gt;Figure 10: Buffers Related to Packet Transmission.&lt;/p&gt;&lt;/div&gt;

&lt;p&gt;TCP协议栈创建和发送数据包，通过发送队列transmit queue(qdisc)向NIC驱动发送。这是个典型的FIFO队列，队列长度可以由ifconfig工具配置，执行ifconfig工具结果中的txqueuelen的值，一般为1000，意味着缓存1000个数据包。&lt;/p&gt;

&lt;p&gt;环状发送队列(TX ring)处于NIC驱动和NIC之间，正如上一章提到的，Tx ring可被认为是发送请求队列。如果Tx ring满，此时NIC驱动不能发出发送请求，那么待发送的数据包将会累积在TCP/IP协议栈和NIC驱动之间的qdisc中，如果累积数据包超过qdisc大小，那么再想发送新包，会被直接丢弃。&lt;/p&gt;

&lt;p&gt;NIC将待发送数据包存储在自身缓存中，包速率主要由NIC的物理速度决定。而且由于链路层Ethernet layer的流控制，如果NIC的接收缓冲区没有空间，那么发送数据包也将停止（可以猜测原因是自身停止发送后，对端将不会再发送数据包过来，有助于NIC和NIC驱动将拥塞在接受缓冲区的数据包处理完）。&lt;/p&gt;

&lt;p&gt;当发送自kernel的数据包速度大于发送自NIC的数据包速度时，包将拥堵在NIC的缓存中。如果NIC自身缓存没有多余空间，NIC将不会从Tx ring中去取发送请求request；这样的话，越来越多的发送请求累积在Tx ring中，最终Tx ring也堵满；此时NIC驱动再也不能发起新的发送请求，并且要发送的新包将堵塞在qdisc中；就这样，性能衰退从底向上传递。（感觉这里我们可以通过检测各级buffer的堵塞情况，判断程序堵塞在哪一步）&lt;/p&gt;

&lt;p&gt;图11显示接受数据包的传递过程。首先，收到的数据包将缓存在NIC自身缓存中。从流控制的角度来看，NIC和NIC驱动之间的Rx ring队列作为缓存，NIC驱动从Rx ring中将已接受数据包的请求取出，发给上层，在这里NIC驱动和协议栈之前没有缓冲区，因为这里是通过kernel调用NAPI去poll已收到的数据包的。(需要想想怎么翻译).这里可以认为上层直接从Rx ring中获取数据包。网络包的数据部分将上传缓存在socket的接收缓冲区中，应用程序随后从socket的接受缓冲区中读取数据。&lt;/p&gt;

&lt;div align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/BG2BKK/githubio/master/static/buffers_related_to_packaet_receiving.png&#34; width=&#34;70%&#34; height=&#34;70%&#34;&gt;&lt;p&gt;Figure 11: Buffers Related to Packet Receiving.&lt;/p&gt;&lt;/div&gt;

&lt;h2 id=&#34;to-be-continued&#34;&gt;To Be Continued&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://static.lwn.net/images/pdf/LDD3/ch17.pdf&#34;&gt;ldd&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>futex和linux的线程同步机制</title>
      <link>https://bg2bkk.github.io/post/futex%E5%92%8Clinux%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Thu, 13 Oct 2016 13:57:31 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/futex%E5%92%8Clinux%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/nellson/article/details/5400360#&#34;&gt;futex初体验&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.sina.com.cn/s/blog_e59371cc0102v29b.html&#34;&gt;阿里基础架构事业群的博客关于futex的文章&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.dbafree.net/?p=1128&#34;&gt;linux线程同步机制&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;Linux中的线程同步机制(二)–In Glibc

&lt;ul&gt;
&lt;li&gt;大部分的glibc的同步方式，mutex或者semaphore，大多基于futex的方式，首先进行用户态检查，未果的话进行futex系统调用。这是我疑惑为什么futex这么常用却在代码层面上看不到它，原因是我们使用的都是基于futex的机制&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Linux中的线程同步机制(三)–Practice

&lt;ul&gt;
&lt;li&gt;pthread库中的pthread_join也是基于futex的哦，当父进程执行pthread_join它的某一个子线程时，如果子线程已经执行完毕，则父进程不会调用futex系统调用，如果子线程仍然执行中，那么父进程调用futex系统调用进行FUTEX_WAIT休眠，等待子线程的唤醒&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;好文章，值得深挖和思考&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;man page

&lt;ul&gt;
&lt;li&gt;先通过__sync_bool_compare_and_swap等原子操作比对futex的值是否有变化，如果没有，说明没有进程竞争。这里都是用户态执行的&lt;/li&gt;
&lt;li&gt;如果有变化，说明有进程竞争了，所以这时系统调用futex进行FUTEX_WAIT，使得本进程休眠或休眠一段时间，直到有别的进程FUTEX_WAKE它&lt;/li&gt;
&lt;li&gt;说白了，futex针对有些同步场景中，尽管没有竞争发生，但是还要陷入内核态去获得锁或者标志位然后同步的情况，futex可以仅通过原子性的内核态即可实现线程安全&lt;/li&gt;
&lt;li&gt;提供futex_demo.c

&lt;ul&gt;
&lt;li&gt;如果将futex1和futex2互换下，画面太美不敢看，CPU暴涨100%&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;futex(0x7f99372d3004, FUTEX_WAIT, 0, NULL) = -1 EAGAIN (Resource temporarily unavailable)
futex(0x7f99372d3004, FUTEX_WAIT, 0, NULL) = -1 EAGAIN (Resource temporarily unavailable)
futex(0x7f99372d3004, FUTEX_WAIT, 0, NULL) = -1 EAGAIN (Resource temporarily unavailable)
futex(0x7f99372d3004, FUTEX_WAIT, 0, NULL) = -1 EAGAIN (Resource temporarily unavailable)
futex(0x7f99372d3004, FUTEX_WAIT, 0, NULL) = -1 EAGAIN (Resource temporarily unavailable)
futex(0x7f99372d3004, FUTEX_WAIT, 0, NULL) = -1 EAGAIN (Resource temporarily unavailable)
futex(0x7f99372d3004, FUTEX_WAIT, 0, NULL) = -1 EAGAIN (Resource temporarily unavailable)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>为什么我喜欢读书</title>
      <link>https://bg2bkk.github.io/post/why_to_read/</link>
      <pubDate>Sun, 18 Sep 2016 19:43:59 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/why_to_read/</guid>
      <description>&lt;p&gt;我们都知道实验新药的时候首先要在实验大鼠身上实行，有些时候我们发现，明明在大鼠身上具有良好功效的药品，在人身上的临床效果并不明显。我们此时可能会从鼠和人类的基因的区别、体质等方面找原因，这是受过基本科研训练的人会有的正常想法：控制变量法。其实我们可能忽略了一个点，那就是，实验大鼠从小生活在无菌环境下，而人并不是。实验大鼠在无菌环境下出生和长大，并不会遇到某些细菌，自然不会建立起免疫机制，可与之类比的大概是人类婴儿吧。科学家们通过对比实验大鼠和农场中生活的野鼠，确认野鼠体质与成年人类更为接近，因此在实验新药的时候会更倾向于使用农场大鼠。这个案例告诉我们，遇到问题时，我们一般会从受到过的训练中获取方法，快速反应去比对变量，但同时眼睛将固定于自己更想看到的部分，而没有跳出来看问题。在分析系统性能问题时，对某个瓶颈点百思不得其解时，这个时候是否可以把自己跳出来，多想想其他变量，甚至是其他更显得“弱智”的因素。&lt;/p&gt;

&lt;p&gt;有时候阅读一些技术文章时，会有这样一种感觉：这和理论不太一样啊。读林佩满的wireshark的书时，他分析过这样一个问题：某厂某个文件传输的产品在竞标时，发现大文件通过网络传输，从上海发往北京时很慢，需要很长时间才能将文件发送完成，而同时测试网速发现完全不是瓶颈，带宽利用率低到个位数；林在通过wireshark抓包时，发现有非常多的数据包被重传了多次，并且是毫无意义的重传；配管人员配置数据传送采用UDP方式，理论上讲不需要三次握手，且不需要发送确认的UDP传输更适合发送大文件，比如FTP协议就是基于UDP实现的，课本上都这么说。然而实际情况是，发送数据从上海到北京，会经过多多少少的中间结点，客户端发送较大的数据包，中途转发时，一些设备可能将大包拆成小包发送，对于UDP协议而言，如果最终小包里有一个包传输失败，那么需要将整个大包重传，而对于TCP协议而言，哪个小包没有收到，由于TCP头部的序号，客户端将只需要重传丢失的这个小包即可，避免了大量的无意义的重传；将传输方式改为TCP传输后，带宽利用率果然一下就上去了，这里我们的结论是远途传输大文件或大数据包时，TCP的性能由于UDP，这和课本上讲的很不一样。很多知识都不是一成不变的，会根据落地情况而调整、而改变，更有可能进化成不同形态。我想起前几天在火车上看到的一篇文章，城市里的灯光将会吸引虫子，趋光的虫子绕着灯泡一圈圈转，最后力竭饿死，这是个老知识了；而科学家经过实验，从城市和郊区抓取同样数量的飞虫，放在一个房间里观察，发现郊区的飞虫全部围绕着灯泡，而城市中的飞虫则有一小部分对灯光不感兴趣。科学家做出的结论是，城市中的飞虫有一部分进化出了不那么趋光的特性，基因得以保留。所以，我们看到，知识不是一成不变的，尽量做到不先入为主，从实际情况出发来分析问题。&lt;/p&gt;

&lt;p&gt;说到实际情况出发，与一个朋友聊epoll在实际使用中会遇到的一些问题，对于多进程（线程）程序而言，具有父子关系的两个进程共享一个epoll fd，A进程通过epoll_ctl将fd添加进epfd的监听fd列表中，如果有fd有事件发生，发生事件的fd有的是A添加的，有的是B添加的，如果此时唤醒的是B进程，B进程将该epfd监听的所有有事件发生的fd取出，进行处理时，遇到有些不是自己添加的fd时，这个fd对B进程而言是无效的，如果不做处理，去read或者write它，可能会导致core dump，当然，我还没有自己做实验验证，但是理论上讲，这是会发生的。&lt;/p&gt;

&lt;p&gt;在技术书之外，其实还有非常多的有趣的书，使人明事里、断情势，提升人的气质，这是一个大的范畴，我愿接下来一点点的分享我的读书感受。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>C&#43;&#43;基础知识学习</title>
      <link>https://bg2bkk.github.io/post/cpp_basis/</link>
      <pubDate>Tue, 23 Aug 2016 19:52:25 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/cpp_basis/</guid>
      <description>

&lt;h2 id=&#34;static和const关键字各自的作用&#34;&gt;static和const关键字各自的作用&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;static关键字&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在函数体内声明的话，static变量只分配一次，作用域范围也在该函数体内；当下次调用该函数时，该值保持不变&lt;/li&gt;
&lt;li&gt;模块内的static变量的作用域是模块内&lt;/li&gt;
&lt;li&gt;类的static变量属于整个类，而不是某个对象，所有对象都共有这一份拷贝&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;const关键字&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;定义常量；首次定义必须初始化，之后不能赋值&lt;/li&gt;
&lt;li&gt;函数声明时，用const修饰形参，可以保证不被函数体修改&lt;/li&gt;
&lt;li&gt;可以修饰类的成员函数，保证其返回值不为“左值”&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;拷贝构造函数和赋值构造函数&#34;&gt;拷贝构造函数和赋值构造函数&lt;/h2&gt;

&lt;p&gt;C++的拷贝构造函数、重载赋值构造函数，以及析构函数，属于C++赋值控制的范畴&lt;/p&gt;

&lt;p&gt;如果没有手动实现，编译器会自动生成一个；编译器会自动生成以下四个成员函数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1. 构造函数&lt;/li&gt;
&lt;li&gt;2. 析构函数&lt;/li&gt;
&lt;li&gt;3. 拷贝构造函数&lt;/li&gt;
&lt;li&gt;4. 赋值构造函数&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;
class String {
public:
	String(const char *);			// 构造函数
	String(const String &amp;amp;other);	// 拷贝构造函数
	String &amp;amp; operator=( const String &amp;amp;other); // 赋值构造函数
	~String();						// 析构函数
private:
	char *m_data;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果有手动实现，则会替代编译器的行为；除了析构函数，析构函数用于完成对象的释放操作，即使我们手动实现，编译器也会实现一份，这时析构函数可以让我们用来释放动态分配的内存.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;拷贝构造函数&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;String::String(const String &amp;amp;other) {
	int len = strlen(other.m_data);
	m_data = new char[len + 1];
	strcpy(m_data, other.m_data);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;* 如下几种情况下，拷贝构造函数被调用:
    * 1. 定义新对象，并用已有对象初始化新对象：即 String obj = other，或者 String obj(other)时，此时String(const String &amp;amp;other)被调用
    * 2. 对象作为参数传递时，函数将建立对象的临时拷贝
    * 3. 对象作为函数的返回值时，函数建立临时拷贝，并将其返回
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;赋值构造函数&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;String &amp;amp; operator=(const String &amp;amp;other) {
	if( this == &amp;amp;other)
		return *this;
	delete []m_data;

	int len = strlen(other.m_data);
	m_data = new char[len + 1];
	strcpy(m_data, other.m_data);

	return *this;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;* 赋值构造函数的用法
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;String obj;
obj = other;

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;* 拷贝构造函数
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;String obj = other;   //或者
String obj(other);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而在前者的&lt;strong&gt;&lt;em&gt;obj = other&lt;/em&gt;&lt;/strong&gt; 和后者的&lt;strong&gt;&lt;em&gt;String obj=other&lt;/em&gt;&lt;/strong&gt;不同，前者表示obj是一个未初始化的对象，通过&lt;strong&gt;&lt;em&gt;=&lt;/em&gt;&lt;/strong&gt;进行赋值，后者中的&lt;strong&gt;&lt;em&gt;=&lt;/em&gt;&lt;/strong&gt;是使用other对obj进行初始化。&lt;/p&gt;

&lt;p&gt;在赋值构造函数中，&lt;strong&gt;&lt;em&gt;=&lt;/em&gt;&lt;/strong&gt;缺省操作是将成员变量的值赋值，这时函数成员的旧值自然被丢弃，比如指针被赋予新值，旧值丢弃；然而指针旧值指向的内存却并未释放；因此包含动态分配成员的类提供拷贝构造函数外，还应该考虑重载&lt;strong&gt;&lt;em&gt;=&lt;/em&gt;&lt;/strong&gt;赋值操作符&lt;/p&gt;

&lt;h2 id=&#34;抽象类与纯虚函数&#34;&gt;抽象类与纯虚函数&lt;/h2&gt;

&lt;p&gt;纯虚函数是在基类中声明的虚函数，在基类中没有定义，声明方法是在函数原型后加&lt;strong&gt;&lt;em&gt;=0&lt;/em&gt;&lt;/strong&gt;，例如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;virtual void function() = 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;纯虚函数要求基类的所有派生类都要定义自己的实现方法，除非派生类也是抽象类，因此纯虚函数主要功能是实现接口声明。至少含有一个纯虚函数的类被称为抽象类。&lt;/p&gt;

&lt;h2 id=&#34;基类的虚析构函数&#34;&gt;基类的虚析构函数&lt;/h2&gt;

&lt;p&gt;在多态使用时，如果new一个子类对象，而用父类类型指针指向它来使用，delete父类类型指针的时候，只释放父类类型的资源，子类的虚构函数并不存在，导致资源不能及时释放。因此将父类的析构函数设置为虚函数，释放派生类对象时，链式调用析构函数，派生类析构函数先调用，父类的析构函数后调用。&lt;a href=&#34;http://blog.csdn.net/starlee/article/details/619827&#34;&gt;参考链接&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;一句话，基类的析构函数设置为虚，可以在释放时链式释放子类对象内存，防止内存泄露。不过这个机制，还是无法释放类中的动态分配的内存，所以良好的编程习惯是不挖坑的基础。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>redis过期清除机制及应用方法</title>
      <link>https://bg2bkk.github.io/post/redis%E8%BF%87%E6%9C%9F%E6%B8%85%E9%99%A4%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%BA%94%E7%94%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 01 Aug 2016 13:26:07 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/redis%E8%BF%87%E6%9C%9F%E6%B8%85%E9%99%A4%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%BA%94%E7%94%A8%E6%96%B9%E6%B3%95/</guid>
      <description>

&lt;h2 id=&#34;redis过期清除和淘汰机制&#34;&gt;redis过期清除和淘汰机制&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;过期时间设置&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;expire key seconds&lt;/li&gt;
&lt;li&gt;该命令设置指定key超时的秒数，超过该时间后，可以将被删除&lt;/li&gt;
&lt;li&gt;在超时之前，如果该key被修改，与之关联的超时将被移除

&lt;ul&gt;
&lt;li&gt;persist key 持久化该key，超时时间移除&lt;/li&gt;
&lt;li&gt;set key newvalue 设置新值，会清除过期时间&lt;/li&gt;
&lt;li&gt;del key   显然会清除过期时间&lt;/li&gt;
&lt;li&gt;例外情况：

&lt;ul&gt;
&lt;li&gt;lpush, zset, incr等操作，在高版本（2.1.3++）之后不会清除过期时间，毕竟修改的不是key本身&lt;/li&gt;
&lt;li&gt;rename 也不会清除过期时间，只是改key名字&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;过期处理&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;redis对过期key采用lazy expiration方式，在访问key的时候才判定该key是否过期&lt;/li&gt;
&lt;li&gt;此外，每秒还会抽取volatile keys进行抽样，处理删除过期键&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.marser.cn/archives/87/&#34;&gt;过期键删除策略种类&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;事件删除

&lt;ul&gt;
&lt;li&gt;每个键都有一个定时器，到期时触发处理事件，在事件中删除&lt;/li&gt;
&lt;li&gt;缺点是需要为每个key维护定时器，key的量大时，cpu消耗较大&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;惰性删除

&lt;ul&gt;
&lt;li&gt;每次访问时才检查，如果没过期，正常返回，否则删除该键并返回空&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;定期删除&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;每隔一段时间，检查所有设置了过期时间的key，删除已过期的键
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;redis采用后两种结合的方式&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;读写一个key时，触发惰性删除策略&lt;/li&gt;
&lt;li&gt;惰性删除策略不能及时处理冷数据，因此redis会定期主动淘汰一批已过期的key&lt;/li&gt;
&lt;li&gt;内存超过maxmemory时，触发主动清理&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://blueswind8306.iteye.com/blog/2240088&#34;&gt;http://blueswind8306.iteye.com/blog/2240088&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.cnblogs.com/chenpingzhao/p/5022467.html&#34;&gt;http://www.cnblogs.com/chenpingzhao/p/5022467.html&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>effective tips in daily work</title>
      <link>https://bg2bkk.github.io/post/effective%20tips%20in%20daily%20work/</link>
      <pubDate>Sun, 24 Jul 2016 16:36:33 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/effective%20tips%20in%20daily%20work/</guid>
      <description>

&lt;h2 id=&#34;sar在ubuntu中的配置&#34;&gt;sar在ubuntu中的配置&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt-get install sysstat

sudo vim /etc/default/sysstat
&amp;quot; change ENABLED=&amp;quot;false&amp;quot; to &amp;quot;true&amp;quot;

sudo vim /etc/cron.d/sysstat
&amp;quot; change 
&amp;quot; 5-55/10 * * * * root command -v debian-sa1 &amp;gt; /dev/null &amp;amp;&amp;amp; debian-sa1 1 1
&amp;quot; to 
&amp;quot; */2 * * * * root command -v debian-sa1 &amp;gt; /dev/null &amp;amp;&amp;amp; debian-sa1 1 1
&amp;quot; change the collection interval from every 10 minutes to every 2 minutes.

sudo /etc/init.d/sysstat restart
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;全世界最愚蠢的事情就是-重复做相同的事情-却期待有不同的结果发生&#34;&gt;全世界最愚蠢的事情就是，重复做相同的事情，却期待有不同的结果发生&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;Insanity: doing the same thing over and over again and expecting different results.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说实话，在写代码、调代码的时候，一但出现非预期结果，首先检查之前自己的编码和输入，确定后不应该再二次重试，毕竟相同条件下不可能产生不同结果，此时应该将思维跳脱出来，另辟蹊径为好。&lt;/p&gt;

&lt;h2 id=&#34;ubuntu下解压zip文件出现乱码的解决办法&#34;&gt;ubuntu下解压zip文件出现乱码的解决办法&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.zhihu.com/question/20523036&#34;&gt;参考链接&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;由于zip格式中并没有指定编码格式，Windows下生成的zip文件中的编码是GBK/GB2312等，因此，导致这些zip文件在Linux下解压时出现乱码问题，因为Linux下的默认编码是UTF8。&lt;/p&gt;

&lt;p&gt;目前网上流传一种unzip -O cp936的方法，但一些unzip是没有-O这个选项的。&lt;/p&gt;

&lt;p&gt;亲测好用，不好用的看链接&lt;/p&gt;

&lt;h2 id=&#34;redis设置和清除密码&#34;&gt;redis设置和清除密码&lt;/h2&gt;

&lt;p&gt;正规项目终于要对redis设置密码了，&lt;a href=&#34;http://blog.csdn.net/zyz511919766/article/details/42268219&#34;&gt;如何加密码呢&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;配置文件中添加密码&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;配置文件中的requirepass配置指令用于配置密码&lt;/li&gt;
&lt;li&gt;配置文件中的masterauth用于配置从机登陆主机的密码&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;运行中添加密码&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;config set requirepass PASSWORD&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;运行中删除密码&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;config set requirepass &amp;ldquo;&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;获取密码&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;config get requirepass&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;配置从机&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;config set masterauth MASTER_PASSWORD&lt;/li&gt;
&lt;li&gt;config set requirepass SLAVE_AUTH&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;epoll是同步非阻塞的&#34;&gt;epoll是同步非阻塞的&lt;/h2&gt;

&lt;p&gt;epoll、select等多路服用IO，将fd加入等待时间的队列中，每隔一段时间去轮询一次，因此是同步的；优点是能够在等待任务的时间里去做别的任务；缺点是任务完成的响应延迟增大，因为每隔一段时间去轮询他们，在时间间隔内任务可能已经完成而等待处理等待了一段时间了。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://ring0.me/2014/11/sync-async-blocked/&#34;&gt;参考链接&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;同步/异步指的是被调用方的通知方式，被调用方完成后，主动通知调用方，还是等待调用方发现。前者是异步，后者是同步。从这里也可以看出，&lt;a href=&#34;https://segmentfault.com/a/1190000003063859&#34;&gt;异步IO通知调用方时，数据已经就绪&lt;/a&gt;，对于网络IO来说，异步IO已经将数据从内核复制到用户空间了。&lt;/p&gt;

&lt;p&gt;阻塞/非阻塞是调用方的等待方式，是一直等待在做的事件完成，还是去做别的事情，等到在做的事件完成后再接着进行处理。前者是阻塞，后者是非阻塞&lt;/p&gt;

&lt;p&gt;因此epoll是同步和非阻塞的。&lt;/p&gt;

&lt;h2 id=&#34;sed合并相邻两行&#34;&gt;sed合并相邻两行&lt;/h2&gt;

&lt;p&gt;从redis中取出一个键的所有内容时，比如hgetall，得到的结果并不是排序好的，类似于这样&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;11485) &amp;quot;1470347460&amp;quot;
11486) &amp;quot;69&amp;quot;
11487) &amp;quot;1470262350&amp;quot;
11488) &amp;quot;34&amp;quot;
11489) &amp;quot;1470262170&amp;quot;
11490) &amp;quot;68&amp;quot;
11491) &amp;quot;1470242400&amp;quot;
11492) &amp;quot;21&amp;quot;
11493) &amp;quot;1470288030&amp;quot;
11494) &amp;quot;65&amp;quot;
11495) &amp;quot;1470303390&amp;quot;
11496) &amp;quot;54&amp;quot;
11497) &amp;quot;1470205320&amp;quot;
11498) &amp;quot;85&amp;quot;
11499) &amp;quot;1470318330&amp;quot;
11500) &amp;quot;92&amp;quot;
11501) &amp;quot;1470167040&amp;quot;
11502) &amp;quot;1&amp;quot;
11503) &amp;quot;1470281880&amp;quot;
11504) &amp;quot;14&amp;quot;
11505) &amp;quot;1470298140&amp;quot;
11506) &amp;quot;113&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该hash的key为unix时间戳，val为数值，如果想手动看分布的话，需要将相邻两行合并然后排序，在此我们&lt;a href=&#34;http://blog.chinaunix.net/uid-9950859-id-98222.html&#34;&gt;借助sed&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sed &#39;$!N;s/\n/\t/&#39; filename 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;redis分析实例中所有key和单个key的内存占用情况&#34;&gt;redis分析实例中所有key和单个key的内存占用情况&lt;/h2&gt;

&lt;p&gt;采用&lt;a href=&#34;https://github.com/sripathikrishnan/redis-rdb-tools&#34;&gt;rdb工具&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;rdb -c memory /path/to/ab-dump.rdb &amp;gt; memory.csv
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;sort进行多重排序&#34;&gt;sort进行多重排序&lt;/h2&gt;

&lt;p&gt;sort和uniq在文本处理，尤其是日志处理中用的较多的工具，记得当年校招时候准备面试，用到这两个命令，惊为天人，非常shock。在日常工作中，用的也非常多。&lt;/p&gt;

&lt;p&gt;目前有这样的需求，拿到两列数据，第一列是ip，第二列是访问计数，想看一下分布，要求ip要按文本排序，访问计数按数值排序。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;221.179.175.109	97
221.179.175.164	101
221.179.175.46	8
221.179.175.164	102
221.179.175.178	78
221.179.175.46	9
221.179.175.109	98
221.179.175.178	79
120.239.141.197	96
221.179.175.70	114
218.202.7.121	70
221.179.175.178	80
218.202.7.121	71
221.179.175.134	83
120.239.141.197	97
221.179.175.46	10
221.179.175.178	81
221.179.175.47	24
120.239.141.197	98
221.179.175.70	115
221.179.175.70	116
120.239.141.197	99
221.179.175.134	84

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.chinaunix.net/uid-25504049-id-3075909.html&#34;&gt;解决方法&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sort -t &#39; &#39; -k1,1 -k2n,2 data


其中 -t &#39; &#39; 指定使用空格分列
-k1,1  指定以第一列为关键字排序
-k2n,2 指定以第二列为关键字做数据排序
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/dabingxiaozu/article/details/6213851&#34;&gt;也可以&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sort -k1 -k2n out
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;shell脚本批量处理文本&#34;&gt;shell脚本批量处理文本&lt;/h2&gt;

&lt;p&gt;善用awk、grep、xargs、bash、sed等工具，可以提高生产力&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;grep &#39;config.config&#39; . -r | awk -F&#39;:&#39; &#39;{print $1}&#39; | grep &#39;lua$&#39; | xargs sed &amp;quot;s/config.config&#39;)/config.config&#39;).ab/g&amp;quot; -i
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;shell循环&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;for j in {a..z}; do echo $j; done
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;redis批量删除key&#34;&gt;redis批量删除key&lt;/h2&gt;

&lt;p&gt;手动清理redis中的key时，很想通过 &lt;strong&gt;&lt;em&gt;del keys&lt;/em&gt;&lt;/strong&gt;* 的方式实现批量删除，而redis却没有提供这样的选项，因此需要借助外部工具&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1、sehll 命令行&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;redis-cli keys ip:* | xargs redis-cli del&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;2、lua脚本&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;redis-cli eval &amp;ldquo;redis.call(&amp;lsquo;del&amp;rsquo;, unpack(redis.call(&amp;lsquo;keys&amp;rsquo;,&amp;lsquo;ip*&amp;lsquo;)))&amp;rdquo; 0&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;这种方式受限于lua的unpack函数，一次删除的key不能太多&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;3、借助客户端&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.redisfans.com/?p=71&#34;&gt;php&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/tuposky/article/details/45364107&#34;&gt;jedis&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;unix获取时间戳&#34;&gt;unix获取时间戳&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;date &#39;+%s&#39;

export timestamp=`date &#39;+%s&#39;`; echo $timestamp

# 标准时间格式转unix时间戳
date -d &amp;quot;2011-03-02 15:00&amp;quot; +%s

# unix时间戳转为标准格式
date -d &#39;1970-01-01 UTC 1299049200 seconds&#39;

# 或者

date -d &amp;quot;@1279592730&amp;quot; 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/hittata/article/details/7640974&#34;&gt;链接&lt;/a&gt;中提到了各种各样的格式，以后写shell脚本就不担心时间戳问题了&lt;/p&gt;

&lt;h2 id=&#34;docker-设置代理下载镜像&#34;&gt;docker 设置代理下载镜像&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://stackoverflow.com/questions/23111631/cannot-download-docker-images-behind-a-proxy&#34;&gt;在systemd中设置&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;mkdir /etc/systemd/system/docker.service.d&lt;p&gt;&lt;/li&gt;
&lt;li&gt;touch /etc/systemd/system/docker.service.d/http-proxy.conf&lt;p&gt;&lt;/li&gt;
&lt;li&gt;在文件中添加：&lt;p&gt;[Service]&lt;p&gt;Environment=&amp;ldquo;HTTP_PROXY=&lt;a href=&#34;http://proxy.example.com:80/&amp;quot;&#34;&gt;http://proxy.example.com:80/&amp;quot;&lt;/a&gt;&lt;p&gt;&lt;/li&gt;
&lt;li&gt;重启daemon：&lt;p&gt;sudo systemctl daemon-reload&lt;p&gt;&lt;/li&gt;
&lt;li&gt;查看设置状态：&lt;p&gt;sudo systemctl show docker &amp;ndash;property Environment&lt;p&gt;&lt;/li&gt;
&lt;li&gt;重启docker：&lt;p&gt;sudo systemctl restart docker&lt;p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;tested on Ubuntu 16.04&lt;/p&gt;

&lt;h2 id=&#34;用ps查看进程的执行时间&#34;&gt;用ps查看进程的执行时间&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ps -eo pid,tty,user,comm,stime,etime | grep main
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以打印进程的开始时间和执行时间&lt;/p&gt;

&lt;h2 id=&#34;vim下以16进制查看文本文件&#34;&gt;vim下以16进制查看文本文件&lt;/h2&gt;

&lt;p&gt;vim的功能实在是太强大了，&lt;a href=&#34;http://blog.sina.com.cn/s/blog_4c451e0e0100h4nl.html&#34;&gt;可以以16进制查看文本信息&lt;/a&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;十六进制显示
:%!xxd
正常显示
:%!xxd -r
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;linux获取系统调度时间片长度&#34;&gt;Linux获取系统调度时间片长度&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#define _GNU_SOURCE
#include &amp;lt;sched.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;assert.h&amp;gt;

	int
main(int argc, char *argv[])
{
	int ret, i;  
	struct timespec tp;  
	ret = sched_rr_get_interval(0, &amp;amp;tp);  
	if(ret == -1)  
		printf(&amp;quot;sched_rr_get_interval error.\n&amp;quot;);  
	printf(&amp;quot;The time is %ds:%ldns.\n&amp;quot;, (int)tp.tv_sec, tp.tv_nsec);  
	return 0;  
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./cpu_time_slice.o 
The time is 0s:16000000ns.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见Ubuntu-16.04 64bit的系统进程时间片是16ms&lt;/p&gt;

&lt;h2 id=&#34;c语言中short-int-long内存占用&#34;&gt;C语言中short、int、long内存占用&lt;/h2&gt;

&lt;p&gt;随着工作年限的增加，很多基本功反而落了下来，甚至开始怀疑short等类型的内存占用问题了呵呵。印象里一直记得int和long类型都是4字节大小啊&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

struct test{
	char *ch1;
	int i;
	long ch2;
} aa;

int main()
{
	printf(&amp;quot;Linux-64Bit-platform\n&amp;quot;);
	printf(&amp;quot;	%lu\n&amp;quot;, (unsigned long)sizeof(aa));
	printf(&amp;quot;	sizeof short : %d\n&amp;quot;, sizeof(short));
	printf(&amp;quot;	sizeof int   : %d\n&amp;quot;, sizeof(int));
	printf(&amp;quot;	sizeof long  : %d\n&amp;quot;, sizeof(long));
	
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
Linux-64Bit-platform
	24
	sizeof short : 2
	sizeof int   : 4
	sizeof long  : 8

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
Linux-32Bit-platform
	24
	sizeof short : 2
	sizeof int   : 4
	sizeof long  : 4

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看来，long和int大小一样已经是32位机器的老黄历了，基础知识还是应该常用常新啊&lt;/p&gt;

&lt;h2 id=&#34;文件操作的线程安全相关-待续&#34;&gt;文件操作的线程安全相关（待续）&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://stackoverflow.com/questions/29981050/concurrent-writing-to-a-file&#34;&gt;http://stackoverflow.com/questions/29981050/concurrent-writing-to-a-file&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;ubuntu关闭键盘和触摸板的方法&#34;&gt;ubuntu关闭键盘和触摸板的方法&lt;/h2&gt;

&lt;p&gt;家里的猫就是喜欢趴在笔记本键盘上看你干活，我只能再买一个键盘，然后笔记本键盘留给猫大爷了。&lt;/p&gt;

&lt;p&gt;然而它还喜欢在键盘上跳舞，这样太影响输入了，只能想办法把笔记本键盘关掉。&lt;/p&gt;

&lt;p&gt;在ubuntu下，键盘鼠标触控板都属于xinput设备，可以通过以下命令查看：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
$ xinput  --list
⎡ Virtual core pointer                    	id=2	[master pointer  (3)]
⎜   ↳ Virtual core XTEST pointer              	id=4	[slave  pointer  (2)]
⎜   ↳ SynPS/2 Synaptics TouchPad              	id=16	[slave  pointer  (2)]
⎜   ↳ Rapoo Rapoo Gaming Keyboard             	id=11	[slave  pointer  (2)]
⎜   ↳ RAPOO Rapoo 2.4G Wireless Device        	id=12	[slave  pointer  (2)]
⎜   ↳ Wacom ISDv4 E6 Pen stylus               	id=13	[slave  pointer  (2)]
⎜   ↳ Wacom ISDv4 E6 Finger touch             	id=14	[slave  pointer  (2)]
⎜   ↳ Wacom ISDv4 E6 Pen eraser               	id=18	[slave  pointer  (2)]
⎜   ↳ TPPS/2 IBM TrackPoint                   	id=19	[slave  pointer  (2)]
⎣ Virtual core keyboard                   	id=3	[master keyboard (2)]
    ↳ Virtual core XTEST keyboard             	id=5	[slave  keyboard (3)]
    ↳ Power Button                            	id=6	[slave  keyboard (3)]
    ↳ Video Bus                               	id=7	[slave  keyboard (3)]
    ↳ Sleep Button                            	id=8	[slave  keyboard (3)]
    ↳ Integrated Camera                       	id=9	[slave  keyboard (3)]
    ↳ Rapoo Rapoo Gaming Keyboard             	id=10	[slave  keyboard (3)]
    ↳ AT Translated Set 2 keyboard            	id=15	[slave  keyboard (3)]
    ↳ ThinkPad Extra Buttons                  	id=17	[slave  keyboard (3)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到笔记本键盘是&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;    ↳ AT Translated Set 2 keyboard            	id=15	[slave  keyboard (3)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而触控板是&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;⎜   ↳ SynPS/2 Synaptics TouchPad              	id=16	[slave  pointer  (2)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;他们的id分别是 15和 16，所以采用以下命令关掉就可以&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo sudo xinput set-prop 15 &amp;quot;Device Enabled&amp;quot; 0
sudo sudo xinput set-prop 16 &amp;quot;Device Enabled&amp;quot; 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;附送shell脚本&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash

keyboard=`xinput --list | grep AT | awk -F&#39;=&#39; &#39;{print $2}&#39; | awk &#39;{print $1}&#39;`
touchpad=`xinput --list | grep Synaptics | awk -F&#39;=&#39; &#39;{print $2}&#39; | awk &#39;{print $1}&#39;`

function doit() {
	echo &#39;关闭  笔记本键盘&#39;
	`sudo xinput set-prop $keyboard &amp;quot;Device Enabled&amp;quot; 0`			
	echo &#39;关闭  笔记本触摸板&#39;
	`sudo xinput set-prop $touchpad &amp;quot;Device Enabled&amp;quot; 0`
}

doit 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;小于1024的保留端口都有哪些&#34;&gt;小于1024的保留端口都有哪些&lt;/h2&gt;

&lt;p&gt;我们会遇到如下情况：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sudo tcpdump -i any port 1080
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on any, link-type LINUX_SLL (Linux cooked), capture size 262144 bytes
15:08:42.421693 IP localhost.55092 &amp;gt; localhost.socks: Flags [.], ack 1960200857, win 342, options [nop,nop,TS val 4687328 ecr 4676064], length 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我想监听1080端口，tcpdump为什么不乖乖显示1080，而是出现个socks呢？（可以通过&lt;strong&gt;&lt;em&gt;-n&lt;/em&gt;&lt;/strong&gt;参数解决）为什么1080是socks，而不是别的呢？&lt;/p&gt;

&lt;p&gt;这是因为低于1024的保留端口大多有自己的名字，他们&lt;a href=&#34;http://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml&#34;&gt;由IANA分配&lt;/a&gt;，通常用于系统进程，而我们可以在&lt;strong&gt;&lt;em&gt;/etc/services&lt;/em&gt;&lt;/strong&gt;文件中找到：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#
# From ``Assigned Numbers&#39;&#39;:
#
#&amp;gt; The Registered Ports are not controlled by the IANA and on most systems
#&amp;gt; can be used by ordinary user processes or programs executed by ordinary
#&amp;gt; users.
#
#&amp;gt; Ports are used in the TCP [45,106] to name the ends of logical
#&amp;gt; connections which carry long term conversations.  For the purpose of
#&amp;gt; providing services to unknown callers, a service contact port is
#&amp;gt; defined.  This list specifies the port used by the server process as its
#&amp;gt; contact port.  While the IANA can not control uses of these ports it
#&amp;gt; does register or list uses of these ports as a convienence to the
#&amp;gt; community.
#
socks		1080/tcp			# socks proxy server
socks		1080/udp
proofd		1093/tcp
proofd		1093/udp
rootd		1094/tcp
rootd		1094/udp
openvpn		1194/tcp
openvpn		1194/udp
rmiregistry	1099/tcp			# Java RMI Registry
rmiregistry	1099/udp
kazaa		1214/tcp
kazaa		1214/udp
nessus		1241/tcp			# Nessus vulnerability
nessus		1241/udp			#  assessment scanner
lotusnote	1352/tcp	lotusnotes	# Lotus Note
lotusnote	1352/udp	lotusnotes
ms-sql-s	1433/tcp			# Microsoft SQL Server
ms-sql-s	1433/udp
ms-sql-m	1434/tcp			# Microsoft SQL Monitor
ms-sql-m	1434/udp
ingreslock	1524/tcp
ingreslock	1524/udp
prospero-np	1525/tcp			# Prospero non-privileged

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;git修改默认分支名&#34;&gt;git修改默认分支名&lt;/h2&gt;

&lt;p&gt;在develop分支改动太大了，导致merge 到master分支时非常被动，这个时候我想，干脆将develop分支作为分支好了。还好碰到&lt;a href=&#34;http://stackoverflow.com/questions/1485578/change-a-git-remote-head-to-point-to-something-besides-master&#34;&gt;stackoverflow的一个帖子&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;git branch -m master oldmaster&lt;/li&gt;
&lt;li&gt;git branch -m develop master&lt;/li&gt;
&lt;li&gt;git push -f origin master&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;另一个方法是从github的&lt;a href=&#34;https://help.github.com/articles/setting-the-default-branch/&#34;&gt;项目主页上更改&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;编译openssl-1-0-2g&#34;&gt;编译openssl 1.0.2g&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./config shared -fPIC zlib-dynamic &amp;amp;&amp;amp; make depend -j   &amp;amp;&amp;amp; make -j
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;编译nginx-tengine-cpp模块&#34;&gt;编译nginx/tengine: CPP模块&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./configure --add-module=../cpp_module  --with-ld-opt=&amp;quot;-lstdc++&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;curl-i-和-i的区别&#34;&gt;curl -i 和 -I的区别&lt;/h2&gt;

&lt;p&gt;man page:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;	-i, --include
		(HTTP) Include the HTTP-header in the output. The HTTP-header includes things like server-name, date of the document, HTTP-version and more...
		
	-I, --head
		(HTTP/FTP/FILE) Fetch the HTTP-header only! HTTP-servers feature the command HEAD which this uses to get nothing but the header of a document. When used on an FTP or FILE file, curl displays the file size and last modification time only.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-i选项会打印出HTTP头部的一些信息，这个选项是curl软件的选项，这些信息本来就是存在的&lt;/p&gt;

&lt;p&gt;-I选项会发送HEAD请求，获取信息&lt;/p&gt;

&lt;h2 id=&#34;linux系统如何将父子进程一起kill掉&#34;&gt;linux系统如何将父子进程一起kill掉&lt;/h2&gt;

&lt;p&gt;对于普通进程而言，kill掉父进程将会连带着把子进程kill掉；而对于daemon等类型进程而言，kill掉父进程，子进程会被daemon接管，所以如果想父子一起kill掉的话，不能直接kill父进程。&lt;/p&gt;

&lt;p&gt;有&lt;a href=&#34;http://blog.csdn.net/lalaguozhe/article/details/11142855&#34;&gt;两种方法&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;kill &amp;ndash; -PPID&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;PPID前面有&lt;strong&gt;&lt;em&gt;-&lt;/em&gt;&lt;/strong&gt;号，可以将父子进程kill掉&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用exec或者xargs来kill掉他们&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;dns查询中-域名是否可以有多个cname呢&#34;&gt;dns查询中，域名是否可以有多个cname呢？&lt;/h2&gt;

&lt;p&gt;不可以
    * &lt;a href=&#34;http://serverfault.com/questions/574072/can-we-have-multiple-cnames-for-a-single-name&#34;&gt;http://serverfault.com/questions/574072/can-we-have-multiple-cnames-for-a-single-name&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;git代理访问&#34;&gt;git代理访问&lt;/h2&gt;

&lt;p&gt;git config &amp;ndash;global http.proxy 10.8.0.1:8118&lt;/p&gt;

&lt;h2 id=&#34;ubuntu操作-挂载-格式化sd卡&#34;&gt;ubuntu操作、挂载、格式化SD卡&lt;/h2&gt;

&lt;p&gt;玩树莓派等板子的时候，需要从host机器将os镜像烧进sd卡，然后启动。那么ubuntu如何操作呢？&lt;/p&gt;

&lt;p&gt;fdisk -l命令可以用来查看系统中的存储硬件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;

Disk /dev/sda: 111.8 GiB, 120034123776 bytes, 234441648 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: gpt
Disk identifier: C27256BB-CE04-48C2-96F4-8F79FAE2AE87

Device     Start       End   Sectors   Size Type
/dev/sda1   2048 234440703 234438656 111.8G Linux filesystem


Disk /dev/sdb: 167.7 GiB, 180045766656 bytes, 351651888 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x42b438a2

Device     Boot     Start       End   Sectors  Size Id Type
/dev/sdb1  *         2048 105887743 105885696 50.5G  7 HPFS/NTFS/exFAT
/dev/sdb2       105887744 187807665  81919922 39.1G 83 Linux
/dev/sdb3       187807744 228767743  40960000 19.5G  7 HPFS/NTFS/exFAT
/dev/sdb4       228769790 351649791 122880002 58.6G  f W95 Ext&#39;d (LBA)
/dev/sdb5       228769792 351649791 122880000 58.6G  7 HPFS/NTFS/exFAT


Disk /dev/sdc: 14.9 GiB, 16021192704 bytes, 31291392 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x00000000

Device     Boot Start      End  Sectors  Size Id Type
/dev/sdc1        8192 31291391 31283200 14.9G  c W95 FAT32 (LBA)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果sd卡（tf卡）通过usb 读卡器接入电脑，则会显示为 /dev/sdc&lt;/p&gt;

&lt;p&gt;如果是标准sd卡（大卡），则会显示为 /dev/mmblck0&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
Disk /dev/mmcblk0: 14.9 GiB, 16021192704 bytes, 31291392 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x00000000

Device         Boot Start      End  Sectors  Size Id Type
/dev/mmcblk0p1       8192 31291391 31283200 14.9G  c W95 FAT32 (LBA)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;推荐使用USB读卡器，速度较为快一些。&lt;/p&gt;

&lt;h2 id=&#34;lua库文件的加载路径&#34;&gt;Lua库文件的加载路径&lt;/h2&gt;

&lt;p&gt;Lua 提供一个名为 &lt;a href=&#34;http://www.lua.org/manual/5.1/manual.html#pdf-require&#34;&gt;require&lt;/a&gt; 的函数来加载模块，使用也很简单，它只有一个参数，这个参数就是要指定加载的模块名，&lt;a href=&#34;http://dhq.me/lua-learning-notes-package-and-module&#34;&gt;例如&lt;/a&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&amp;quot;&amp;lt;模块名&amp;gt;&amp;quot;)
-- 或者是
-- require &amp;quot;&amp;lt;模块名&amp;gt;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后会返回一个由模块常量或函数组成的 table，并且还会定义一个包含该 table 的全局变量。&lt;/p&gt;

&lt;p&gt;或者给加载的模块定义一个别名变量，方便调用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local m = require(&amp;quot;module&amp;quot;)
print(m.constant)
m.func3()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于自定义的模块，模块文件不是放在哪个文件目录都行，函数 require 有它自己的文件路径加载策略，它会尝试从 Lua 文件或 C 程序库中加载模块。&lt;/p&gt;

&lt;p&gt;require 用于搜索 Lua 文件的路径是存放在全局变量 package.path 中，当 Lua 启动后，会以环境变量 LUA_PATH 的值来初始这个环境变量。如果没有找到该环境变量，则使用一个编译时定义的默认路径来初始化。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
Lua 5.1.5  Copyright (C) 1994-2012 Lua.org, PUC-Rio
&amp;gt;  print(package.path)
~/lua/?.lua;/usr/local/share/lua/5.1/?.lua;/home/huang/workspace/luactor/?.lua;./?.lua;/usr/local/share/lua/5.1/?.lua;/usr/local/share/lua/5.1/?/init.lua;/usr/local/lib/lua/5.1/?.lua;/usr/local/lib/lua/5.1/?/init.lua;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果没有 LUA_PATH 这个环境变量，也可以自定义设置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;huang@ThinkPad-X220:~/workspace/luapkg/luasocket-2.0.2$ export LUA_PATH=&amp;quot;4;;&amp;quot;
huang@ThinkPad-X220:~/workspace/luapkg/luasocket-2.0.2$ lua
Lua 5.1.5  Copyright (C) 1994-2012 Lua.org, PUC-Rio
&amp;gt;  print(package.path)
4;./?.lua;/usr/local/share/lua/5.1/?.lua;/usr/local/share/lua/5.1/?/init.lua;/usr/local/lib/lua/5.1/?.lua;/usr/local/lib/lua/5.1/?/init.lua;
&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，随便加的环境变量&amp;rdquo;4;&amp;ldquo;写在了package.path中。&lt;/p&gt;

&lt;p&gt;而为什么4需要两个&amp;rsquo;；&amp;rsquo;号呢：文件路径以 &amp;ldquo;;&amp;rdquo; 号分隔，最后的 2 个 &amp;ldquo;;;&amp;rdquo; 表示新加的路径后面加上原来的默认路径。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;huang@ThinkPad-X220:~/workspace/luapkg/luasocket-2.0.2$ export LUA_PATH=&amp;quot;4;&amp;quot;
huang@ThinkPad-X220:~/workspace/luapkg/luasocket-2.0.2$ lua
Lua 5.1.5  Copyright (C) 1994-2012 Lua.org, PUC-Rio
&amp;gt; print(package.path)
4;
&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见如果只有一个；号，将只采用这个分号。&lt;/p&gt;

&lt;p&gt;如果找过目标文件，则会调用 package.loadfile 来加载模块。否则，就会去找 C 程序库。搜索的文件路径是从全局变量 package.cpath 获取，而这个变量则是通过环境变量 LUA_CPATH 来初始。搜索的策略跟上面的一样，只不过现在换成搜索的是 so 或 dll 类型的文件。如果找得到，那么 require 就会通过 package.loadlib 来加载它。&lt;/p&gt;

&lt;p&gt;我们也可以在lua代码中&lt;a href=&#34;https://github.com/rtsisyk/luafun&#34;&gt;动态修改package.path变量&lt;/a&gt;，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;package.path = &amp;quot;../?.lua;&amp;quot;..package.path
require &amp;quot;fun&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这点对于我们自己的lua project的设置来说无疑是很方便的。
&lt;a href=&#34;http://www.runoob.com/lua/lua-modules-packages.html&#34;&gt;参考链接&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;cpp调用c函数&#34;&gt;cpp调用c函数&lt;/h2&gt;

&lt;p&gt;由于CPP在链接时与C不太一样，因此在调用C函数时，&lt;a href=&#34;http://www.cnblogs.com/skynet/archive/2010/07/10/1774964.html&#34;&gt;需要做一定处理。&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;将C函数的声明房子 &lt;strong&gt;&lt;em&gt;#ifdef __cplusplus&lt;/em&gt;&lt;/strong&gt; 块中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#ifdef __cplusplus
extern &amp;quot;C&amp;quot; {
#endif
 
/*.
 * c functions declarations
..*/

#ifdef __cplusplus
}
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;多少人在猜你机器的密码呢&#34;&gt;多少人在猜你机器的密码呢&lt;/h2&gt;

&lt;p&gt;VPS在公网就是个待宰的肥肉，都想去登陆，那&lt;a href=&#34;https://plus.google.com/+AlbertSu2015/posts/Uu1vbeJY1Hw&#34;&gt;都谁猜我的IP了呢？&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo grep &amp;quot;Failed password for root&amp;quot; /var/log/auth.log | awk &#39;{print $11}&#39; | sort | uniq -c | sort -nr | more
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;grep的简单使用-与-或-非&#34;&gt;grep的简单使用，与 或 非&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;或操作&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;grep -E &#39;123|abc&#39; filename  // 找出文件（filename）中包含123或者包含abc的行
egrep &#39;123|abc&#39; filename    // 用egrep同样可以实现
awk &#39;/123|abc/&#39; filename   // awk 的实现方式
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;与操作&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;grep pattern1 files | grep pattern2 ：显示既匹配 pattern1 又匹配 pattern2 的行。
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;其他操作&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
grep -i pattern files ：不区分大小写地搜索。默认情况区分大小写，
grep -l pattern files ：只列出匹配的文件名，
grep -L pattern files ：列出不匹配的文件名，
grep -w pattern files ：只匹配整个单词，而不是字符串的一部分（如匹配‘magic’，而不是‘magical’），
grep -v pattern files ：不匹配pattern
grep -C number pattern files ：匹配的上下文分别显示[number]行，
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;iptables的简单使用&#34;&gt;iptables的简单使用&lt;/h2&gt;

&lt;p&gt;其实并不想写iptables相关的内容，因为用的不熟，但是一些常用的命令还是记一下吧&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://linux.cn/article-1586-1.html&#34;&gt;iptables的详细解释&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Linux系统中,防火墙(Firewall),网址转换(NAT),数据包(package)记录,流量统计,这些功能是由Netfilter子系统所提供的，而iptables是控制Netfilter的工具。iptables将许多复杂的规则组织成成容易控制的方式，以便管理员可以进行分组测试，或关闭、启动某组规则。
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;https://blog.phpgao.com/vps_iptables.html
http://www.tabyouto.com/bandwagon-vps-for-shadowsocks-was-hacked.html
http://my.oschina.net/yqc/blog/82111?fromerr=VxVIazGW
http://www.vpser.net/security/linux-iptables.html
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 列出所有规则
iptables -L -n

# 更新iptables规则，规则写在/etc/iptables.rules
iptables-restore &amp;lt; /etc/iptables.rules

# 保存iptables规则，规则写在/etc/iptables.rules
iptables-save &amp;gt; /etc/iptables.rules

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的是Debian/Ubuntu上iptables是不会保存规则的。&lt;/p&gt;

&lt;p&gt;需要按如下步骤进行，让网卡关闭是保存iptables规则，启动时加载iptables规则：&lt;/p&gt;

&lt;p&gt;创建/etc/network/if-post-down.d/iptables 文件，添加如下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash
iptables-save &amp;gt; /etc/iptables.rules
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行：chmod +x /etc/network/if-post-down.d/iptables 添加执行权限。&lt;/p&gt;

&lt;p&gt;创建/etc/network/if-pre-up.d/iptables 文件，添加如下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash
iptables-restore &amp;lt; /etc/iptables.rules
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行：chmod +x /etc/network/if-pre-up.d/iptables 添加执行权限。&lt;/p&gt;

&lt;p&gt;iptables的一些常用规则：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#允许ping
iptables -A INPUT -p icmp -m icmp --icmp-type 8 -j ACCEPT
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果想清空的话，先执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/sbin/iptables -P INPUT ACCEPT
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/sbin/iptables -F
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;vps简单的ssh登陆设置&#34;&gt;VPS简单的ssh登陆设置&lt;/h2&gt;

&lt;p&gt;初次使用VPS，不懂得安全的重要性，直到扣款时候才心疼，这个时候，弱口令，密码登陆什么的，还是都放弃吧，只用ssh登陆，并且换一个自己的端口。&lt;a href=&#34;https://imququ.com/post/bandwagon-vps-and-basicly-usage.html&#34;&gt;参考链接&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;简单来说，任何一台主机想登陆VPS的主机都需要有本身的ssh公钥私钥&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd ~/.ssh/
ssh-keygen -t rsa -C &amp;quot;username@gmail.com&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后复制~/.ssh/id_rsa.pub中的内容，就是本机的公钥。&lt;/p&gt;

&lt;p&gt;将公钥添加到VPS服务器的/home/username/.ssh/authorized_keys中，本机就能以username用户名登陆VPS了&lt;/p&gt;

&lt;p&gt;然后在/etc/ssh/sshd_config中禁用禁用 VPS 的密码登录和 root 帐号登录，将以下两项改为no&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;PasswordAuthentication no
PermitRootLogin no

Port 11111

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;随后重启SSH服务&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo service ssh restart
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;vim删除空行&#34;&gt;vim删除空行&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;从网页上copy下代码后，发现很多情况下有不想要的空行，非常影响阅读，通过&lt;a href=&#34;http://bbs.chinaunix.net/thread-510754-1-1.html&#34;&gt;vim的正则&lt;/a&gt;可以解决

&lt;ul&gt;
&lt;li&gt;Delete all blank lines (^ is start of line; \s* is zero or more whitespace characters; $ is end of line)&lt;/li&gt;
&lt;li&gt;删除所有空白行(^是行的开始，\s*是零个或者多个空白字符；$是行尾)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;:g/^\s*$/d
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ubuntu通过命令设置系统时间&#34;&gt;ubuntu通过命令设置系统时间&lt;/h2&gt;

&lt;p&gt;在嵌入式开发中，在pcduino或者rpi板子上安装好linux后，系统时间是UTC时间1970年，对于有些软件来说可能影响安装，所以需要命令行修改date&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo date -s &amp;quot;13 DEC 2015 20:43&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ubuntu终端下中文设置&#34;&gt;ubuntu终端下中文设置&lt;/h2&gt;

&lt;p&gt;在安装完ubuntu系统后，我们发现中文支持的不好，主要体现在locale的错误，&lt;a href=&#34;http://www.linuxidc.com/Linux/2015-08/122501.htm&#34;&gt;解决方法：&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;perl: warning: Setting locale failed.
perl: warning: Please check that your locale settings:
	LANGUAGE = (unset),
	LC_ALL = (unset),
	LC_PAPER = &amp;quot;zh_CN.UTF-8&amp;quot;,
	LC_ADDRESS = &amp;quot;zh_CN.UTF-8&amp;quot;,
	LC_MONETARY = &amp;quot;zh_CN.UTF-8&amp;quot;,
	LC_NUMERIC = &amp;quot;zh_CN.UTF-8&amp;quot;,
	LC_TELEPHONE = &amp;quot;zh_CN.UTF-8&amp;quot;,
	LC_IDENTIFICATION = &amp;quot;zh_CN.UTF-8&amp;quot;,
	LC_MEASUREMENT = &amp;quot;zh_CN.UTF-8&amp;quot;,
	LC_TIME = &amp;quot;zh_CN.UTF-8&amp;quot;,
	LC_NAME = &amp;quot;zh_CN.UTF-8&amp;quot;,
	LANG = &amp;quot;en_US.UTF-8&amp;quot;
    are supported and installed on your system.
perl: warning: Falling back to the standard locale (&amp;quot;C&amp;quot;).

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是因为中文包没有安装好的缘故，如下命令就可以解决：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;添加简体中文支持
sudo apt-get -y install language-pack-zh-hans language-pack-zh-hans-base

添加繁体中文支持
sudo apt-get -y install language-pack-zh-hant language-pack-zh-hant-base

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果还不行，先观察下locale的配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;huang@localhost:~$ locale
locale: Cannot set LC_CTYPE to default locale: No such file or directory
locale: Cannot set LC_MESSAGES to default locale: No such file or directory
locale: Cannot set LC_ALL to default locale: No such file or directory
LANG=en_US.UTF-8
LANGUAGE=
LC_CTYPE=&amp;quot;en_US.UTF-8&amp;quot;
LC_NUMERIC=zh_CN.UTF-8
LC_TIME=zh_CN.UTF-8
LC_COLLATE=&amp;quot;en_US.UTF-8&amp;quot;
LC_MONETARY=zh_CN.UTF-8
LC_MESSAGES=&amp;quot;en_US.UTF-8&amp;quot;
LC_PAPER=zh_CN.UTF-8
LC_NAME=zh_CN.UTF-8
LC_ADDRESS=zh_CN.UTF-8
LC_TELEPHONE=zh_CN.UTF-8
LC_MEASUREMENT=zh_CN.UTF-8
LC_IDENTIFICATION=zh_CN.UTF-8
LC_ALL=
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再重新配置下语言包&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;huang@localhost:~$  sudo locale-gen &amp;quot;en_US.UTF-8&amp;quot;
Generating locales...
  en_US.UTF-8... done
Generation complete.
huang@localhost:~$ sudo  pip install shadowsocks^C
huang@localhost:~$  sudo locale-gen &amp;quot;zh_CN.UTF-8&amp;quot;
Generating locales...
  zh_CN.UTF-8... done
Generation complete.
huang@localhost:~$ sudo dpkg-reconfigure locales
Generating locales...
  en_US.UTF-8... done
  zh_CN.UTF-8... up-to-date
  zh_HK.UTF-8... done
  zh_SG.UTF-8... done
  zh_TW.UTF-8... done
Generation complete.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般就都能解决&lt;/p&gt;

&lt;h2 id=&#34;linux终端下的颜色设置输出&#34;&gt;Linux终端下的颜色设置输出&lt;/h2&gt;

&lt;p&gt;Linux终端下，如果有一个彩色的终端，可以明显提升人的阅读兴趣，通过printf的简单设置即可&lt;a href=&#34;http://www.w2bc.com/Article/39141&#34;&gt;实现彩色输出&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;\033[显示方式;前景色;背景色m

    显示方式、前景色、背景色至少一个存在即可。
    格式：\033[显示方式;前景色;背景色m
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;前景色  背景色  颜色
30  40  黑色
31  41  红色
32  42  绿色
33  43  黃色
34  44  蓝色
35  45  紫红色
36  46  青蓝色
37  47  白色


显示方式    意义
0   终端默认设置
1   高亮显示
4   使用下划线
5   闪烁
7   反白显示
8   不可见

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;\033[1;31;40m    &amp;lt;!--1-高亮显示 31-前景色红色  40-背景色黑色--&amp;gt;
\033[0m          &amp;lt;!--采用终端默认设置，即取消颜色设置--&amp;gt;

printf(&amp;quot;\033[1;31;40m&amp;quot;);
printf(&amp;quot;\033[0m&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;tsar监控系统负载和nginx运行情况&#34;&gt;tsar监控系统负载和nginx运行情况&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/alibaba/tsar&#34;&gt;tsar&lt;/a&gt;是阿里巴巴发布的一款能够实时监控系统状态的命令行工具，并且支持第三方模块扩展，其中比较注明的是nginx模块。使用tsar时，可以将系统负载和nginx运行情况同步同时打出，可以用来定位系统瓶颈，所以广受好评。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;tsar -li1&lt;/em&gt;&lt;/strong&gt; 是其最经典的用法，可以将一般我们感兴趣的监控项每秒更新一次并输出&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Time              ---cpu-- ---mem-- ---tcp-- -----traffic---- --sda---  ---load- 
Time                util     util   retran    bytin  bytout     util     load1   
25/03/16-19:03:30   0.08    10.22     0.00     1.4K    1.2K     0.00     0.33  
25/03/16-19:03:31   0.08    10.21     0.00   424.00  468.00     0.00     0.33   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果想使能nginx模块，需要对其进行配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;1. mkdir /etc/tsar/conf.d
2. touch /etc/tsar/conf.d/nginx.conf

3. 写入如下内容并保存
mod_nginx on

####add it to tsar default output
output_stdio_mod mod_nginx

####add it to center db
#output_db_mod mod_nginx

####add it to nagios send
####set nagios threshold for alert
#output_nagios_mod mod_nginx

#threshold nginx.value1;N;N;N;N;
#threshold nginx.value2;N;N;N;N;
#threshold nginx.value3;N;N;N;N;

表示使能nginx模块，并使用stdio输出

4. tsar -li1

Time              ---cpu-- ---mem-- ---tcp-- -----traffic---- --sda---  ---load- ------------------nginx----------------- 
Time                util     util   retran    bytin  bytout     util     load1      qps      rt  sslqps  spdyps  sslhst   
25/03/16-19:06:19   0.08    11.40     7.14   302.00  546.00     0.00     0.02     1.00    0.00    0.00    0.00    0.00   

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;wrk在centos系统上的编译方法&#34;&gt;wrk在CentOS系统上的编译方法&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/wg/wrk&#34;&gt;wrk&lt;/a&gt;作为一款可以内嵌lua脚本的，支持多线程的压测工具，受到了广泛欢迎。在高版本CentOS 7上，直接在wrk目录下执行make，可以首先编译deps/luajit，得到deps/luajit/libluajit.a，然而在低版本上，CentOS 6.5系统中，会报一些莫名奇妙的错误。&lt;/p&gt;

&lt;p&gt;解决方法是，查看wrk的Makefile，发现wrk依赖于luajit，那么首先进入deps/luajit编译它，并且是静态编译&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd wrk
cd deps/luajit
make -j24 BUILDMODE=static

cd ../..
make -j24

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;rpmbuild环境的快速初始化&#34;&gt;rpmbuild环境的快速初始化&lt;/h2&gt;

&lt;p&gt;需要将代码打包为CentOS的RPM包时，可以先自己在本地新建一个环境&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;1. mkdir -p ~/rpmbuild/{SOURCES,BUILD,BUILDROOT,RPMS,SRPMS,SPECS}
2. 将代打包的代码压缩包 software.tar.gz 放入SOURCES文件夹
3. 将 software.spec 放入SPECS文件夹
4. rpmbuild -ba path/to/software.spec 即可
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;git记住密码-不用每次都输密码才登入&#34;&gt;git记住密码，不用每次都输密码才登入&lt;/h2&gt;

&lt;p&gt;git有两种方式，一种是ssh方式，配置公钥私钥，对于新手而言还是比较麻烦的；另一种是http方式，这里有一个办法可以让git记住密码，避免每次都需要输入密码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;1. touch ~/.git-credentials
2. 将  https://{username}:{password}@github.com  写入该文件
3. git config --global credential.helper store  就可以使得git记住密码了
4. 此时查看 ~/.gitconfig，发现多了一项
    
    [credential] 
    helper = store 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;centos系统上某些软件-比如gcc-python等版本过低的解决方案&#34;&gt;centos系统上某些软件，比如gcc、python等版本过低的解决方案&lt;/h2&gt;

&lt;p&gt;在CentOS Server上，经常会遇到某些软件依赖版本过低的问题，比如CentOS 6.5的python是2.7版本的，gcc是4.2版本的，那么我们如何获得一个干净的、与原版本无冲突的运行环境呢。CentOS系提供了一个叫SCL的工具，可以帮我们实现目的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sudo wget http://people.centos.org/tru/devtools-1.1/devtools-1.1.repo -P /etc/yum.repos.d
$ sudo sh -c &#39;echo &amp;quot;enabled=1&amp;quot; &amp;gt;&amp;gt; /etc/yum.repos.d/devtools-1.1.repo&#39;
$ sudo yum install devtoolset-1.1
$ scl enable devtoolset-1.1 bash
$ gcc --version
# 通过devtoolset工具可以暂时提高gcc版本，而不更改之前服务器的配置，这个很有效果，高版本的gcc会智能保留symbol。
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# CentOS 6.5
sudo yum install centos-release-SCL
sudo yum install python27
scl enable python27 bash
python --version
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ubuntu系统上某些软件-比如gcc等版本过高的解决方案&#34;&gt;ubuntu系统上某些软件，比如gcc等版本过高的解决方案&lt;/h2&gt;

&lt;p&gt;与CentOS相反，debian系发行版的软件版本都很高，Ubuntu 16.04的gcc 版本已经到了5.2，然而编译一些早期linux内核的话，需要gcc-4.7左右的版本，这时候我们怎么办呢，有两个方法：
* 通过apt安装低版本gcc
    * sudo apt-get install gcc-4.7
    * 在编译linux 内核时， make CC=gcc-4.7 即可
* update-alternatives可以帮忙更改符号链接，指向不同版本的gcc
    * &lt;a href=&#34;http://www.metsky.com/archives/607.html&#34;&gt;参考链接1&lt;/a&gt;
    * &lt;a href=&#34;http://blog.csdn.net/zyxlinux888/article/details/6708775&#34;&gt;参考链接2&lt;/a&gt; &lt;a href=&#34;http://blog.csdn.net/zyxlinux888/article/details/6709036&#34;&gt;附赠&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;python的matplotlib库实现绘制图标&#34;&gt;python的matplotlib库实现绘制图标&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;sudo apt-get install python-matplotlib&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://matplotlib.org/index.html&#34;&gt;参考链接&lt;/a&gt;
&lt;a href=&#34;http://matplotlib.org/examples/index.html&#34;&gt;example&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;python使用requests库发送http请求&#34;&gt;python使用requests库发送http请求&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://cn.python-requests.org/zh_CN/latest/user/quickstart.html#json&#34;&gt;参考链接&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;python解析命令行参数-argparse&#34;&gt;python解析命令行参数：argparse&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.xiayf.cn/2013/03/30/argparse/&#34;&gt;参考链接&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;git比较两次commit的差异&#34;&gt;git比较两次commit的差异&lt;/h2&gt;

&lt;p&gt;通过比较两次commit的代码差异，能够快速理解此次commit的目的，理解作者意图&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;git log

&lt;ul&gt;
&lt;li&gt;查看commit历史&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;commit 2279c3f4a8a42e696a0f34e6e9b6289487da92c1
Author: bg2bkk &amp;lt;bg2bkk@gmail.com&amp;gt;
Date:   Sun Mar 13 09:12:26 2016 +0800

    add SO_REUSEADDR和SO_REUSEPORT.md

commit 2b9d85f8427c5ca9e4f9c128c22acd280eb94405
Author: bg2bkk &amp;lt;bg2bkk@gmail.com&amp;gt;
Date:   Sat Mar 12 01:16:00 2016 +0800

    add 采用二级指针实现单链表操作 单链表翻转 删除单链表结点
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;git diff commit 2279c3f4a8a42e696a0f34e6e9b6289487da92c1 2b9d85f8427c5ca9e4f9c128c22acd280eb94405&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;git返回强制返回某次提交&#34;&gt;git返回强制返回某次提交&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;git log&lt;/li&gt;
&lt;li&gt;git reset 5f4769a98985b5acfea45462df27830e51a75145 &amp;ndash;hard

&lt;ul&gt;
&lt;li&gt;可见commit号很重要&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;iptables允许端口被外网访问&#34;&gt;iptables允许端口被外网访问&lt;/h2&gt;

&lt;p&gt;防火墙设置，配置1985端口可以被外网访问&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;sudo iptables -A INPUT -m state &amp;ndash;state NEW -m tcp -p tcp &amp;ndash;dport 1985 -j ACCEPT&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;tcpdump过滤指定标志的packet&#34;&gt;tcpdump过滤指定标志的packet&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# tcp包里有个flags字段表示包的类型，tcpdump可以根据该字段抓取相应类型的包：
# tcp[13] 就是 TCP flags (URG,ACK,PSH,RST,SYN,FIN)
# Unskilled 32
# Attackers 16
# Pester     8
# Real       4
# Security   2
# Folks      1

#抓取fin包：
tcpdump -ni any port 9001 and &#39;tcp[13] &amp;amp; 1 != 0 &#39; -s0  -w fin.cap -vvv
#抓取syn+fin包：
tcpdump -ni any port 9001 and &#39;tcp[13] &amp;amp; 3 != 0 &#39; -s0  -w syn_fin.cap -vvv
#抓取rst包：
tcpdump -ni any port 9001 and &#39;tcp[13] &amp;amp; 4 != 0 &#39; -s0  -w rst.cap -vvv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://babyhe.blog.51cto.com/1104064/1395489&#34;&gt;参考链接&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;查看进程的内存占用情况&#34;&gt;查看进程的内存占用情况&lt;/h2&gt;

&lt;p&gt;用Ternary Search Tree代替Trie Tree后，我想知道我的进程内存占用有多大区别。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ps -e -o &amp;lsquo;pid,comm,args,pcpu,rsz,vsz,stime,user,uid&amp;rsquo; | grep MyDict&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;rsz是实际占用内存，单位是KB&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;pmap -d pid&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>stm32_eclipse_openocd_stlink</title>
      <link>https://bg2bkk.github.io/post/stm32_eclipse_openocd_stlink/</link>
      <pubDate>Wed, 06 Jul 2016 12:51:05 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/stm32_eclipse_openocd_stlink/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;eclipse下载&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;neon &lt;a href=&#34;http://ftp.jaist.ac.jp/pub/eclipse/technology/epp/downloads/release/neon/R/eclipse-jee-neon-R-linux-gtk-x86_64.tar.gz&#34;&gt;http://ftp.jaist.ac.jp/pub/eclipse/technology/epp/downloads/release/neon/R/eclipse-jee-neon-R-linux-gtk-x86_64.tar.gz&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;system workbench:&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;stlink 驱动&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://erika.tuxfamily.org/wiki/index.php?title=Tutorial:_STM32_-_Integrated_Debugging_in_Eclipse_using_GNU_toolchain&amp;amp;oldid=5474&#34;&gt;http://erika.tuxfamily.org/wiki/index.php?title=Tutorial:_STM32_-_Integrated_Debugging_in_Eclipse_using_GNU_toolchain&amp;amp;oldid=5474&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.st.com/content/st_com/en/products/embedded-software/development-tool-software/stsw-link004.html#&#34;&gt;http://www.st.com/content/st_com/en/products/embedded-software/development-tool-software/stsw-link004.html#&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Linux: &lt;a href=&#34;https://github.com/texane/stlink&#34;&gt;https://github.com/texane/stlink&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;sudo apt-get install autoreconf&lt;/li&gt;
&lt;li&gt;sudo apt-get install libusb-1.0-0 libusb-1.0-0-dev&lt;/li&gt;
&lt;li&gt;make &amp;amp;&amp;amp; make -j &amp;amp;&amp;amp; make install&lt;/li&gt;
&lt;li&gt;sudo ./st-util

&lt;ul&gt;
&lt;li&gt;之前还需要做udev.rules，现在发现不需要&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;用法：&lt;a href=&#34;http://erika.tuxfamily.org/wiki/index.php?title=Tutorial:_STM32_-_Integrated_Debugging_in_Eclipse_using_GNU_toolchain&amp;amp;oldid=5474&#34;&gt;http://erika.tuxfamily.org/wiki/index.php?title=Tutorial:_STM32_-_Integrated_Debugging_in_Eclipse_using_GNU_toolchain&amp;amp;oldid=5474&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;arm gcc compiler&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;sudo apt-get install gcc-arm-none-eabi&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;插件和eclipse环境配置：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;eclipse cdt 插件

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://eclipse.org/cdt/downloads.php&#34;&gt;https://eclipse.org/cdt/downloads.php&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://gnuarmeclipse.sourceforge.net/updates&#34;&gt;http://gnuarmeclipse.sourceforge.net/updates&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;gnu arm eclipse plugins的几种安装方法 &lt;a href=&#34;http://gnuarmeclipse.github.io/plugins/install/&#34;&gt;http://gnuarmeclipse.github.io/plugins/install/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gnuarmeclipse.github.io/eclipse/workspace/preferences/&#34;&gt;http://gnuarmeclipse.github.io/eclipse/workspace/preferences/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gnuarmeclipse.github.io/plugins/packs-manager/&#34;&gt;http://gnuarmeclipse.github.io/plugins/packs-manager/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ac6 system workbench: &lt;a href=&#34;http://www.ac6-tools.com/Eclipse-updates/org.openstm32.system-workbench.site/&#34;&gt;http://www.ac6-tools.com/Eclipse-updates/org.openstm32.system-workbench.site/&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;有了它就可以ac6 debugger了，但是没办法，neon不支持&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.emcu.it/STM32/What_should_I_use_to_develop_on_STM32/stm32f0_linux_dvlpt.pdf&#34;&gt;http://www.emcu.it/STM32/What_should_I_use_to_develop_on_STM32/stm32f0_linux_dvlpt.pdf&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如何使用eclipse新建工程&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;可以安装以上两个插件后，从eclipse新建ac6工程，下载相应库即可，ac6保证这个好使；&lt;/li&gt;
&lt;li&gt;可以从cube新建工程sw4stm32类型的工程，然后引入SW4STM32工程&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如何调试工程&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;debugger: AC6     普通的&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用ac6调试, &lt;a href=&#34;http://www.xlgps.com/article/387805.html&#34;&gt;http://www.xlgps.com/article/387805.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;debugger: hardware debugger configuration&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://stm32discovery.nano-age.co.uk/open-source-development-with-the-stm32-discovery/getting-hardware-debuging-working-with-eclipse-and-code-sourcey&#34;&gt;http://stm32discovery.nano-age.co.uk/open-source-development-with-the-stm32-discovery/getting-hardware-debuging-working-with-eclipse-and-code-sourcey&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;neon还不支持ac6 debugger，所以只能用后者 &lt;a href=&#34;http://www.openstm32.org/forumthread3023&#34;&gt;http://www.openstm32.org/forumthread3023&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;create debugging configuration&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.openstm32.org/Creating+debug+configuration&#34;&gt;http://www.openstm32.org/Creating+debug+configuration&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;开始debug&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;st-flash 烧录工具 &lt;a href=&#34;https://www.youtube.com/watch?v=HKX12hJApZM&#34;&gt;https://www.youtube.com/watch?v=HKX12hJApZM&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;openocd &lt;a href=&#34;https://www.youtube.com/watch?v=ZeUQXjTg-8c&#34;&gt;https://www.youtube.com/watch?v=ZeUQXjTg-8c&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;./configure &amp;ndash;enable-verbose &amp;ndash;enable-verbose-jtag-io &amp;ndash;enable-parport &amp;ndash;enable-jlink &amp;ndash;enable-ulink &amp;ndash;enable-stlink &amp;ndash;enable-ti-icdi&lt;/li&gt;
&lt;li&gt;make -j &amp;amp;&amp;amp; sudo make install&lt;/li&gt;
&lt;li&gt;openocd -f tcl/board/stm32f4discovery.cfg&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;openocd是debug server，3333端口&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;eclipse需要debug configuration&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;eclipse的设置&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;代码自动提示：&lt;a href=&#34;http://blog.csdn.net/u012750578/article/details/16811227&#34;&gt;http://blog.csdn.net/u012750578/article/details/16811227&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;elua&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;openocd -f ../../openocd-0.9.0/tcl/board/stm32f429discovery.cfg   -c &amp;quot;init&amp;quot;    -c &amp;quot;reset halt&amp;quot;    -c &amp;quot;sleep 100&amp;quot;    -c &amp;quot;wait_halt 2&amp;quot;    -c &amp;quot;echo \&amp;quot;--- Writing elua_lua_stm32f4discovery.bin\&amp;quot;&amp;quot;    -c &amp;quot;flash write_image erase elua_lua_stm32f4discovery.bin 0x08000000&amp;quot;    -c &amp;quot;sleep 100&amp;quot;    -c &amp;quot;echo \&amp;quot;--- Verifying\&amp;quot;&amp;quot;    -c &amp;quot;verify_image elua_lua_stm32f4discovery.bin 0x08000000&amp;quot;    -c &amp;quot;sleep 100&amp;quot;    -c &amp;quot;echo \&amp;quot;--- Done\&amp;quot;&amp;quot;    -c &amp;quot;resume&amp;quot;    -c &amp;quot;shutdown&amp;quot;

st-flash --reset write elua_lua_stm32f4discovery.bin 0x8000000
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>insertionSortList_链表插入排序</title>
      <link>https://bg2bkk.github.io/post/insertionSortList_%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sun, 05 Jun 2016 22:27:39 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/insertionSortList_%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</guid>
      <description>&lt;p&gt;写go并发代码有点疲劳，那就A个题吧。我觉得LintCode上的题目都很不错，有难有易，循序渐进的，随手选一道题来做吧。&lt;/p&gt;

&lt;p&gt;选择了&lt;a href=&#34;http://www.lintcode.com/zh-cn/problem/insertion-sort-list/&#34;&gt;链表插入排序&lt;/a&gt;，写起来不那么容易，但是也有调试的快感，其实对于难题，我们需要做到的是心思缜密、抽丝剥茧一步步实现；对于中等题目，我们需要抓住本质，一击制敌；在编码过程中，心里有时刻有代码执行时间复杂度和空间占用的底，逐渐养成这个习惯；编码过程中同样重要的还有编码风格，如果能够简洁明了的表达程序逻辑，就追求简洁，如果变量较多，需要在变量命名的时候注意甄别，对于写出的代码，尽量追求逻辑清晰风格良好，这是一个程序员的基本素质。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;用插入排序对链表排序&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;思路：插入排序的特点是，待排序的节点前面所有节点都是已排序的，同时记录已排序部分的末尾，也就是待排序节点的prev节点，所以每次拿带排序节点依次从头比较，直到比较到自己头上；在比较过程中，如果没有合适的位置，最终比较到自己头上，说明待排序节点可以直接补在已排序节点的后面；如果有合适的位置，就直接break，然后待排序节点从链表取出，prev节点的next指向待排序节点的next，保存当前break处的节点，待排序节点占据该节点位置，并将待排序节点的next指向break处节点，完成插入。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/BG2BKK/daily-programming/blob/master/cpp/insertionSortList.cpp&#34;&gt;完整代码地址&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;codelist&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;/**
 * Definition of ListNode
 * class ListNode {
 * public:
 *     int val;
 *     ListNode *next;
 *     ListNode(int val) {
 *         this-&amp;gt;val = val;
 *         this-&amp;gt;next = NULL;
 *     }
 * }
 */
class Solution { 
	public:
		ListNode *insertionSortList(ListNode *head) {
			// write your code here
			if(!head || !head-&amp;gt;next)
				return head;
			ListNode *sortedHead = head;
			ListNode *prev = head;
			ListNode *node = prev-&amp;gt;next;
			while(node){
				ListNode **p = &amp;amp;sortedHead;
				while(*p!=node){
					if((*p)-&amp;gt;val &amp;gt; node-&amp;gt;val){
						break;
					}
					p = &amp;amp;((*p)-&amp;gt;next);
				}
				if(*p == node){
					prev = node;
					node = node-&amp;gt;next;
				} else {
					ListNode *next = *p;
					*p = node;
					prev-&amp;gt;next = node-&amp;gt;next;
					(*p)-&amp;gt;next = next;
					node = prev-&amp;gt;next;
				}
			}
			return sortedHead;
		}
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>一道多线程面试题</title>
      <link>https://bg2bkk.github.io/post/%E4%B8%80%E9%81%93%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Thu, 26 May 2016 01:39:59 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/%E4%B8%80%E9%81%93%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>

&lt;p&gt;最近突然看协程和并发编程比较多，遇到这样&lt;a href=&#34;http://blog.csdn.net/liuxuejiang158blog/article/details/21977009&#34;&gt;一道题&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;题目：子线程循环 10 次，接着主线程循环 100 次，接着又回到子线程循环 10 次，接着再回到主线程又循环 100 次，如此循环50次，试写出代码。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;参考文档里的代码采用C++11编写，而我，很不幸的，看不懂。&lt;/p&gt;

&lt;p&gt;我想我的cpp已经退化到看不见了吧，然后c++11我更加看不懂了，甚至连cpp较为官方的&lt;a href=&#34;http://en.cppreference.com/w/cpp/thread/condition_variable&#34;&gt;文档都开始采用c++11了&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;虽然我不会c++11，但是我会lua、c、golang、python、shell，我要报复性的把这个题做了。&lt;/p&gt;

&lt;h2 id=&#34;c-11&#34;&gt;C++11&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;thread&amp;gt;
#include&amp;lt;mutex&amp;gt;
#include&amp;lt;condition_variable&amp;gt;
using namespace std;
mutex m;
condition_variable cond;
int flag=10;
void fun(int num){
    for(int i=0;i&amp;lt;2;i++){
        unique_lock&amp;lt;mutex&amp;gt; lk(m);//A unique lock is an object that manages a mutex object with unique ownership in both states: locked and unlocked.
        while(flag!=num)
            cond.wait(lk);//在调用wait时会执行lk.unlock()
        for(int j=0;j&amp;lt;num;j++)
            cout&amp;lt;&amp;lt;j&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
        cout&amp;lt;&amp;lt;endl;
        flag=(num==10)?100:10;
        cond.notify_one();//被阻塞的线程唤醒后lk.lock()恢复在调用wait前的状态
    }
}
int main(){
    thread child(fun,10);
    fun(100);
    child.join();
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;lua&#34;&gt;Lua&lt;/h2&gt;

&lt;p&gt;lua的协程使得主从两个thread之间并没有竞争关系，所以很顺畅的就可以把代码写出来，逻辑也十分简单&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local thread = coroutine.create(function() 
	for cnt = 1, 5 do
		local tmp = {}
		for i = 1, 10 do
			table.insert(tmp, i)
		end
		print(&#39;child: &#39;, table.concat(tmp, &#39; &#39;))
		coroutine.yield()

		local tmp = {}
		for i = 1, 10 do
			table.insert(tmp, i)
		end
		print(&#39;child: &#39;, table.concat(tmp, &#39; &#39;))
		coroutine.yield()
	end

end)


for i=1, 5 do
	coroutine.resume(thread)
	local tmp = {}
	for i = 1, 100 do
		table.insert(tmp, i)
	end
	print(&#39;main: &#39;, table.concat(tmp, &#39; &#39;))

	print(&#39;------------------------------------&#39;)

	coroutine.resume(thread)

	local tmp = {}
	for i = 1, 100 do
		table.insert(tmp, i)
	end
	print(&#39;main: &#39;, table.concat(tmp, &#39; &#39;))

	print(&#39;====================================&#39;)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
child: 	1 2 3 4 5 6 7 8 9 10
main: 	1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100
------------------------------------
child: 	1 2 3 4 5 6 7 8 9 10
main: 	1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100
====================================
child: 	1 2 3 4 5 6 7 8 9 10
main: 	1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100
------------------------------------
child: 	1 2 3 4 5 6 7 8 9 10
main: 	1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100
====================================
child: 	1 2 3 4 5 6 7 8 9 10
main: 	1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100
------------------------------------
child: 	1 2 3 4 5 6 7 8 9 10
main: 	1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100
====================================
child: 	1 2 3 4 5 6 7 8 9 10
main: 	1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100
------------------------------------
child: 	1 2 3 4 5 6 7 8 9 10
main: 	1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100
====================================
child: 	1 2 3 4 5 6 7 8 9 10
main: 	1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100
------------------------------------
child: 	1 2 3 4 5 6 7 8 9 10
main: 	1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100
====================================

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;c&#34;&gt;c&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;volatile: 使用volatile类型的全局变量和sleep函数实现阻塞和互斥&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;pthread.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;ctype.h&amp;gt;

volatile int cond = 0;

void func(int n)
{
	int i = 0, j = 0;
	for(j=0; j&amp;lt;5; j++){
		while(cond != 0)
			sleep(1);
		printf(&amp;quot;\n----------------------------------\n&amp;quot;);
		printf(&amp;quot;child: &amp;quot;);
		for(i=0; i &amp;lt; 10; i++ )
			printf(&amp;quot;%d\t&amp;quot;, i);
		printf(&amp;quot;\n&amp;quot;);
		cond = 1;
	}
}

int main()
{
	pthread_t tid;
	int s = pthread_create(&amp;amp;tid, NULL, func, 10);
	if(s != 0){
		printf(&amp;quot;pthread_create error for %s&amp;quot;, strerror(errno));
		exit(1);
	}

	int i = 0, j = 0;
	for(j=0; j &amp;lt; 5; j++){
		while(cond != 1)
			sleep(1);
		printf(&amp;quot;master: &amp;quot;);
		for(i=0; i &amp;lt; 100; i++ )
			printf(&amp;quot;%d\t&amp;quot;, i);
		printf(&amp;quot;\n&amp;quot;);
		printf(&amp;quot;==================================\n&amp;quot;);
		cond = 0;
	}

	s = pthread_join(tid, NULL);
	if(s != 0){
		printf(&amp;quot;pthread_join error for %s&amp;quot;, strerror(errno));
		exit(1);
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;signal: 使用信号，用于进程互相通知对方&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;semop: 使用System V　进行线程同步，控制并发访问&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;pthread.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;ctype.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;

#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/ipc.h&amp;gt;
#include &amp;lt;sys/sem.h&amp;gt;

volatile int cond = 0;
int semid;
struct sembuf sem[2];

void func(int n)
{

//	printf(&amp;quot;ppid = %d, getpid = %d\n&amp;quot;, getppid(), getpid());

	int i = 0, j = 0;
	for(j=0; j&amp;lt;5; j++){

		sem[1].sem_num = 1;
		sem[1].sem_op = -1;
		sem[1].sem_flg = 0;
		semop(semid, &amp;amp;sem[1], 1);

		printf(&amp;quot;\n----------------------------------\n&amp;quot;);
		printf(&amp;quot;child: &amp;quot;);
		for(i=0; i &amp;lt; 10; i++ )
			printf(&amp;quot;%d\t&amp;quot;, i);
		printf(&amp;quot;\n&amp;quot;);

		sem[0].sem_num = 0;
		sem[0].sem_op = 1;
		sem[0].sem_flg = 0;
		semop(semid, &amp;amp;sem[0], 1);
	}
}

int main()
{
	semid = semget(IPC_PRIVATE, 2, 0666| IPC_CREAT);
	if(semid &amp;lt; 0){
		printf(&amp;quot;semget error for %s&amp;quot;, strerror(errno));
		exit(1);
	}

	pthread_t tid;
	int s = pthread_create(&amp;amp;tid, NULL, func, getpid());
	if(s != 0){
		printf(&amp;quot;pthread_create error for %s&amp;quot;, strerror(errno));
		exit(1);
	}

	int i = 0, j = 0;
	for(j=0; j &amp;lt; 5; j++){

		sem[0].sem_num = 0;
		sem[0].sem_op = -1;
		sem[0].sem_flg = 0;
		sem[1].sem_num = 1;
		sem[1].sem_op = 1;
		sem[1].sem_flg = 0;

		semop(semid, &amp;amp;sem[1], 1);
		semop(semid, &amp;amp;sem[0], 1);

		printf(&amp;quot;master: &amp;quot;);
		for(i=0; i &amp;lt; 100; i++ )
			printf(&amp;quot;%d\t&amp;quot;, i);
		printf(&amp;quot;\n&amp;quot;);
		printf(&amp;quot;==================================\n&amp;quot;);

		sem[1].sem_num = 1;
		sem[1].sem_op = 1;
		sem[1].sem_flg = 0;
	}

	s = pthread_join(tid, NULL);
	if(s != 0){
		printf(&amp;quot;pthread_join error for %s&amp;quot;, strerror(errno));
		exit(1);
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;python&#34;&gt;python&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;python yield&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;golang&#34;&gt;golang&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;goroutine之间可以通过channel进行多任务同步&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

var c1 chan int
var c2 chan int

func task(loop int, times int) {

	for i := 0; i &amp;lt; loop; i++ {
		&amp;lt;-c1
		fmt.Println(&amp;quot;------------------------------&amp;quot;)
		fmt.Print(&amp;quot;child: &amp;quot;)
		for j := 0; j &amp;lt; times; j++ {
			fmt.Printf(&amp;quot;%d\t&amp;quot;, j)
		}
		fmt.Println()
		c2 &amp;lt;- 1
	}
}

func main() {
	times := 100
	loop := 5

	c1 = make(chan int, 1024)
	c2 = make(chan int, 1024)

	go task(loop, 10)

	for i := 0; i &amp;lt; loop; i++ {
		c1 &amp;lt;- 1
		&amp;lt;-c2
		fmt.Print(&amp;quot;master: &amp;quot;)
		for j := 0; j &amp;lt; times; j++ {
			fmt.Printf(&amp;quot;%d\t&amp;quot;, j)
		}
		fmt.Println()
		fmt.Println(&amp;quot;==============================&amp;quot;)
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;其实golang的chan作为阻塞读取的协程通信组件，有一个也就能实现谁先谁后的同步了；毕竟，不光 val &amp;lt;- chan 这种读操作会堵塞，chan &amp;lt;- val这种写操作也会被堵塞&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

var c1 chan int

func task(loop int, times int) {

	for i := 0; i &amp;lt; loop; i++ {

		fmt.Println(&amp;quot;------------------------------&amp;quot;)
		fmt.Print(&amp;quot;child: &amp;quot;)
		for j := 0; j &amp;lt; times; j++ {
			fmt.Printf(&amp;quot;%d\t&amp;quot;, j)
		}
		fmt.Println()
		c1 &amp;lt;- 1
	}
}

func main() {
	times := 100
	loop := 5

	c1 = make(chan int)
	go task(loop, 10)

	for i := 0; i &amp;lt; loop; i++ {

		&amp;lt;-c1
		fmt.Print(&amp;quot;master: &amp;quot;)
		for j := 0; j &amp;lt; times; j++ {
			fmt.Printf(&amp;quot;%d\t&amp;quot;, j)
		}
		fmt.Println()
		fmt.Println(&amp;quot;==============================&amp;quot;)
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;shell&#34;&gt;shell&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;token bucket&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>SO_REUSEADDR和SO_REUSEPORT</title>
      <link>https://bg2bkk.github.io/post/SO_REUSEADDR%E5%92%8CSO_REUSEPORT/</link>
      <pubDate>Mon, 09 May 2016 16:55:42 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/SO_REUSEADDR%E5%92%8CSO_REUSEPORT/</guid>
      <description>

&lt;h2 id=&#34;结论&#34;&gt;结论&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;1. SO_REUSEPORT用于多个socket监听同一个TCP链接
2. SO_REUSEADDR可用于多个进程bind同一端口，但需要TCP连接的四元组不一样。
3. SO_REUSEPORT比SO_REUSEADDR更加扩展，但是也带来了隐患，需要额外注意
4. SO_REUSEADDR的最大作用是，当服务因故障重启时，不用等待需要绑定的端口从TIME_WAIT状态变更到CLOSED状态，就可以直接绑定该端口
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;

&lt;p&gt;nginx 1.9.1引入了 SO_REUSEPORT选项，在高版本（linux kernel 3.9以上）系统上可用。该选项允许多个socket监听同一个IP:PORT组合，&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SO_REUSEPORT可以&lt;a href=&#34;http://freeprogrammersblog.vhex.net/post/linux-39-introdued-new-way-of-writing-socket-servers/2&#34;&gt;简化服务器编程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;prefork模式：master预先分配进程池，每一个client连接用一个进程处理

&lt;ul&gt;
&lt;li&gt;省资源，不用每次都fork，然后再回收&lt;/li&gt;
&lt;li&gt;可控制，预先分配的进程池大小是固定的&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;SO_REUSEPORT使得多进程时不用使master再做管理工作，比如管理子进程，设置信号等等，设置不需要一个master进程，只需要子进程监听同一个端口就行。操作系统做了大部分工作。

&lt;ul&gt;
&lt;li&gt;这里还有个好处是，C写的server模块，python写的server模块，它们可以共存监听同一个端口，灵活性更好&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;听听linux-kernle-维护者怎么说-https-lwn-net-articles-542629&#34;&gt;听听linux kernle&lt;a href=&#34;https://lwn.net/Articles/542629/&#34;&gt;维护者怎么说&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;允许多个进程绑定host上的同一端口&lt;/li&gt;
&lt;li&gt;只需要第一个绑定端口的进程指定SO_REUSEPORT选项，后继者都可以绑定该端口，所以需要担心的是端口劫持，不希望恶意程序能accept该端口的连接。&lt;/li&gt;
&lt;li&gt;方法是后继者要与第一次绑定端口的进程的USER ID一样，比如用root和普通用户启动程序绑定同一个端口，会报address already in use&lt;/li&gt;
&lt;li&gt;SO_REUSEPORT的负载均衡性能更好
&lt;!--        * 这里的负载均衡可能指的不是主动分配的，而是当多个线程监听同一端口时，如果某个线程在忙，那么新来的请求自然会被load较低的线程处理，间接的达到均衡效果 --&gt;&lt;/li&gt;
&lt;li&gt;TCP和UDP都可以用

&lt;ul&gt;
&lt;li&gt;UDP场景中，在DNS server的应用比较有意义，可以负载均衡的处理dns请求&lt;/li&gt;
&lt;li&gt;作者指出，SO_REUSEADDR虽然也能让UDP连接绑定同一端口，但是SO_REUSEPORT可以防止劫持，并能将请求均衡的分配给监听的线程&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;传统多线程的工作模式的缺点&#34;&gt;传统多线程的工作模式的缺点&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;1. 传统的多线程server都是有一个listener线程绑定端口并接受所有的请求，然后传递给其他线程，而这个listener往往会成为瓶颈&lt;/li&gt;
&lt;li&gt;2. master绑定端口，每个slave轮流accept从该端口获取连接（nginx）

&lt;ul&gt;
&lt;li&gt;缺点是有可能导致每个slave不能平均的处理连接，unblanced；有的slave处理的过多，有的slave处理的过少，导致cpu资源不能充分利用&lt;/li&gt;
&lt;li&gt;SO_REUSEPORT的实现可以使请求平均的分配给堵塞在accept上的各个进程&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;so-reuseport的应用举例&#34;&gt;SO_REUSEPORT的应用举例&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;server.py&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import socket
import os

SO_REUSEPORT = 15

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.setsockopt(socket.SOL_SOCKET, SO_REUSEPORT, 1)
s.bind((&#39;&#39;, 10000))
s.listen(1)
while True:
    conn, addr = s.accept()
    print(&#39;Connected to {}&#39;.format(os.getpid()))
    data = conn.recv(1024)
    conn.send(data)
    conn.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动两个进程，都绑定10000端口；使用nc作为client&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ python server.py&amp;amp;
[1] 12649
$ python server.py&amp;amp;
[2] 12650
$ echo data | nc localhost 10000
Connected to 12649
data
$ echo data | nc localhost 10000
Connected to 12650
data
$ echo data | nc localhost 10000
Connected to 12649
data
$ echo data | nc localhost 10000
Connected to 12650
data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再启动一个新的进程显然也是可以的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ python server.py&amp;amp;
[3] 14021
$ echo data | nc localhost 10000
Connected to 12650
data
$ echo data | nc localhost 10000
Connected to 14021
data
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/kavu/go_reuseport&#34;&gt;SO_REUSEPORT在golang中的实践&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.microhowto.info/howto/listen_on_a_tcp_port_with_connections_in_the_time_wait_state.html&#34;&gt;SO_REUSEADDR的使用场景&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在某tcp连接处于 TIME_WAIT状态时，它所占用的port不能被立刻使用&lt;/li&gt;
&lt;li&gt;例如server端服务挂掉后需要重启，重启时发现需要bind的端口处于TIME_WAIT状态，不能立刻使用，错误码为EADDRINUSE，glibc将这个错误码渲染为 &amp;ldquo;Address already in use&amp;rdquo;&lt;/li&gt;
&lt;li&gt;TIME_WAIT状态持续时间为2MSL，一个MSL通常是30s到2min，所以该状态时长为1min到4min；这是不可忍受的&lt;/li&gt;
&lt;li&gt;SO_REUSEADDR可以使得进程能够绑定处于TIME_WAIT状态的端口，在服务重启的时候很有用&lt;/li&gt;
&lt;li&gt;SO_REUSEADDR同样可以使得进程能够绑定处于ESTABLISHED状态的连接&lt;/li&gt;
&lt;li&gt;无论如何，SO_REUSEADDR不允许相同ip和port的四元组存在&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;so-reuseport-和-so-reuseaddr-对比-待续&#34;&gt;SO_REUSEPORT 和 SO_REUSEADDR 对比（待续）&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;前者可以防止端口被恶意进程劫持&lt;/li&gt;
&lt;li&gt;前者可以使请求平均分配给各个进程&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考链接&#34;&gt;参考链接&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://lwn.net/Articles/542629/&#34;&gt;lwn: the SO_REUSEPORT socket option&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/14388706/socket-options-so-reuseaddr-and-so-reuseport-how-do-they-differ-do-they-mean-t&#34;&gt;topic on so_reuseaddr and so_reuseport on stackoverflow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>tcp_fast_open的概念 作用以及实现</title>
      <link>https://bg2bkk.github.io/post/tcp_fast_open%E7%9A%84%E6%A6%82%E5%BF%B5%20%E4%BD%9C%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Mon, 09 May 2016 15:53:34 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/tcp_fast_open%E7%9A%84%E6%A6%82%E5%BF%B5%20%E4%BD%9C%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%AE%9E%E7%8E%B0/</guid>
      <description>

&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;三次握手的过程中，当用户首次访问server时，发送syn包，server根据用户IP生成cookie，并与syn+ack一同发回client；client再次访问server时，在syn包携带TCP cookie；如果server校验合法，则在用户回复ack前就可以直接发送数据；否则按照正常三次握手进行。&lt;/p&gt;

&lt;p&gt;TFO提高性能的关键是省去了热请求的三次握手，这在充斥着小对象的移动应用场景中能够极大提升性能。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Google研究发现TCP 二次握手是页面延迟时间的重要部分，所以提出TFO&lt;/p&gt;

&lt;p&gt;TFO的fast open标志体现在TCP报文的头部的&lt;a href=&#34;http://www.iana.org/assignments/tcp-parameters/tcp-parameters.xhtml&#34;&gt;OPTION字段&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;TCP Fast Open的标准文档是&lt;a href=&#34;http://tools.ietf.org/html/rfc7413&#34;&gt;rfc7413&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;TFO与2.6.34内核合并到主线，&lt;a href=&#34;https://lwn.net/Articles/508865/&#34;&gt;lwn通告地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;TFO的使用目前还是有些复杂的，从&lt;a href=&#34;https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt&#34;&gt;linux的network文档来看&lt;/a&gt;：&lt;/p&gt;

&lt;p&gt;TFO的配置说明：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;tcp_fastopen - INTEGER
	Enable TCP Fast Open feature (draft-ietf-tcpm-fastopen) to send data
	in the opening SYN packet. To use this feature, the client application
	must use sendmsg() or sendto() with MSG_FASTOPEN flag rather than
	connect() to perform a TCP handshake automatically.

	The values (bitmap) are
	1: Enables sending data in the opening SYN on the client w/ MSG_FASTOPEN.
	2: Enables TCP Fast Open on the server side, i.e., allowing data in
	   a SYN packet to be accepted and passed to the application before
	   3-way hand shake finishes.
	4: Send data in the opening SYN regardless of cookie availability and
	   without a cookie option.
	0x100: Accept SYN data w/o validating the cookie.
	0x200: Accept data-in-SYN w/o any cookie option present.
	0x400/0x800: Enable Fast Open on all listeners regardless of the
	   TCP_FASTOPEN socket option. The two different flags designate two
	   different ways of setting max_qlen without the TCP_FASTOPEN socket
	   option.

	Default: 1

	Note that the client &amp;amp; server side Fast Open flags (1 and 2
	respectively) must be also enabled before the rest of flags can take
	effect.

	See include/net/tcp.h and the code for more details.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了启用 tcp fast open功能&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- client需要使用sendmsg或者sento系统调用，加上MSG_FASTOPEN flag，来连接server端，代替connect系统调用。
- 对server端不做要求。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;linux系统（高版本内核）默认tcp_fastopen为1：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sysctl -a | grep fastopen

net.ipv4.tcp_fastopen = 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试代码： server.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// reference: http://blog.csdn.net/hanhuili/article/details/8540227

#include &amp;lt;string.h&amp;gt;         
#include &amp;lt;sys/types.h&amp;gt; /* See NOTES */
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
int main(){
    int portno = 6666;
    socklen_t clilen;
    char buffer[256];
    struct sockaddr_in serv_addr, cli_addr;
    int cfd;
    int sfd = socket(AF_INET, SOCK_STREAM, 0);   // Create socket
    
    bzero((char *) &amp;amp;serv_addr, sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = INADDR_ANY;
    serv_addr.sin_port = htons(portno);
    bind(sfd, &amp;amp;serv_addr,sizeof(serv_addr));      // Bind to well known address
    
    int qlen = 5;                 // Value to be chosen by application
    int err = setsockopt(sfd, IPPROTO_TCP/*SOL_TCP*/, 23/*TCP_FASTOPEN*/, &amp;amp;qlen, sizeof(qlen));
    
    listen(sfd,1);                // Mark socket to receive connections

	while(1){
		cfd = accept(sfd, NULL, 0);   // Accept connection on new socket

		while(1){
			int len = read(cfd,buffer,256);
			if(len)
				printf(&amp;quot;tcp fast open: %s\n&amp;quot;,buffer);
			else
				break;
			// read and write data on connected socket cfd
		}

		memset(buffer, 0, 256);
		close(cfd);
	}

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试代码：client.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
#include &amp;lt;netdb.h&amp;gt; 
#include &amp;lt;errno.h&amp;gt;
int main(){
    struct sockaddr_in serv_addr;
    struct hostent *server;

    char *data = &amp;quot;Hello, tcp fast open&amp;quot;;
    int data_len = strlen(data);    
    
    int sfd = socket(AF_INET, SOCK_STREAM, 0);
    server = gethostbyname(&amp;quot;localhost&amp;quot;);
    
    bzero((char *) &amp;amp;serv_addr, sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;
    bcopy((char *)server-&amp;gt;h_addr, 
         (char *)&amp;amp;serv_addr.sin_addr.s_addr,
         server-&amp;gt;h_length);
    serv_addr.sin_port = htons(6666);

// /usr/src/linux-headers-4.4.0-22/include/linux/socket.h:#define MSG_FASTOPEN	0x20000000	/* Send data in TCP SYN */

//  int len = sendto(sfd, data, data_len, 0x20000000/*MSG_FASTOPEN*/, 

    int len = sendto(sfd, data, data_len, MSG_FASTOPEN/*MSG_FASTOPEN*/, 
                (struct sockaddr *) &amp;amp;serv_addr, sizeof(serv_addr));
	if(errno != 0){
		printf(&amp;quot;error: %s\n&amp;quot;, strerror(errno));
	}
    close(sfd);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通信过程：tcpdump&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
$ sudo tcpdump -i any port 6666 -X

# 第一次 ./client.o

00:29:34.820187 IP localhost.51388 &amp;gt; localhost.6666: Flags [S], seq 755101042, win 43690, options [mss 65495,sackOK,TS val 17053 ecr 0,nop,wscale 7,unknown-34,nop,nop], length 0
	0x0000:  4500 0040 afef 4000 4006 8cc6 7f00 0001  E..@..@.@.......
	0x0010:  7f00 0001 c8bc 1a0a 2d01 ed72 0000 0000  ........-..r....
	0x0020:  b002 aaaa fe34 0000 0204 ffd7 0402 080a  .....4..........
	0x0030:  0000 429d 0000 0000 0103 0307 2202 0101  ..B.........&amp;quot;...
00:29:34.820284 IP localhost.6666 &amp;gt; localhost.51388: Flags [S.], seq 3725111481, ack 755101043, win 43690, options [mss 65495,sackOK,TS val 17053 ecr 17053,nop,wscale 7], length 0
	0x0000:  4500 003c 0000 4000 4006 3cba 7f00 0001  E..&amp;lt;..@.@.&amp;lt;.....
	0x0010:  7f00 0001 1a0a c8bc de08 b0b9 2d01 ed73  ............-..s
	0x0020:  a012 aaaa fe30 0000 0204 ffd7 0402 080a  .....0..........
	0x0030:  0000 429d 0000 429d 0103 0307            ..B...B.....
00:29:34.820372 IP localhost.51388 &amp;gt; localhost.6666: Flags [P.], seq 1:21, ack 1, win 342, options [nop,nop,TS val 17053 ecr 17053], length 20
	0x0000:  4500 0048 aff0 4000 4006 8cbd 7f00 0001  E..H..@.@.......
	0x0010:  7f00 0001 c8bc 1a0a 2d01 ed73 de08 b0ba  ........-..s....
	0x0020:  8018 0156 fe3c 0000 0101 080a 0000 429d  ...V.&amp;lt;........B.
	0x0030:  0000 429d 4865 6c6c 6f2c 2074 6370 2066  ..B.Hello,.tcp.f
	0x0040:  6173 7420 6f70 656e                      ast.open
00:29:34.820433 IP localhost.6666 &amp;gt; localhost.51388: Flags [.], ack 21, win 342, options [nop,nop,TS val 17053 ecr 17053], length 0
	0x0000:  4500 0034 f227 4000 4006 4a9a 7f00 0001  E..4.&#39;@.@.J.....
	0x0010:  7f00 0001 1a0a c8bc de08 b0ba 2d01 ed87  ............-...
	0x0020:  8010 0156 fe28 0000 0101 080a 0000 429d  ...V.(........B.
	0x0030:  0000 429d                                ..B.
00:29:34.859246 IP localhost.6666 &amp;gt; localhost.51388: Flags [.], ack 22, win 342, options [nop,nop,TS val 17063 ecr 17053], length 0
	0x0000:  4500 0034 f228 4000 4006 4a99 7f00 0001  E..4.(@.@.J.....
	0x0010:  7f00 0001 1a0a c8bc de08 b0ba 2d01 ed88  ............-...
	0x0020:  8010 0156 fe28 0000 0101 080a 0000 42a7  ...V.(........B.
	0x0030:  0000 429d                                ..B.

# 第二次 ./client.o

00:29:39.271936 IP localhost.51398 &amp;gt; localhost.6666: Flags [S], seq 2362540136, win 43690, options [mss 65495,sackOK,TS val 18166 ecr 0,nop,wscale 7,exp-tfo cookiereq], length 0
	0x0000:  4500 0040 c69e 4000 4006 7617 7f00 0001  E..@..@.@.v.....
	0x0010:  7f00 0001 c8c6 1a0a 8cd1 8068 0000 0000  ...........h....
	0x0020:  b002 aaaa fe34 0000 0204 ffd7 0402 080a  .....4..........
	0x0030:  0000 46f6 0000 0000 0103 0307 fe04 f989  ..F.............
00:29:39.271986 IP localhost.6666 &amp;gt; localhost.51398: Flags [S.], seq 3703577773, ack 2362540137, win 43690, options [mss 65495,sackOK,TS val 18166 ecr 18166,nop,wscale 7], length 0
	0x0000:  4500 003c 0000 4000 4006 3cba 7f00 0001  E..&amp;lt;..@.@.&amp;lt;.....
	0x0010:  7f00 0001 1a0a c8c6 dcc0 1cad 8cd1 8069  ...............i
	0x0020:  a012 aaaa fe30 0000 0204 ffd7 0402 080a  .....0..........
	0x0030:  0000 46f6 0000 46f6 0103 0307            ..F...F.....
00:29:39.272038 IP localhost.51398 &amp;gt; localhost.6666: Flags [P.], seq 1:21, ack 1, win 342, options [nop,nop,TS val 18166 ecr 18166], length 20
	0x0000:  4500 0048 c69f 4000 4006 760e 7f00 0001  E..H..@.@.v.....
	0x0010:  7f00 0001 c8c6 1a0a 8cd1 8069 dcc0 1cae  ...........i....
	0x0020:  8018 0156 fe3c 0000 0101 080a 0000 46f6  ...V.&amp;lt;........F.
	0x0030:  0000 46f6 4865 6c6c 6f2c 2074 6370 2066  ..F.Hello,.tcp.f
	0x0040:  6173 7420 6f70 656e                      ast.open
00:29:39.272072 IP localhost.6666 &amp;gt; localhost.51398: Flags [.], ack 21, win 342, options [nop,nop,TS val 18166 ecr 18166], length 0
	0x0000:  4500 0034 5a58 4000 4006 e269 7f00 0001  E..4ZX@.@..i....
	0x0010:  7f00 0001 1a0a c8c6 dcc0 1cae 8cd1 807d  ...............}
	0x0020:  8010 0156 fe28 0000 0101 080a 0000 46f6  ...V.(........F.
	0x0030:  0000 46f6                                ..F.
00:29:39.311280 IP localhost.6666 &amp;gt; localhost.51398: Flags [.], ack 22, win 342, options [nop,nop,TS val 18176 ecr 18166], length 0
	0x0000:  4500 0034 5a59 4000 4006 e268 7f00 0001  E..4ZY@.@..h....
	0x0010:  7f00 0001 1a0a c8c6 dcc0 1cae 8cd1 807e  ...............~
	0x0020:  8010 0156 fe28 0000 0101 080a 0000 4700  ...V.(........G.
	0x0030:  0000 46f6                                ..F.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;奇怪的是，在代码中启用tcp_fastopen的结果和不启用，并没有区别。那这是什么原因呢？&lt;/p&gt;

&lt;p&gt;通过搜索，发现在介绍&lt;a href=&#34;https://github.com/shadowsocks/shadowsocks/wiki/TCP-Fast-Open&#34;&gt;tcp fast open优化shadowsocks&lt;/a&gt;时，设置net.ipv4.tcp_fastopen为3，虽然奇怪，但是可以试试：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sysctl -a | grep fastopen

net.ipv4.tcp_fastopen = 3
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
# 第一次，server返回cookie unknown-34 0x38af51c10bf41ca4

00:36:36.667932 IP localhost.52220 &amp;gt; localhost.6666: Flags [S], seq 3662514892, win 43690, options [mss 65495,sackOK,TS val 122515 ecr 0,nop,wscale 7,unknown-34,nop,nop], length 0
	0x0000:  4500 0040 545f 4000 4006 e856 7f00 0001  E..@T_@.@..V....
	0x0010:  7f00 0001 cbfc 1a0a da4d 8acc 0000 0000  .........M......
	0x0020:  b002 aaaa fe34 0000 0204 ffd7 0402 080a  .....4..........
	0x0030:  0001 de93 0000 0000 0103 0307 2202 0101  ............&amp;quot;...
00:36:36.667990 IP localhost.6666 &amp;gt; localhost.52220: Flags [S.], seq 3186866007, ack 3662514893, win 43690, options [mss 65495,sackOK,TS val 122515 ecr 122515,nop,wscale 7,unknown-34 0x38af51c10bf41ca4,nop,nop], length 0
	0x0000:  4500 0048 0000 4000 4006 3cae 7f00 0001  E..H..@.@.&amp;lt;.....
	0x0010:  7f00 0001 1a0a cbfc bdf3 b757 da4d 8acd  ...........W.M..
	0x0020:  d012 aaaa fe3c 0000 0204 ffd7 0402 080a  .....&amp;lt;..........
	0x0030:  0001 de93 0001 de93 0103 0307 220a 38af  ............&amp;quot;.8.
	0x0040:  51c1 0bf4 1ca4 0101                      Q.......
00:36:36.668050 IP localhost.52220 &amp;gt; localhost.6666: Flags [P.], seq 1:21, ack 1, win 342, options [nop,nop,TS val 122515 ecr 122515], length 20
	0x0000:  4500 0048 5460 4000 4006 e84d 7f00 0001  E..HT`@.@..M....
	0x0010:  7f00 0001 cbfc 1a0a da4d 8acd bdf3 b758  .........M.....X
	0x0020:  8018 0156 fe3c 0000 0101 080a 0001 de93  ...V.&amp;lt;..........
	0x0030:  0001 de93 4865 6c6c 6f2c 2074 6370 2066  ....Hello,.tcp.f
	0x0040:  6173 7420 6f70 656e                      ast.open
00:36:36.668109 IP localhost.6666 &amp;gt; localhost.52220: Flags [.], ack 21, win 342, options [nop,nop,TS val 122515 ecr 122515], length 0
	0x0000:  4500 0034 69cb 4000 4006 d2f6 7f00 0001  E..4i.@.@.......
	0x0010:  7f00 0001 1a0a cbfc bdf3 b758 da4d 8ae1  ...........X.M..
	0x0020:  8010 0156 fe28 0000 0101 080a 0001 de93  ...V.(..........
	0x0030:  0001 de93                                ....
00:36:36.707264 IP localhost.6666 &amp;gt; localhost.52220: Flags [.], ack 22, win 342, options [nop,nop,TS val 122525 ecr 122515], length 0
	0x0000:  4500 0034 69cc 4000 4006 d2f5 7f00 0001  E..4i.@.@.......
	0x0010:  7f00 0001 1a0a cbfc bdf3 b758 da4d 8ae2  ...........X.M..
	0x0020:  8010 0156 fe28 0000 0101 080a 0001 de9d  ...V.(..........
	0x0030:  0001 de93                                ....


# 第二次，client发送请求时，将cookie写在syn包中，同时带上发送的数据；server端校验后(kernel和tcp/ip协议栈做校验)后返回成功，如此在3次握手中节省了一次rtt时间

00:36:38.744954 IP localhost.52226 &amp;gt; localhost.6666: Flags [S], seq 1820632025:1820632045, win 43690, options [mss 65495,sackOK,TS val 123034 ecr 0,nop,wscale 7,unknown-34 0x38af51c10bf41ca4,nop,nop], length 20
	0x0000:  4500 005c 4343 4000 4006 f956 7f00 0001  E..\CC@.@..V....
	0x0010:  7f00 0001 cc02 1a0a 6c84 a3d9 0000 0000  ........l.......
	0x0020:  d002 aaaa fe50 0000 0204 ffd7 0402 080a  .....P..........
	0x0030:  0001 e09a 0000 0000 0103 0307 220a 38af  ............&amp;quot;.8.
	0x0040:  51c1 0bf4 1ca4 0101 4865 6c6c 6f2c 2074  Q.......Hello,.t
	0x0050:  6370 2066 6173 7420 6f70 656e            cp.fast.open
00:36:38.745022 IP localhost.6666 &amp;gt; localhost.52226: Flags [S.], seq 3848342665, ack 1820632046, win 43690, options [mss 65495,sackOK,TS val 123034 ecr 123034,nop,wscale 7], length 0
	0x0000:  4500 003c 0000 4000 4006 3cba 7f00 0001  E..&amp;lt;..@.@.&amp;lt;.....
	0x0010:  7f00 0001 1a0a cc02 e561 0c89 6c84 a3ee  .........a..l...
	0x0020:  a012 aaaa fe30 0000 0204 ffd7 0402 080a  .....0..........
	0x0030:  0001 e09a 0001 e09a 0103 0307            ............
00:36:38.745072 IP localhost.52226 &amp;gt; localhost.6666: Flags [.], ack 1, win 342, options [nop,nop,TS val 123034 ecr 123034], length 0
	0x0000:  4500 0034 4344 4000 4006 f97d 7f00 0001  E..4CD@.@..}....
	0x0010:  7f00 0001 cc02 1a0a 6c84 a3ee e561 0c8a  ........l....a..
	0x0020:  8010 0156 fe28 0000 0101 080a 0001 e09a  ...V.(..........
	0x0030:  0001 e09a                                ....
00:36:38.745127 IP localhost.52226 &amp;gt; localhost.6666: Flags [F.], seq 1, ack 1, win 342, options [nop,nop,TS val 123034 ecr 123034], length 0
	0x0000:  4500 0034 4345 4000 4006 f97c 7f00 0001  E..4CE@.@..|....
	0x0010:  7f00 0001 cc02 1a0a 6c84 a3ee e561 0c8a  ........l....a..
	0x0020:  8011 0156 fe28 0000 0101 080a 0001 e09a  ...V.(..........
	0x0030:  0001 e09a                                ....
00:36:38.747232 IP localhost.6666 &amp;gt; localhost.52226: Flags [.], ack 2, win 342, options [nop,nop,TS val 123035 ecr 123034], length 0
	0x0000:  4500 0034 ec10 4000 4006 50b1 7f00 0001  E..4..@.@.P.....
	0x0010:  7f00 0001 1a0a cc02 e561 0c8a 6c84 a3ef  .........a..l...
	0x0020:  8010 0156 fe28 0000 0101 080a 0001 e09b  ...V.(..........
	0x0030:  0001 e09a                                ....

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;上述通信过程中

&lt;ul&gt;
&lt;li&gt;第一次，server返回cookie unknown-34 0x38af51c10bf41ca4&lt;/li&gt;
&lt;li&gt;第二次，client发送请求时，将cookie写在syn包中，同时带上发送的数据；server端校验后(kernel和tcp/ip协议栈做校验)后返回成功，如此在3次握手中节省了一次rtt时间&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;也就是说，在net.ipv4.tcp_fastopen设置为3时，tcp fastopen特性使能&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关于如何使能TFO，在前文中的TFO的配置说明中，我们可以看到，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;	The values (bitmap) are
	1: Enables sending data in the opening SYN on the client w/ MSG_FASTOPEN.
		使能client端的TFO特性
	2: Enables TCP Fast Open on the server side, i.e., allowing data in
	   a SYN packet to be accepted and passed to the application before
	   3-way hand shake finishes.
		使能server端的TFO特性
	4: Send data in the opening SYN regardless of cookie availability and
	   without a cookie option.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;并且这个标志是位操作，如果我在本机做实验，将本机作为sever端和client端的话，需要两个位都使能，所以应该将该值设置为3.&lt;/p&gt;

&lt;p&gt;同时我们可以看到，tcp fast open是非常向后兼容的，升级成本不高，需要高于3.7+版本内核，但总体来说值得采用。&lt;/p&gt;

&lt;p&gt;nginx 1.5.18（2013年）开始支持tcp fast open&lt;/p&gt;

&lt;h2 id=&#34;todo-list&#34;&gt;TODO LIST&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;TFO在移动端场景中的性能体现：android+nginx&lt;/li&gt;
&lt;li&gt;tcp fast open 在内核中的实现&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考链接&#34;&gt;参考链接&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.sina.com.cn/s/blog_583f42f101011veh.html&#34;&gt;TFO&amp;mdash;google tcp fast open protocol&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/TCP_Fast_Open&#34;&gt;wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.pagefault.info/?p=282&#34;&gt;TFO简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bradleyfalzon/tcp-fast-open&#34;&gt;tfo的golang实现(github)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bradleyf.id.au/nix/shaving-your-rtt-wth-tfo/&#34;&gt;上一行项目的作者bradley falzon&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://static.googleusercontent.com/external_content/untrusted_dlcp/research.google.com/zh-CN/us/pubs/archive/37517.pdf&#34;&gt;google关于tfo的论文&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>effective tips in daily learning</title>
      <link>https://bg2bkk.github.io/post/effective%20tips%20in%20daily%20learning/</link>
      <pubDate>Fri, 06 May 2016 11:39:48 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/effective%20tips%20in%20daily%20learning/</guid>
      <description>

&lt;h2 id=&#34;kernel&#34;&gt;kernel&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/column/details/linux-kernel-no-code.html&#34;&gt;kernel工程导论&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;内存管理&#34;&gt;内存管理&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.jobbole.com/103993/&#34;&gt;http://blog.jobbole.com/103993/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.jobbole.com/88673/&#34;&gt;http://blog.jobbole.com/88673/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;前端开发&#34;&gt;前端开发&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如何使textarea的大小随着其内容增加而变化呢？&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;解决方法&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1、&lt;a href=&#34;http://audi.tw/Blog/Javascript/javascript.textarea.autogrow.asp&#34;&gt;http://audi.tw/Blog/Javascript/javascript.textarea.autogrow.asp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;2、&lt;a href=&#34;http://www.cnblogs.com/xmmcn/archive/2012/12/18/2822968.html&#34;&gt;http://www.cnblogs.com/xmmcn/archive/2012/12/18/2822968.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;3、jquery 插件: &lt;a href=&#34;https://bobscript.com/archives/419/&#34;&gt;https://bobscript.com/archives/419/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;awk&#34;&gt;awk&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.sina.com.cn/s/blog_4a033b090100xo2b.html&#34;&gt;http://blog.sina.com.cn/s/blog_4a033b090100xo2b.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/junjieguo/article/details/7525794&#34;&gt;http://blog.csdn.net/junjieguo/article/details/7525794&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;postgre&#34;&gt;postgre&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.51yip.com/pgsql/1528.html&#34;&gt;修改表结构&lt;/a&gt;，&lt;a href=&#34;https://wiki.postgresql.org/wiki/ALTER_TABLE&#34;&gt;postgre_wiki&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/2013/12/getting_started_with_postgresql.html&#34;&gt;插入数据&lt;/a&gt;、&lt;a href=&#34;https://wiki.postgresql.org/wiki/9.1%E7%AC%AC%E5%85%AD%E7%AB%A0&#34;&gt;postgre_wiki&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://my.oschina.net/Kenyon/blog/101432&#34;&gt;清楚pg_xlog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;python&#34;&gt;python&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;python魔术方法

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://pycoders-weekly-chinese.readthedocs.io/en/latest/issue6/a-guide-to-pythons-magic-methods.html#id19&#34;&gt;指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/wklken/article/details/8126381&#34;&gt;入门&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;http协议&#34;&gt;[http协议]&lt;/h2&gt;

&lt;p&gt;http协议301和302的区别&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/caiyuanzai/archive/2012/04/24/2469013.html&#34;&gt;http://www.cnblogs.com/caiyuanzai/archive/2012/04/24/2469013.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/qmhball/article/details/7838989&#34;&gt;http://blog.csdn.net/qmhball/article/details/7838989&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;linux-socket编程样例&#34;&gt;linux socket编程样例&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://alas.matf.bg.ac.rs/manuals/lspe/snode=106.html&#34;&gt;http://alas.matf.bg.ac.rs/manuals/lspe/snode=106.html&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/win_lin/article/details/7760951&#34;&gt;进程间传递fd&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;linux-apue编程&#34;&gt;linux apue编程&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;epoll是同步非阻塞的&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;epoll、select等多路服用IO，将fd加入等待时间的队列中，每隔一段时间去轮询一次，因此是同步的；优点是能够在等待任务的时间里去做别的任务；缺点是任务完成的响应延迟增大，因为每隔一段时间去轮询他们，在时间间隔内任务可能已经完成而等待处理等待了一段时间了。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://ring0.me/2014/11/sync-async-blocked/&#34;&gt;参考链接&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;同步/异步指的是被调用方的通知方式，被调用方完成后，主动通知调用方，还是等待调用方发现。前者是异步，后者是同步。从这里也可以看出，&lt;a href=&#34;https://segmentfault.com/a/1190000003063859&#34;&gt;异步IO通知调用方时，数据已经就绪&lt;/a&gt;，对于网络IO来说，异步IO已经将数据从内核复制到用户空间了。&lt;/p&gt;

&lt;p&gt;阻塞/非阻塞是调用方的等待方式，是一直等待在做的事件完成，还是去做别的事情，等到在做的事件完成后再接着进行处理。前者是阻塞，后者是非阻塞&lt;/p&gt;

&lt;p&gt;因此epoll是同步和非阻塞的。&lt;/p&gt;

&lt;h2 id=&#34;性能分析&#34;&gt;性能分析&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://sourceware.org/systemtap/examples/keyword-index.html#FUTEX&#34;&gt;有用的systemtap脚本&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;分布式存储&#34;&gt;分布式存储&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://wuchong.me/blog/2014/08/07/distributed-storage-system-knowledge/&#34;&gt;知识体系&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://taop.marchtea.com/03.02.html&#34;&gt;B-Tree&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;分布式id生成&#34;&gt;分布式ID生成&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;amp;mid=403837240&amp;amp;idx=1&amp;amp;sn=ae9f2bf0cc5b0f68f9a2213485313127&amp;amp;scene=21#wechat_redirect&#34;&gt;ID&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;方案一： 常规数据库的auto increment服务

&lt;ul&gt;
&lt;li&gt;改进：可以将ID划均分给若干数据库，每个数据库自增的起点不一样，可以保证各库生成ID不同

&lt;ul&gt;
&lt;li&gt;缺点是非强一致性&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;方案二： 单点批量生成；ID生成服务每次从数据库预定一定容量的ID，然后派发；可以成倍降低数据库压力；

&lt;ul&gt;
&lt;li&gt;缺点：单点服务、可能造成空洞；&lt;/li&gt;
&lt;li&gt;改进：找备胎，一旦主ID服务挂掉，备胎立刻备上；通过vip+keepalived实现&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;方案三：uuid&lt;/li&gt;
&lt;li&gt;方案四：当前毫秒数；缺点是每个毫秒容量有限，也可能重复&lt;/li&gt;
&lt;li&gt;方案五：将64bit数字作为ID，分别包含字段：毫秒数、业务线、机房、机器、以及毫秒内序列号；根据业务来规划容量；毫秒数可以保证ID是趋势自增的&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/heyuquan/archive/2013/08/16/global-guid-identity-maxId.html&#34;&gt;ID&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;分布式锁&#34;&gt;分布式锁&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/zhengyun_ustc/archive/2012/11/17/topic2.html&#34;&gt;http://www.cnblogs.com/zhengyun_ustc/archive/2012/11/17/topic2.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.jeffkit.info/2011/07/1000/&#34;&gt;http://www.jeffkit.info/2011/07/1000/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;一致性哈希-consistent-hashing&#34;&gt;一致性哈希 consistent hashing&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.codeproject.com/Articles/56138/Consistent-hashing&#34;&gt;http://www.codeproject.com/Articles/56138/Consistent-hashing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.huanghao.me/?p=14&#34;&gt;http://blog.huanghao.me/?p=14&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/sparkliang/article/details/5279393&#34;&gt;http://blog.csdn.net/sparkliang/article/details/5279393&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2pc-3pc和paxos算法&#34;&gt;2PC、3PC和Paxos算法&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://coolshell.cn/articles/10910.html&#34;&gt;coolshell&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;并发编程&#34;&gt;并发编程&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://hedengcheng.com/?p=725&#34;&gt;volatile&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://blogread.cn/it/article/7282?f=wb&#34;&gt;并发编程&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.infoq.com/cn/articles/producers-and-consumers-mode&#34;&gt;聊聊并发&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;nginx配置文件&#34;&gt;nginx配置文件&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;rewrite:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.xiehaichao.com/articles/428.html&#34;&gt;http://www.xiehaichao.com/articles/428.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://seanlook.com/2015/05/17/nginx-location-rewrite/&#34;&gt;http://seanlook.com/2015/05/17/nginx-location-rewrite/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://stackoverflow.com/questions/13621915/nginx-error-pages-one-location-rule-to-fit-them-all&#34;&gt;nginx配置使用用户自定义错误页面&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;lua的学习-使用和源码精读&#34;&gt;Lua的学习、使用和源码精读&lt;/h2&gt;

&lt;h2 id=&#34;lua的元表&#34;&gt;lua的元表&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://lua-users.org/wiki/MetamethodsTutorial&#34;&gt;http://lua-users.org/wiki/MetamethodsTutorial&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;元表用来扩展lua对象的功能，元表的含义在于生来就有，lua对象本身会带有这个表，所以称为元表&lt;/li&gt;
&lt;li&gt;metatable也是普通的lua table，包含一系列元方法metamethods，每个元方法有对应的events触发；比如&lt;a href=&#34;http://lua-users.org/wiki/MetatableEvents&#34;&gt;算术运算符、__index 等操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;__index&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://lua-users.org/wiki/MetatableEvents&#34;&gt;http://lua-users.org/wiki/MetatableEvents&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt; &lt;strong&gt;__index&lt;/strong&gt; - Control &amp;lsquo;prototype&amp;rsquo; inheritance. When accessing &amp;ldquo;myTable[key]&amp;rdquo; and the key does not appear in the table, but the metatable has an __index property:
&lt;ul&gt;
&lt;li&gt; if the value is a function, the function is called, passing in the table and the key; the return value of that function is returned as the result.
&lt;/li&gt;&lt;li&gt; if the value is another table, the value of the key in that table is asked for and returned
&lt;ul&gt;
&lt;li&gt; &lt;em&gt;(and if it doesn&amp;rsquo;t exist in &lt;strong&gt;that&lt;/strong&gt; table, but that table&amp;rsquo;s metatable has an __index property, then it continues on up)&lt;/em&gt;
&lt;/li&gt;&lt;/ul&gt;
&lt;/li&gt;&lt;li&gt; &lt;em&gt;Use &amp;ldquo;rawget(myTable,key)&amp;rdquo; to skip this metamethod.&lt;/em&gt;
&lt;/li&gt;&lt;/ul&gt;
&lt;/li&gt;&lt;/ul&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;控制类型继承；当访问myTable[key]，而table中没有key域时，如果元表有__index项：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果__index是函数，则调用该函数&lt;/li&gt;
&lt;li&gt;如果__index是table，返回这个table中key域的值；如果__index是table并且该table没有key域，但是该table有__index，则继续查找(calls fallback function or fallback table)&lt;/li&gt;
&lt;li&gt;使用rawget(myTable, key)可以跳过metatable&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;__index是一个应用广泛并用处很大的元方法metamethod&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果想获取table中的元素key，而key在table中没有找到，该方法可以定义为函数或者一个table，来寻找key。

&lt;ul&gt;
&lt;li&gt;如果__index是函数，该函数的第一个参数是没有找到key的这个table，第二个参数是key；&lt;/li&gt;
&lt;li&gt;如果__index是table，那么将在该table中寻找key，如果没有找到，可以继续从这个table的__index寻找，因此你可以通过__index进行一整个链条的查找。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;__metatable&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;用于隐藏metatable，当调用getmetatable(myTable)时，如果该域不为空，则返回这个域的值，而不是metatable
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://lua-users.org/wiki/LuaClassesWithMetatable&#34;&gt;sample code&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;lua面向对象&#34;&gt;Lua面向对象&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://dabing1022.github.io/2014/03/18/multiple-inheritance-understand-lua/&#34;&gt;http://dabing1022.github.io/2014/03/18/multiple-inheritance-understand-lua/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;lua源码精读&#34;&gt;Lua源码精读&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Lua的全局和状态，以及初始化

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/maximuszhou/article/details/46277695&#34;&gt;Lua的全局和状态&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;在调用lua_newstate 初始化Lua虚拟机时，会创建一个全局状态和一个线程（或称为调用栈），这个全局状态在整个虚拟机中是唯一的，供其他线程共享。一个Lua虚拟机中可以包括多个线程，这些线程共享一个全局状态，线程之间也可以调用lua_xmove函数来交换数据。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/ringofthec/archive/2010/11/09/lua_State.html&#34;&gt;LuaVM 初始化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://yq.aliyun.com/articles/1756?spm=5176.100240.searchblog.8.YbMjAK&#34;&gt;lua_State&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;lua与c的交互&#34;&gt;Lua与C的交互&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;* [深入理解Lua与C用于数据交互的栈](http://blog.csdn.net/maximuszhou/article/details/21331819)
* 为啥要通过 栈 来通信呢？
    * Lua是动态类型语言，在Lua语言中没有类型定义的语法，每个值都携带了它自身的类型信息，而C语言是静态类型语言
    * Lua使用垃圾收集，可以自动管理内存，而C语言要求程序自己释放分配的内存，需应用程序自身管理内存
* 压栈的影响
    * C将值压入栈中后，Lua将会生成相应类型的结构，存储和管理这个值
    * Lua不会持有指向VM外部的指针，指向的都是自己的结构和栈上的结构
    * 比如压入字符串，Lua生成Lua_TTSTRING类型的对象，C可以随意释放这个字符串
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://if-yu.info/lua-notes.html&#34;&gt;http://if-yu.info/lua-notes.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;list和nil&#34;&gt;list和nil&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;* https://techsingular.org/2012/12/22/programming-in-lua%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%8D-nil-%E5%92%8C-list/
* nil不但不是无的意思，反而在list中起到占位和有的意思。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;lua的first-class-https-techsingular-org-2012-12-22-programming-in-lua-ef-bc-88-e5-9b-9b-ef-bc-89-ef-bc-8d-nil-e5-92-8c-list&#34;&gt;&lt;a href=&#34;https://techsingular.org/2012/12/22/programming-in-lua%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%8D-nil-%E5%92%8C-list/&#34;&gt;lua的first class&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;可以被赋值给变量；&lt;/li&gt;
&lt;li&gt;可以作为参数；&lt;/li&gt;
&lt;li&gt;可以作为返回值；&lt;/li&gt;
&lt;li&gt;可以作为数据结构的构成部分。( 注意 nil 并不完全符合这个要求，但是可以通过某个 field 的缺失来表示 nil。)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;lua的gc&#34;&gt;Lua的GC&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;* lua的[gc](https://techsingular.org/2013/10/27/lua-%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;lua的table&#34;&gt;lua的table&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;* https://facepunch.com/showthread.php?t=1306348
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;I don&amp;rsquo;t believe this is correct. It was my understanding that Lua tables are implemented as a two-part data structure whereby dense non-negative integer keys are stored as a simple array and are therefore indexed by a simple pointer addition and dereference, which is O(1). All other keys (non-integer, negative and sparse integer) are stored in a hashmap as a chained scatter table which stores key-values pairs as a flat array indexed by the hash of the key. Collisions are resolved by storing pointers to the next element with the same hash alongside this (essentially a linked list of colliding elements). At worst case, where all elements collide, the complexity of this implementation is O(n), however it is expected that on average the number of collisions per element is 1 and the maximum is 2; this means that the average complexity is O(1).&lt;/p&gt;

&lt;p&gt;The implementation of Lua tables is such that, even with a huge number of elements, lookup is as quick as possible.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;lua函数使用&#34;&gt;lua函数使用&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;setmetatable&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.lua.org/manual/5.2/manual.html&#34;&gt;https://www.lua.org/manual/5.2/manual.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;setmetatable(table, metatable)

&lt;ul&gt;
&lt;li&gt;将metatable设置为table的元表，（在Lua中只能设置table的元表，其他类型的对象不行，除非使用C）。如果metatable为nil，则参数cable的元表被清除；如果该table的__metatable不为空，则抛出异常&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;该函数返回table&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;collectgarbage(&amp;ldquo;count&amp;rdquo;)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;垃圾回收函数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.lua.org/manual/5.2/manual.html#2.6&#34;&gt;lua yield 和 resume&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lua.org/manual/5.2/manual.html#pdf-coroutine.resume&#34;&gt;http://www.lua.org/manual/5.2/manual.html#pdf-coroutine.resume&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- http://my.oschina.net/wangxuanyihaha/blog/186401

function foo(a)
    print(&amp;quot;foo&amp;quot;, a)
    return coroutine.yield(2 * a)
end

co = coroutine.create(function ( a, b )
    print(&amp;quot;co-body&amp;quot;, a, b)
    local r = foo(a + 1)
    print(&amp;quot;co-body&amp;quot;, r)
    local r, s = coroutine.yield(a + b, a - b)
    print(&amp;quot;co-body&amp;quot;, r, s)
    return b, &amp;quot;end&amp;quot;
end)

print(&amp;quot;main&amp;quot;, coroutine.resume(co, 1, 10))
print(&amp;quot;main&amp;quot;, coroutine.resume(co, &amp;quot;m&amp;quot;))	-- resume的参数 &#39;m&#39; 是在调用yield传入的，所以本次是在第5行 return m
print(&amp;quot;main&amp;quot;, coroutine.resume(co, &amp;quot;x&amp;quot;, &amp;quot;y&amp;quot;))
print(&amp;quot;main&amp;quot;, coroutine.resume(co, &amp;quot;x&amp;quot;, &amp;quot;y&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;co-body	1	10
foo	2
main	true	4
co-body	m
main	true	11	-9
co-body	x	y
main	true	10	end
main	false	cannot resume dead coroutine
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;lua编码的陷阱&#34;&gt;lua编码的陷阱&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;* [字符串拼接导致垃圾产生](http://tech.uc.cn/?p=1131)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;golang&#34;&gt;golang&lt;/h2&gt;

&lt;h3 id=&#34;golang的并发-协程和channel&#34;&gt;golang的并发、协程和channel&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://ibillxia.github.io/blog/2014/03/16/go-concurrent-programming-first-try/&#34;&gt;golang并发编程初探&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;	for i := 0; i &amp;lt; 10; i++ {
		go func() {
			arr[i] = i + i*i
			chs[i] &amp;lt;- arr[i]
		}()
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类似于如上形式的for循环中启动go协程，在for循环结束时协程才会开执行，所以每个协程用到的i都是最大值10&lt;/p&gt;

&lt;p&gt;可以将i加入到协程的参数中，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;	for i := 0; i &amp;lt; 10; i++ {
		
		chs[i] = make(chan int)
		go func(i) {
			arr[i] = i + i*i
			chs[i] &amp;lt;- arr[i]
		}(i)
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以用局部变量保存i值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;	for i := 0; i &amp;lt; 10; i++ {
		i := i
		chs[i] = make(chan int)
		go func() {
			arr[i] = i + i*i
			chs[i] &amp;lt;- arr[i]
		}()
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://my.oschina.net/goal/blog/196891&#34;&gt;golang的底层数据结构&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://www.chenwang.net/2015/12/12/%E5%AE%8C%E6%95%B4%E7%9A%84golang-%E5%A4%9A%E5%8D%8F%E7%A8%8B%E4%BF%A1%E9%81%93-%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86%E7%A4%BA%E4%BE%8B/&#34;&gt;golang多协程channel同步&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;sync.WaitGroup&lt;/li&gt;
&lt;li&gt;defer&lt;/li&gt;
&lt;li&gt;recover&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/gophers/article/details/40505683&#34;&gt;golang闭包与协程使用&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;golang设计模式&#34;&gt;golang设计模式&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;* [单例模式](http://marcio.io/2015/07/singleton-pattern-in-go/)
* [golang map reduce](https://gist.github.com/mcastilho)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;golang接口&#34;&gt;golang接口&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;* https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/02.6.md
* http://xiaorui.cc/2016/03/11/%E5%85%B3%E4%BA%8Egolang-struct-interface%E7%9A%84%E7%90%86%E8%A7%A3%E4%BD%BF%E7%94%A8/
* http://blog.csdn.net/zhangzhebjut/article/details/24974315
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;UML图&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;实现关系、泛化关系、关联关系、聚合关系 &lt;a href=&#34;http://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html&#34;&gt;http://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;设计模式&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://tengj.top/2016/04/04/sjms3abstractfactory/&#34;&gt;http://tengj.top/2016/04/04/sjms3abstractfactory/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>resume</title>
      <link>https://bg2bkk.github.io/post/resume/</link>
      <pubDate>Fri, 22 Apr 2016 11:25:56 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/resume/</guid>
      <description>

&lt;h1 id=&#34;黄振栋简历&#34;&gt;黄振栋简历&lt;/h1&gt;

&lt;h2 id=&#34;联系方式&#34;&gt;联系方式&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Email：bg2bkk # gmail.com&lt;/li&gt;
&lt;li&gt;微博：&lt;a href=&#34;http://weibo.com/BG2BKK&#34;&gt;@bg2bkk&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;个人信息&#34;&gt;个人信息&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;男/1990&lt;/li&gt;
&lt;li&gt;硕士/哈工大深圳研究生院计算机系&lt;/li&gt;
&lt;li&gt;工作年限：14个月&lt;/li&gt;
&lt;li&gt;英语水平：CET-6&lt;/li&gt;
&lt;li&gt;技术博客：&lt;a href=&#34;http://bg2bkk.github.io&#34;&gt;http://bg2bkk.github.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Github：&lt;a href=&#34;http://github.com/bg2bkk&#34;&gt;http://github.com/bg2bkk&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;教育背景&#34;&gt;教育背景&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;- 2012.09 ~ 2015.01 哈尔滨工业大学 计算机 硕士
- 2008.09 ~ 2012.06 哈尔滨工程大学 计算机 学士 
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;技能清单&#34;&gt;技能清单&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;c/ lua/ python/ golang/ shell/ vhdl&lt;/li&gt;
&lt;li&gt;nginx/ ngx_lua/ redis&lt;/li&gt;
&lt;li&gt;linux kernel/ performance profiling&lt;/li&gt;
&lt;li&gt;算法、数据结构和设计模式&lt;/li&gt;
&lt;li&gt;linux系统编程、多线程编程、网络编程&lt;/li&gt;
&lt;li&gt;embedded system &amp;amp;&amp;amp; IOT: ble/mqtt/elua&lt;/li&gt;
&lt;li&gt;microprocessor: stm32 51 avr FPGA&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;自我评价&#34;&gt;自我评价&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;热爱计算机，热爱编程，热爱程序员这个工作&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;工作经历&#34;&gt;工作经历&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;- 2015.01 ~ NOW      新浪微博   系统开发工程师 
- 2013.09 ~ 2014.05  极光推送   后台开发实习生 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;项目经历&#34;&gt;项目经历&lt;/h2&gt;

&lt;h4 id=&#34;新浪微博-系统开发工程师-2015年1月-2016年8月&#34;&gt;新浪微博 系统开发工程师 （ 2015年1月 ~ 2016年8月 ）&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;微博防抓站系统&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;手机微博、PC微博以及Wap版微博的防抓站系统

&lt;ul&gt;
&lt;li&gt;微博访问量日益增长，恶意抓站同时增多&lt;/li&gt;
&lt;li&gt;封禁非法访问的IP，阻止恶意抓站&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;防抓站系统的松耦合架构

&lt;ul&gt;
&lt;li&gt;管理节点

&lt;ul&gt;
&lt;li&gt;ngx_lua开发&lt;/li&gt;
&lt;li&gt;管理节点提供提交封禁IP、解禁IP、白名单等接口，微博安全组分析得出恶意IP向管理节点提交&lt;/li&gt;
&lt;li&gt;管理节点将封禁IP等信息写入redis中&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;封禁节点

&lt;ul&gt;
&lt;li&gt;ngx_lua开发&lt;/li&gt;
&lt;li&gt;封禁节点的nginx worker启动定时任务，定期从远程redis拉取新的封禁信息，并将获取到的封禁IP加入到ngx_lua的shared dict共享内存中&lt;/li&gt;
&lt;li&gt;封禁模块工作在nginx的access阶段，获取用户请求的IP，从shared dict查询是否是封禁IP，如果是，则返回403终止用户访问，否则放行&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;可靠性

&lt;ul&gt;
&lt;li&gt;对于nginx的定时任务，由于脱离worker主进程，所以即使出错，不影响原有nginx业务&lt;/li&gt;
&lt;li&gt;对于封禁模块，采用lua的类try-catch机制的xpcall方法，保证即使access阶段的lua代码出错时，会将用户请求放行，所以最坏情况下是不封禁所有IP&lt;/li&gt;
&lt;li&gt;日志监控，监控定时任务执行，实时报警；收集封禁数据，统计IP拦截量&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;运行情况

&lt;ul&gt;
&lt;li&gt;封禁模块嵌入在微博前端机的nginx中，承载全量访问&lt;/li&gt;
&lt;li&gt;封禁模块执行任务最轻，仅仅获取用户IP以及查询nginx的shm，用时低于1ms&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;手机微博七层动态调度系统dygateway&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;动态调度系统&lt;strong&gt;&lt;em&gt;dygateway&lt;/em&gt;&lt;/strong&gt; 在手机微博7层实现

&lt;ul&gt;
&lt;li&gt;系统资源的动态伸缩&lt;/li&gt;
&lt;li&gt;用户请求的动态分流&lt;/li&gt;
&lt;li&gt;产品服务的灰度发布&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;dygateway作为7层服务时：

&lt;ul&gt;
&lt;li&gt;动态分流子系统 &lt;a href=&#34;https://github.com/CNSRE/ABTestingGateway&#34;&gt;ABTestingGateway&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;根据用户请求的特征和分流策略将请求转发至不同的后端upstream；&lt;/li&gt;
&lt;li&gt;动态设置分流策略，实时生效；&lt;/li&gt;
&lt;li&gt;支持单级分流和多级分流。&lt;/li&gt;
&lt;li&gt;基于ngx_lua 和 redis 开发&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;动态upstream模块&lt;a href=&#34;https://github.com/CNSRE/lua-upstream-nginx-module&#34;&gt;lua-upstream-nginx-module&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;该模块可以实时修改nginx的upstream列表，增减upstream，增减upstream中的member成员，实现动态伸缩。&lt;/li&gt;
&lt;li&gt;nginx模块开发&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;目前应用于手机微博、微博头条等产品线&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!--
修改nginx内部的upstream模块，在高并发压力下性能不下降，实时动态分流
灰度子系统在对用户请求做一定处理，比如添加uri参数、header头部等后，再转发至目标后端。可以动态设置分流策略，实时生效，无需重启
--&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;手机微博 HTTP DNS 服务端开发

&lt;ul&gt;
&lt;li&gt;手机微博httpdns项目用于解决客户端恶意劫持的问题，并能够实现节点的智能调度。&lt;/li&gt;
&lt;li&gt;一期：nginx + edns server松耦合实现

&lt;ul&gt;
&lt;li&gt;参与开发nginx的http dns模块&lt;/li&gt;
&lt;li&gt;对项目进行压测和评估，目前已灰度上线&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;二期：golang + edns查询

&lt;ul&gt;
&lt;li&gt;参与golang server的架构设计及系统开发&lt;/li&gt;
&lt;li&gt;开发golang 版本的edns查询模块和并发更新模块

&lt;ul&gt;
&lt;li&gt;全量并发更新域名对应IP的DNS记录，每个域名对应26万段IP，更新时间低于3分钟&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;httpdns server端一期已上线，手机微博客户端采用渠道包灰度；二期已完成edns查询模块。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;极光推送-jpush-cn-后台开发实习生-2013年9月-2014年5月&#34;&gt;极光推送(jpush.cn) 后台开发实习生（ 2013年9月 ~ 2014年5月 ）&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;大规模用户模拟系统&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;实习项目，该系统是极光推送后台系统中用于功能和负载测试的子系统，通过模拟真实用户的功能，保持大规模用户在线，统计模拟用户的运行数据，以测试推送系统的推送速度、负载强度和其他情况。&lt;/li&gt;
&lt;li&gt;在mentor指导下独立完成。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;经过系统设计、功能实现、压力测试及系统调优，单机可实现最高200万TCP长连接，线上运行时单机模拟50万用户，长期稳定运行。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;linux cpp tcp epoll 多线程及线程间通信&lt;/li&gt;
&lt;li&gt;单进程epoll和非阻塞IO实现高并发&lt;/li&gt;
&lt;li&gt;多线程分别实现配置上传下发模块、统计模块、上报模块和心跳模块&lt;/li&gt;
&lt;li&gt;tornado实现管理界面和监控界面&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;项目-演讲和讲义&#34;&gt;项目 演讲和讲义&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/WEIBOMSRE/ABTestingGateway&#34;&gt;ABTestingGateway&lt;/a&gt;：手机微博七层动态调度系统中关于灰度发布和动态分流的子项目，780+ stars。&lt;/li&gt;
&lt;li&gt;2015年OSC源创会运维专场：&lt;a href=&#34;https://github.com/WEIBOMSRE/ABTestingGateway/blob/master/doc/%E5%9F%BA%E4%BA%8E%E5%8A%A8%E6%80%81%E7%AD%96%E7%95%A5%E7%9A%84%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83%E7%B3%BB%E7%BB%9F.pdf&#34;&gt;基于动态策略的灰度发布系统&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;兴趣点&#34;&gt;兴趣点&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;兴趣广泛，从Linux服务端开发到安卓开发，从单片机开发到FPGA开发，从kernel源码到lua源码，我都有兴趣:)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对所使用的软件或服务，愿意并有能力进行深入理解，从设计思路到源码实现着手&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;TCP/ DNS/ HTTP&lt;/li&gt;
&lt;li&gt;Linux/ Nginx/ Redis/ Lua/&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对动态追踪和性能优化尤其有兴趣&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;linux/nginx的配置参数调优&lt;/li&gt;
&lt;li&gt;通过perf或者systemtap分析性能瓶颈&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Linux kernel&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;tcp/ip stack&lt;/li&gt;
&lt;li&gt;epoll&lt;/li&gt;
&lt;li&gt;memory management&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;个人项目&#34;&gt;个人项目&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/BG2BKK/smarthome&#34;&gt;smarthome&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;基于ESP8266单片机的家庭环境参数监测模块，目前支持温度、湿度、PM2.5等参数&lt;/li&gt;
&lt;li&gt;通过wifi上传监测参数和心跳到远程server&lt;/li&gt;
&lt;li&gt;通过mqtt进行远程推送和远程控制&lt;/li&gt;
&lt;li&gt;server端采用nginx+nodejs+redis实现&lt;/li&gt;
&lt;li&gt;使用nginx的rtmp模块实现实时视频监控&lt;/li&gt;
&lt;li&gt;TODO LIST

&lt;ul&gt;
&lt;li&gt;opencv抓取关键帧上报&lt;/li&gt;
&lt;li&gt;android app简易开发&lt;/li&gt;
&lt;li&gt;使用dart 甲醛传感器监测室内甲醛气体&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/BG2BKK/MyDict&#34;&gt;MyDict&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一个离线词典&lt;/li&gt;
&lt;li&gt;原作者采用trie树对离线词库生成索引，我采用三向单词查找树(Ternary search tries TSTs)实现&lt;/li&gt;
&lt;li&gt;数据结构解决实际问题，体现程序员的价值&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/BG2BKK/NFA_by_Python&#34;&gt;NFA_By_Python&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;《计算理论》专业课作业，内容是将使用NFA解析正则表达式，并将其可视化。&lt;/li&gt;
&lt;li&gt;python分析正则表达式，自动生成dot代码，通过graphviz画图并生成pdf&lt;/li&gt;
&lt;li&gt;这恐怕是我离计算机科学最近的一次了:)&lt;/li&gt;
&lt;li&gt;其实想想，计算理论还是非常有趣的，而我也无比热爱这门科学&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/BG2BKK/img_process_vhdl&#34;&gt;img_process_vhdl&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;纯VHDL写的通用图像处理框架，在FPGA进行图像卷积运算，进而可以实现滤波、开闭等操作&lt;/li&gt;
&lt;li&gt;考虑到github上好像逻辑工程师不多，我就不写README了。&lt;/li&gt;
&lt;li&gt;以后再也不碰FPGA了，VHDL这种逻辑语言其实没必要人肉来写&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>DNS with golang</title>
      <link>https://bg2bkk.github.io/post/DNS%20with%20golang/</link>
      <pubDate>Wed, 13 Apr 2016 11:37:24 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/DNS%20with%20golang/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/cobbliu/archive/2013/04/02/2996333.html&#34;&gt;DNS消息格式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/cobbliu/p/3188632.html&#34;&gt;EDNS详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc6891&#34;&gt;rfc6891&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ietf.org/id/draft-ietf-dnsop-edns-client-subnet-08.txt&#34;&gt;edns_client_subnet draft&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://noops.me/?p=653&#34;&gt;小米的ends实践&lt;/a&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;6. respond时也需要增加一个Additional RRs区域，直接把请求的Additional内容发过去就可以(如果支持source netmask，将请求中的source netmask复制到scope netmask中，OpenDNS要求必须支持scope netmask)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;* 意思是非OpenDNS就可以不支持scope netmask吗？目前新浪的仍然不支持
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/miekg/dns&#34;&gt;miekg/dns: golang lib&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;dig with edns&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.gsic.uva.es/~jnisigl/dig-edns-client-subnet.html&#34;&gt;https://www.gsic.uva.es/~jnisigl/dig-edns-client-subnet.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://xmodulo.com/geographic-location-ip-address-command-line.html&#34;&gt;http://xmodulo.com/geographic-location-ip-address-command-line.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;在线查询：curl ipinfo.io/23.66.166.151&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;DNS报文格式&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;IP packet

&lt;ul&gt;
&lt;li&gt;IP Header 20 bytes&lt;/li&gt;
&lt;li&gt;IP Data: UDP

&lt;ul&gt;
&lt;li&gt;UDP Header 8 bytes&lt;/li&gt;
&lt;li&gt;UDP Data: DNS

&lt;ul&gt;
&lt;li&gt;DNS Header 12 bytes&lt;/li&gt;
&lt;li&gt;DNS Data: RR

&lt;ul&gt;
&lt;li&gt;RR: Question[]&lt;/li&gt;
&lt;li&gt;RR: Answer[]&lt;/li&gt;
&lt;li&gt;RR: Authority[]&lt;/li&gt;
&lt;li&gt;RR: Additional[]&lt;/li&gt;
&lt;li&gt;RR

&lt;ul&gt;
&lt;li&gt;QName&lt;/li&gt;
&lt;li&gt;QType&lt;/li&gt;
&lt;li&gt;QClass&lt;/li&gt;
&lt;li&gt;RDLENGTH&lt;/li&gt;
&lt;li&gt;RDATA&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;RR OPT

&lt;ul&gt;
&lt;li&gt;QName null&lt;/li&gt;
&lt;li&gt;QType OPT=41&lt;/li&gt;
&lt;li&gt;QClass = UDP payload 2bytes&lt;/li&gt;
&lt;li&gt;TTL = Extended-RCODE 1byte: extend + VERSION 1byte: 0 + Z 2bytes: 0&lt;/li&gt;
&lt;li&gt;RDLen len of data(OPT)&lt;/li&gt;
&lt;li&gt;OPT

&lt;ul&gt;
&lt;li&gt;Option-Code 2bytes: EDNS0_SUBNET&lt;/li&gt;
&lt;li&gt;Option-Length 2bytes&lt;/li&gt;
&lt;li&gt;Option-Data&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;Family 1byte: IPV4(1)&lt;/li&gt;
&lt;li&gt;Source Netmask 1byte: 32&lt;/li&gt;
&lt;li&gt;Scope Netmask 1byte: 0&lt;/li&gt;
&lt;li&gt;Client Subnet 4bytes: 65.135.152.203
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;我们总是在追一些时髦的技术，而不顾基础还不牢靠&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;我们总是看见新的框架，然而框架本质上仍然是那些东西，mvc，cs&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- http://www.tcpipguide.com/free/index.htm --&gt;

&lt;style type=&#34;text/css&#34;&gt;
div.t-h:hover &gt; div {display:block;}
.t-m-s {font-size:80%;border: 2px solid #ccc;border-spacing:0;border-collapse:collapse;}
.g-h-s {background:#9bf;color:#339;padding:4px; font-size:80%;font-weight:normal;border:1px solid #ccc;}
&lt;/style&gt;

&lt;table class=&#34;t-m-s&#34;&gt;
&lt;div align=&#34;center&#34;&gt;&lt;table border=&#34;3&#34; cellpadding=&#34;4&#34; cellspacing=&#34;2&#34;&gt;&lt;caption align=&#34;top&#34;&gt;&lt;p align=&#34;center&#34;&gt;&lt;font face=&#34;Arial&#34;&gt;&lt;b&gt;TCP Message Format &lt;/b&gt;&lt;/font&gt;&lt;/p&gt;&lt;/caption&gt;
&lt;tbody&gt;&lt;tr class=&#34;g-h-s&#34;&gt;
&lt;td&gt;Octet&lt;/td&gt;
&lt;td&gt;Bits&lt;/td&gt;
&lt;td&gt;Len&lt;/td&gt;
&lt;td&gt;Name&lt;/td&gt;
&lt;td&gt;Notes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0-1&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;Source port&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2-3&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;Destination Port&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4-7&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;Sequence number&lt;/td&gt;
&lt;td&gt;position of last octet we sent.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8-11&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;Acknowledge Number&lt;/td&gt;
&lt;td&gt;Next octet number we expect from the peer.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;0-3&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;HLEN&lt;/td&gt;
&lt;td&gt;4 bits. The number of 32 bit multiples (4 octets) in the TCP header including any &#39;options&#39; fields.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;4-7&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;Reserved&lt;/td&gt;
&lt;td&gt;should be zero&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;Code bits&lt;/td&gt;
&lt;td&gt;8 bits (6 used) valid if 1&lt;br&gt;
bit 0 (URG) Urgent&lt;br&gt;
bit 1 (ACK) Acknowledgement&lt;br&gt;
bit 2 (PSH) Requests PUSH&lt;br&gt;
bit 3 (RST) Reset connection&lt;br&gt;
bit 4 (SYN) Sync sequence numbers&lt;br&gt;
bit 5 (FIN) sender finished&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;14-15&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;Window&lt;/td&gt;
&lt;td&gt;Specifies the amount of data we can accept.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;16-17&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;Checksum&lt;/td&gt;
&lt;td&gt;Standard IP checksum. Includes a &lt;a href=&#34;#tcp-check&#34; class=&#34;t-db&#34;&gt;TCP pseudo header&lt;/a&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;18-19&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;Urgent pointer&lt;/td&gt;
&lt;td&gt;Points to end of urgent data.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;t-c&#34;&gt;
&lt;td colspan=&#34;5&#34;&gt;&lt;a href=&#34;#tcp_opts&#34; class=&#34;t-db&#34;&gt;TCP Options&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;t-c&#34;&gt;
&lt;td colspan=&#34;5&#34;&gt;TCP data&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/div&gt;
&lt;/table&gt;
</description>
    </item>
    
  </channel>
</rss>