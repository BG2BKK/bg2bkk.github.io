<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>BG2BKK Site</title>
    <link>https://bg2bkk.github.io/</link>
    <description>Recent content on BG2BKK Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 26 May 2016 01:39:59 +0800</lastBuildDate>
    <atom:link href="https://bg2bkk.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>一道多线程面试题</title>
      <link>https://bg2bkk.github.io/post/%E4%B8%80%E9%81%93%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Thu, 26 May 2016 01:39:59 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/%E4%B8%80%E9%81%93%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>

&lt;p&gt;最近突然看协程和并发编程比较多，遇到这样&lt;a href=&#34;http://blog.csdn.net/liuxuejiang158blog/article/details/21977009&#34;&gt;一道题&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;题目：子线程循环 10 次，接着主线程循环 100 次，接着又回到子线程循环 10 次，接着再回到主线程又循环 100 次，如此循环50次，试写出代码。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;参考文档里的代码采用C++11编写，而我，很不幸的，看不懂。&lt;/p&gt;

&lt;p&gt;我想我的cpp已经退化到看不见了吧，然后c++11我更加看不懂了，甚至连cpp较为官方的&lt;a href=&#34;http://en.cppreference.com/w/cpp/thread/condition_variable&#34;&gt;文档都开始采用c++11了&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;虽然我不会c++11，但是我会lua、c、golang、python、shell，我要报复性的把这个题做了。&lt;/p&gt;

&lt;h2 id=&#34;c-11:2b47536402331bf9a7545f76ebbbb760&#34;&gt;C++11&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;thread&amp;gt;
#include&amp;lt;mutex&amp;gt;
#include&amp;lt;condition_variable&amp;gt;
using namespace std;
mutex m;
condition_variable cond;
int flag=10;
void fun(int num){
    for(int i=0;i&amp;lt;2;i++){
        unique_lock&amp;lt;mutex&amp;gt; lk(m);//A unique lock is an object that manages a mutex object with unique ownership in both states: locked and unlocked.
        while(flag!=num)
            cond.wait(lk);//在调用wait时会执行lk.unlock()
        for(int j=0;j&amp;lt;num;j++)
            cout&amp;lt;&amp;lt;j&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
        cout&amp;lt;&amp;lt;endl;
        flag=(num==10)?100:10;
        cond.notify_one();//被阻塞的线程唤醒后lk.lock()恢复在调用wait前的状态
    }
}
int main(){
    thread child(fun,10);
    fun(100);
    child.join();
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;lua:2b47536402331bf9a7545f76ebbbb760&#34;&gt;Lua&lt;/h2&gt;

&lt;p&gt;lua的协程使得主从两个thread之间并没有竞争关系，所以很顺畅的就可以把代码写出来，逻辑也十分简单&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local thread = coroutine.create(function() 
	for cnt = 1, 5 do
		local tmp = {}
		for i = 1, 10 do
			table.insert(tmp, i)
		end
		print(&#39;child: &#39;, table.concat(tmp, &#39; &#39;))
		coroutine.yield()

		local tmp = {}
		for i = 1, 10 do
			table.insert(tmp, i)
		end
		print(&#39;child: &#39;, table.concat(tmp, &#39; &#39;))
		coroutine.yield()
	end

end)


for i=1, 5 do
	coroutine.resume(thread)
	local tmp = {}
	for i = 1, 100 do
		table.insert(tmp, i)
	end
	print(&#39;main: &#39;, table.concat(tmp, &#39; &#39;))

	print(&#39;------------------------------------&#39;)

	coroutine.resume(thread)

	local tmp = {}
	for i = 1, 100 do
		table.insert(tmp, i)
	end
	print(&#39;main: &#39;, table.concat(tmp, &#39; &#39;))

	print(&#39;====================================&#39;)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
child: 	1 2 3 4 5 6 7 8 9 10
main: 	1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100
------------------------------------
child: 	1 2 3 4 5 6 7 8 9 10
main: 	1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100
====================================
child: 	1 2 3 4 5 6 7 8 9 10
main: 	1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100
------------------------------------
child: 	1 2 3 4 5 6 7 8 9 10
main: 	1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100
====================================
child: 	1 2 3 4 5 6 7 8 9 10
main: 	1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100
------------------------------------
child: 	1 2 3 4 5 6 7 8 9 10
main: 	1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100
====================================
child: 	1 2 3 4 5 6 7 8 9 10
main: 	1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100
------------------------------------
child: 	1 2 3 4 5 6 7 8 9 10
main: 	1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100
====================================
child: 	1 2 3 4 5 6 7 8 9 10
main: 	1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100
------------------------------------
child: 	1 2 3 4 5 6 7 8 9 10
main: 	1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100
====================================

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;c:2b47536402331bf9a7545f76ebbbb760&#34;&gt;c&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;volatile: 使用volatile类型的全局变量和sleep函数实现阻塞和互斥&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;pthread.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;ctype.h&amp;gt;

volatile int cond = 0;

void func(int n)
{
	int i = 0, j = 0;
	for(j=0; j&amp;lt;5; j++){
		while(cond != 0)
			sleep(1);
		printf(&amp;quot;\n----------------------------------\n&amp;quot;);
		printf(&amp;quot;child: &amp;quot;);
		for(i=0; i &amp;lt; 10; i++ )
			printf(&amp;quot;%d\t&amp;quot;, i);
		printf(&amp;quot;\n&amp;quot;);
		cond = 1;
	}
}

int main()
{
	pthread_t tid;
	int s = pthread_create(&amp;amp;tid, NULL, func, 10);
	if(s != 0){
		printf(&amp;quot;pthread_create error for %s&amp;quot;, strerror(errno));
		exit(1);
	}

	int i = 0, j = 0;
	for(j=0; j &amp;lt; 5; j++){
		while(cond != 1)
			sleep(1);
		printf(&amp;quot;master: &amp;quot;);
		for(i=0; i &amp;lt; 100; i++ )
			printf(&amp;quot;%d\t&amp;quot;, i);
		printf(&amp;quot;\n&amp;quot;);
		printf(&amp;quot;==================================\n&amp;quot;);
		cond = 0;
	}

	s = pthread_join(tid, NULL);
	if(s != 0){
		printf(&amp;quot;pthread_join error for %s&amp;quot;, strerror(errno));
		exit(1);
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;signal: 使用信号，用于进程互相通知对方&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;semop: 使用System V　进行线程同步，控制并发访问&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;pthread.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;ctype.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;

#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/ipc.h&amp;gt;
#include &amp;lt;sys/sem.h&amp;gt;

volatile int cond = 0;
int semid;
struct sembuf sem[2];

void func(int n)
{

//	printf(&amp;quot;ppid = %d, getpid = %d\n&amp;quot;, getppid(), getpid());

	int i = 0, j = 0;
	for(j=0; j&amp;lt;5; j++){

		sem[1].sem_num = 1;
		sem[1].sem_op = -1;
		sem[1].sem_flg = 0;
		semop(semid, &amp;amp;sem[1], 1);

		printf(&amp;quot;\n----------------------------------\n&amp;quot;);
		printf(&amp;quot;child: &amp;quot;);
		for(i=0; i &amp;lt; 10; i++ )
			printf(&amp;quot;%d\t&amp;quot;, i);
		printf(&amp;quot;\n&amp;quot;);

		sem[0].sem_num = 0;
		sem[0].sem_op = 1;
		sem[0].sem_flg = 0;
		semop(semid, &amp;amp;sem[0], 1);
	}
}

int main()
{
	semid = semget(IPC_PRIVATE, 2, 0666| IPC_CREAT);
	if(semid &amp;lt; 0){
		printf(&amp;quot;semget error for %s&amp;quot;, strerror(errno));
		exit(1);
	}

	pthread_t tid;
	int s = pthread_create(&amp;amp;tid, NULL, func, getpid());
	if(s != 0){
		printf(&amp;quot;pthread_create error for %s&amp;quot;, strerror(errno));
		exit(1);
	}

	int i = 0, j = 0;
	for(j=0; j &amp;lt; 5; j++){

		sem[0].sem_num = 0;
		sem[0].sem_op = -1;
		sem[0].sem_flg = 0;
		sem[1].sem_num = 1;
		sem[1].sem_op = 1;
		sem[1].sem_flg = 0;

		semop(semid, &amp;amp;sem[1], 1);
		semop(semid, &amp;amp;sem[0], 1);

		printf(&amp;quot;master: &amp;quot;);
		for(i=0; i &amp;lt; 100; i++ )
			printf(&amp;quot;%d\t&amp;quot;, i);
		printf(&amp;quot;\n&amp;quot;);
		printf(&amp;quot;==================================\n&amp;quot;);

		sem[1].sem_num = 1;
		sem[1].sem_op = 1;
		sem[1].sem_flg = 0;
	}

	s = pthread_join(tid, NULL);
	if(s != 0){
		printf(&amp;quot;pthread_join error for %s&amp;quot;, strerror(errno));
		exit(1);
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;python:2b47536402331bf9a7545f76ebbbb760&#34;&gt;python&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;python yield&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;golang:2b47536402331bf9a7545f76ebbbb760&#34;&gt;golang&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;goroutine&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;shell:2b47536402331bf9a7545f76ebbbb760&#34;&gt;shell&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;token bucket&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>SO_REUSEADDR和SO_REUSEPORT</title>
      <link>https://bg2bkk.github.io/post/SO_REUSEADDR%E5%92%8CSO_REUSEPORT/</link>
      <pubDate>Mon, 09 May 2016 16:55:42 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/SO_REUSEADDR%E5%92%8CSO_REUSEPORT/</guid>
      <description>

&lt;h2 id=&#34;结论:035fb573c14692e64241442f4294aac6&#34;&gt;结论&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;1. SO_REUSEPORT用于多个socket监听同一个TCP链接
2. SO_REUSEADDR可用于多个进程bind同一端口，但需要TCP连接的四元组不一样。
3. SO_REUSEPORT比SO_REUSEADDR更加扩展，但是也带来了隐患，需要额外注意
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;引言:035fb573c14692e64241442f4294aac6&#34;&gt;引言&lt;/h2&gt;

&lt;p&gt;nginx 1.9.1引入了 SO_REUSEPORT选项，在高版本（linux kernel 3.9以上）系统上可用。该选项允许多个socket监听同一个IP:PORT组合，&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SO_REUSEPORT可以&lt;a href=&#34;http://freeprogrammersblog.vhex.net/post/linux-39-introdued-new-way-of-writing-socket-servers/2&#34;&gt;简化服务器编程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;prefork模式：master预先分配进程池，每一个client连接用一个进程处理

&lt;ul&gt;
&lt;li&gt;省资源，不用每次都fork，然后再回收&lt;/li&gt;
&lt;li&gt;可控制，预先分配的进程池大小是固定的&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;SO_REUSEPORT使得多进程时不用使master再做管理工作，比如管理子进程，设置信号等等，设置不需要一个master进程，只需要子进程监听同一个端口就行。操作系统做了大部分工作。

&lt;ul&gt;
&lt;li&gt;这里还有个好处是，C写的server模块，python写的server模块，它们可以共存监听同一个端口，灵活性更好&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;听听linux-kernle-维护者怎么说-https-lwn-net-articles-542629:035fb573c14692e64241442f4294aac6&#34;&gt;听听linux kernle&lt;a href=&#34;https://lwn.net/Articles/542629/&#34;&gt;维护者怎么说&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;允许多个进程绑定host上的同一端口&lt;/li&gt;
&lt;li&gt;只需要第一个绑定端口的进程指定SO_REUSEPORT选项，后继者都可以绑定该端口，所以需要担心的是端口劫持，不希望恶意程序能accept该端口的连接。&lt;/li&gt;
&lt;li&gt;方法是后继者要与第一次绑定端口的进程的USER ID一样，比如用root和普通用户启动程序绑定同一个端口，会报address already in use&lt;/li&gt;
&lt;li&gt;SO_REUSEPORT的负载均衡性能更好
&lt;!--        * 这里的负载均衡可能指的不是主动分配的，而是当多个线程监听同一端口时，如果某个线程在忙，那么新来的请求自然会被load较低的线程处理，间接的达到均衡效果 --&gt;&lt;/li&gt;
&lt;li&gt;TCP和UDP都可以用

&lt;ul&gt;
&lt;li&gt;UDP场景中，在DNS server的应用比较有意义，可以负载均衡的处理dns请求&lt;/li&gt;
&lt;li&gt;作者指出，SO_REUSEADDR虽然也能让UDP连接绑定同一端口，但是SO_REUSEPORT可以防止劫持，并能将请求均衡的分配给监听的线程&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;传统多线程的工作模式的缺点:035fb573c14692e64241442f4294aac6&#34;&gt;传统多线程的工作模式的缺点&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;1. 传统的多线程server都是有一个listener线程绑定端口并接受所有的请求，然后传递给其他线程，而这个listener往往会成为瓶颈&lt;/li&gt;
&lt;li&gt;2. master绑定端口，每个slave轮流accept从该端口获取连接（nginx）

&lt;ul&gt;
&lt;li&gt;缺点是有可能导致每个slave不能平均的处理连接，unblanced；有的slave处理的过多，有的slave处理的过少，导致cpu资源不能充分利用&lt;/li&gt;
&lt;li&gt;SO_REUSEPORT的实现可以使请求平均的分配给堵塞在accept上的各个进程&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;so-reuseport的应用举例:035fb573c14692e64241442f4294aac6&#34;&gt;SO_REUSEPORT的应用举例&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;server.py&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import socket
import os

SO_REUSEPORT = 15

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.setsockopt(socket.SOL_SOCKET, SO_REUSEPORT, 1)
s.bind((&#39;&#39;, 10000))
s.listen(1)
while True:
    conn, addr = s.accept()
    print(&#39;Connected to {}&#39;.format(os.getpid()))
    data = conn.recv(1024)
    conn.send(data)
    conn.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动两个进程，都绑定10000端口；使用nc作为client&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ python server.py&amp;amp;
[1] 12649
$ python server.py&amp;amp;
[2] 12650
$ echo data | nc localhost 10000
Connected to 12649
data
$ echo data | nc localhost 10000
Connected to 12650
data
$ echo data | nc localhost 10000
Connected to 12649
data
$ echo data | nc localhost 10000
Connected to 12650
data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再启动一个新的进程显然也是可以的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ python server.py&amp;amp;
[3] 14021
$ echo data | nc localhost 10000
Connected to 12650
data
$ echo data | nc localhost 10000
Connected to 14021
data
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kavu/go_reuseport&#34;&gt;SO_REUSEPORT在golang中的实践&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;so-reuseport-和-so-reuseaddr-对比-待续:035fb573c14692e64241442f4294aac6&#34;&gt;SO_REUSEPORT 和 SO_REUSEADDR 对比（待续）&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;前者可以防止端口被恶意进程劫持&lt;/li&gt;
&lt;li&gt;前者可以使请求平均分配给各个进程&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考链接:035fb573c14692e64241442f4294aac6&#34;&gt;参考链接&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://lwn.net/Articles/542629/&#34;&gt;lwn: the SO_REUSEPORT socket option&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/14388706/socket-options-so-reuseaddr-and-so-reuseport-how-do-they-differ-do-they-mean-t&#34;&gt;topic on so_reuseaddr and so_reuseport on stackoverflow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>tcp_fast_open的概念 作用以及实现</title>
      <link>https://bg2bkk.github.io/post/tcp_fast_open%E7%9A%84%E6%A6%82%E5%BF%B5%20%E4%BD%9C%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Mon, 09 May 2016 15:53:34 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/tcp_fast_open%E7%9A%84%E6%A6%82%E5%BF%B5%20%E4%BD%9C%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%AE%9E%E7%8E%B0/</guid>
      <description>

&lt;h2 id=&#34;引言:dcfa70d5873a9471dad227ae4d6ecbe0&#34;&gt;引言&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;三次握手的过程中，当用户首次访问server时，发送syn包，server根据用户IP生成cookie，并与syn+ack一同发回client；client再次访问server时，在syn包携带TCP cookie；如果server校验合法，则在用户回复ack前就可以直接发送数据；否则按照正常三次握手进行。&lt;/p&gt;

&lt;p&gt;TFO提高性能的关键是省去了热请求的三次握手，这在充斥着小对象的移动应用场景中能够极大提升性能。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Google研究发现TCP 二次握手是页面延迟时间的重要部分，所以提出TFO&lt;/p&gt;

&lt;p&gt;TFO的fast open标志体现在TCP报文的头部的&lt;a href=&#34;http://www.iana.org/assignments/tcp-parameters/tcp-parameters.xhtml&#34;&gt;OPTION字段&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;TCP Fast Open的标准文档是&lt;a href=&#34;http://tools.ietf.org/html/rfc7413&#34;&gt;rfc7413&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;TFO与2.6.34内核合并到主线，&lt;a href=&#34;https://lwn.net/Articles/508865/&#34;&gt;lwn通告地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;TFO的使用目前还是有些复杂的，从&lt;a href=&#34;https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt&#34;&gt;linux的network文档来看&lt;/a&gt;：&lt;/p&gt;

&lt;p&gt;TFO的配置说明：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;tcp_fastopen - INTEGER
	Enable TCP Fast Open feature (draft-ietf-tcpm-fastopen) to send data
	in the opening SYN packet. To use this feature, the client application
	must use sendmsg() or sendto() with MSG_FASTOPEN flag rather than
	connect() to perform a TCP handshake automatically.

	The values (bitmap) are
	1: Enables sending data in the opening SYN on the client w/ MSG_FASTOPEN.
	2: Enables TCP Fast Open on the server side, i.e., allowing data in
	   a SYN packet to be accepted and passed to the application before
	   3-way hand shake finishes.
	4: Send data in the opening SYN regardless of cookie availability and
	   without a cookie option.
	0x100: Accept SYN data w/o validating the cookie.
	0x200: Accept data-in-SYN w/o any cookie option present.
	0x400/0x800: Enable Fast Open on all listeners regardless of the
	   TCP_FASTOPEN socket option. The two different flags designate two
	   different ways of setting max_qlen without the TCP_FASTOPEN socket
	   option.

	Default: 1

	Note that the client &amp;amp; server side Fast Open flags (1 and 2
	respectively) must be also enabled before the rest of flags can take
	effect.

	See include/net/tcp.h and the code for more details.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了启用 tcp fast open功能&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- client需要使用sendmsg或者sento系统调用，加上MSG_FASTOPEN flag，来连接server端，代替connect系统调用。
- 对server端不做要求。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;linux系统（高版本内核）默认tcp_fastopen为1：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sysctl -a | grep fastopen

net.ipv4.tcp_fastopen = 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试代码： server.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// reference: http://blog.csdn.net/hanhuili/article/details/8540227

#include &amp;lt;string.h&amp;gt;         
#include &amp;lt;sys/types.h&amp;gt; /* See NOTES */
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
int main(){
    int portno = 6666;
    socklen_t clilen;
    char buffer[256];
    struct sockaddr_in serv_addr, cli_addr;
    int cfd;
    int sfd = socket(AF_INET, SOCK_STREAM, 0);   // Create socket
    
    bzero((char *) &amp;amp;serv_addr, sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = INADDR_ANY;
    serv_addr.sin_port = htons(portno);
    bind(sfd, &amp;amp;serv_addr,sizeof(serv_addr));      // Bind to well known address
    
    int qlen = 5;                 // Value to be chosen by application
    int err = setsockopt(sfd, IPPROTO_TCP/*SOL_TCP*/, 23/*TCP_FASTOPEN*/, &amp;amp;qlen, sizeof(qlen));
    
    listen(sfd,1);                // Mark socket to receive connections

	while(1){
		cfd = accept(sfd, NULL, 0);   // Accept connection on new socket

		while(1){
			int len = read(cfd,buffer,256);
			if(len)
				printf(&amp;quot;tcp fast open: %s\n&amp;quot;,buffer);
			else
				break;
			// read and write data on connected socket cfd
		}

		memset(buffer, 0, 256);
		close(cfd);
	}

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试代码：client.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
#include &amp;lt;netdb.h&amp;gt; 
#include &amp;lt;errno.h&amp;gt;
int main(){
    struct sockaddr_in serv_addr;
    struct hostent *server;

    char *data = &amp;quot;Hello, tcp fast open&amp;quot;;
    int data_len = strlen(data);    
    
    int sfd = socket(AF_INET, SOCK_STREAM, 0);
    server = gethostbyname(&amp;quot;localhost&amp;quot;);
    
    bzero((char *) &amp;amp;serv_addr, sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;
    bcopy((char *)server-&amp;gt;h_addr, 
         (char *)&amp;amp;serv_addr.sin_addr.s_addr,
         server-&amp;gt;h_length);
    serv_addr.sin_port = htons(6666);

// /usr/src/linux-headers-4.4.0-22/include/linux/socket.h:#define MSG_FASTOPEN	0x20000000	/* Send data in TCP SYN */

//  int len = sendto(sfd, data, data_len, 0x20000000/*MSG_FASTOPEN*/, 

    int len = sendto(sfd, data, data_len, MSG_FASTOPEN/*MSG_FASTOPEN*/, 
                (struct sockaddr *) &amp;amp;serv_addr, sizeof(serv_addr));
	if(errno != 0){
		printf(&amp;quot;error: %s\n&amp;quot;, strerror(errno));
	}
    close(sfd);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通信过程：tcpdump&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
$ sudo tcpdump -i any port 6666 -X

# 第一次 ./client.o

00:29:34.820187 IP localhost.51388 &amp;gt; localhost.6666: Flags [S], seq 755101042, win 43690, options [mss 65495,sackOK,TS val 17053 ecr 0,nop,wscale 7,unknown-34,nop,nop], length 0
	0x0000:  4500 0040 afef 4000 4006 8cc6 7f00 0001  E..@..@.@.......
	0x0010:  7f00 0001 c8bc 1a0a 2d01 ed72 0000 0000  ........-..r....
	0x0020:  b002 aaaa fe34 0000 0204 ffd7 0402 080a  .....4..........
	0x0030:  0000 429d 0000 0000 0103 0307 2202 0101  ..B.........&amp;quot;...
00:29:34.820284 IP localhost.6666 &amp;gt; localhost.51388: Flags [S.], seq 3725111481, ack 755101043, win 43690, options [mss 65495,sackOK,TS val 17053 ecr 17053,nop,wscale 7], length 0
	0x0000:  4500 003c 0000 4000 4006 3cba 7f00 0001  E..&amp;lt;..@.@.&amp;lt;.....
	0x0010:  7f00 0001 1a0a c8bc de08 b0b9 2d01 ed73  ............-..s
	0x0020:  a012 aaaa fe30 0000 0204 ffd7 0402 080a  .....0..........
	0x0030:  0000 429d 0000 429d 0103 0307            ..B...B.....
00:29:34.820372 IP localhost.51388 &amp;gt; localhost.6666: Flags [P.], seq 1:21, ack 1, win 342, options [nop,nop,TS val 17053 ecr 17053], length 20
	0x0000:  4500 0048 aff0 4000 4006 8cbd 7f00 0001  E..H..@.@.......
	0x0010:  7f00 0001 c8bc 1a0a 2d01 ed73 de08 b0ba  ........-..s....
	0x0020:  8018 0156 fe3c 0000 0101 080a 0000 429d  ...V.&amp;lt;........B.
	0x0030:  0000 429d 4865 6c6c 6f2c 2074 6370 2066  ..B.Hello,.tcp.f
	0x0040:  6173 7420 6f70 656e                      ast.open
00:29:34.820433 IP localhost.6666 &amp;gt; localhost.51388: Flags [.], ack 21, win 342, options [nop,nop,TS val 17053 ecr 17053], length 0
	0x0000:  4500 0034 f227 4000 4006 4a9a 7f00 0001  E..4.&#39;@.@.J.....
	0x0010:  7f00 0001 1a0a c8bc de08 b0ba 2d01 ed87  ............-...
	0x0020:  8010 0156 fe28 0000 0101 080a 0000 429d  ...V.(........B.
	0x0030:  0000 429d                                ..B.
00:29:34.859246 IP localhost.6666 &amp;gt; localhost.51388: Flags [.], ack 22, win 342, options [nop,nop,TS val 17063 ecr 17053], length 0
	0x0000:  4500 0034 f228 4000 4006 4a99 7f00 0001  E..4.(@.@.J.....
	0x0010:  7f00 0001 1a0a c8bc de08 b0ba 2d01 ed88  ............-...
	0x0020:  8010 0156 fe28 0000 0101 080a 0000 42a7  ...V.(........B.
	0x0030:  0000 429d                                ..B.

# 第二次 ./client.o

00:29:39.271936 IP localhost.51398 &amp;gt; localhost.6666: Flags [S], seq 2362540136, win 43690, options [mss 65495,sackOK,TS val 18166 ecr 0,nop,wscale 7,exp-tfo cookiereq], length 0
	0x0000:  4500 0040 c69e 4000 4006 7617 7f00 0001  E..@..@.@.v.....
	0x0010:  7f00 0001 c8c6 1a0a 8cd1 8068 0000 0000  ...........h....
	0x0020:  b002 aaaa fe34 0000 0204 ffd7 0402 080a  .....4..........
	0x0030:  0000 46f6 0000 0000 0103 0307 fe04 f989  ..F.............
00:29:39.271986 IP localhost.6666 &amp;gt; localhost.51398: Flags [S.], seq 3703577773, ack 2362540137, win 43690, options [mss 65495,sackOK,TS val 18166 ecr 18166,nop,wscale 7], length 0
	0x0000:  4500 003c 0000 4000 4006 3cba 7f00 0001  E..&amp;lt;..@.@.&amp;lt;.....
	0x0010:  7f00 0001 1a0a c8c6 dcc0 1cad 8cd1 8069  ...............i
	0x0020:  a012 aaaa fe30 0000 0204 ffd7 0402 080a  .....0..........
	0x0030:  0000 46f6 0000 46f6 0103 0307            ..F...F.....
00:29:39.272038 IP localhost.51398 &amp;gt; localhost.6666: Flags [P.], seq 1:21, ack 1, win 342, options [nop,nop,TS val 18166 ecr 18166], length 20
	0x0000:  4500 0048 c69f 4000 4006 760e 7f00 0001  E..H..@.@.v.....
	0x0010:  7f00 0001 c8c6 1a0a 8cd1 8069 dcc0 1cae  ...........i....
	0x0020:  8018 0156 fe3c 0000 0101 080a 0000 46f6  ...V.&amp;lt;........F.
	0x0030:  0000 46f6 4865 6c6c 6f2c 2074 6370 2066  ..F.Hello,.tcp.f
	0x0040:  6173 7420 6f70 656e                      ast.open
00:29:39.272072 IP localhost.6666 &amp;gt; localhost.51398: Flags [.], ack 21, win 342, options [nop,nop,TS val 18166 ecr 18166], length 0
	0x0000:  4500 0034 5a58 4000 4006 e269 7f00 0001  E..4ZX@.@..i....
	0x0010:  7f00 0001 1a0a c8c6 dcc0 1cae 8cd1 807d  ...............}
	0x0020:  8010 0156 fe28 0000 0101 080a 0000 46f6  ...V.(........F.
	0x0030:  0000 46f6                                ..F.
00:29:39.311280 IP localhost.6666 &amp;gt; localhost.51398: Flags [.], ack 22, win 342, options [nop,nop,TS val 18176 ecr 18166], length 0
	0x0000:  4500 0034 5a59 4000 4006 e268 7f00 0001  E..4ZY@.@..h....
	0x0010:  7f00 0001 1a0a c8c6 dcc0 1cae 8cd1 807e  ...............~
	0x0020:  8010 0156 fe28 0000 0101 080a 0000 4700  ...V.(........G.
	0x0030:  0000 46f6                                ..F.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;奇怪的是，在代码中启用tcp_fastopen的结果和不启用，并没有区别。那这是什么原因呢？&lt;/p&gt;

&lt;p&gt;通过搜索，发现在介绍&lt;a href=&#34;https://github.com/shadowsocks/shadowsocks/wiki/TCP-Fast-Open&#34;&gt;tcp fast open优化shadowsocks&lt;/a&gt;时，设置net.ipv4.tcp_fastopen为3，虽然奇怪，但是可以试试：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sysctl -a | grep fastopen

net.ipv4.tcp_fastopen = 3
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
# 第一次，server返回cookie unknown-34 0x38af51c10bf41ca4

00:36:36.667932 IP localhost.52220 &amp;gt; localhost.6666: Flags [S], seq 3662514892, win 43690, options [mss 65495,sackOK,TS val 122515 ecr 0,nop,wscale 7,unknown-34,nop,nop], length 0
	0x0000:  4500 0040 545f 4000 4006 e856 7f00 0001  E..@T_@.@..V....
	0x0010:  7f00 0001 cbfc 1a0a da4d 8acc 0000 0000  .........M......
	0x0020:  b002 aaaa fe34 0000 0204 ffd7 0402 080a  .....4..........
	0x0030:  0001 de93 0000 0000 0103 0307 2202 0101  ............&amp;quot;...
00:36:36.667990 IP localhost.6666 &amp;gt; localhost.52220: Flags [S.], seq 3186866007, ack 3662514893, win 43690, options [mss 65495,sackOK,TS val 122515 ecr 122515,nop,wscale 7,unknown-34 0x38af51c10bf41ca4,nop,nop], length 0
	0x0000:  4500 0048 0000 4000 4006 3cae 7f00 0001  E..H..@.@.&amp;lt;.....
	0x0010:  7f00 0001 1a0a cbfc bdf3 b757 da4d 8acd  ...........W.M..
	0x0020:  d012 aaaa fe3c 0000 0204 ffd7 0402 080a  .....&amp;lt;..........
	0x0030:  0001 de93 0001 de93 0103 0307 220a 38af  ............&amp;quot;.8.
	0x0040:  51c1 0bf4 1ca4 0101                      Q.......
00:36:36.668050 IP localhost.52220 &amp;gt; localhost.6666: Flags [P.], seq 1:21, ack 1, win 342, options [nop,nop,TS val 122515 ecr 122515], length 20
	0x0000:  4500 0048 5460 4000 4006 e84d 7f00 0001  E..HT`@.@..M....
	0x0010:  7f00 0001 cbfc 1a0a da4d 8acd bdf3 b758  .........M.....X
	0x0020:  8018 0156 fe3c 0000 0101 080a 0001 de93  ...V.&amp;lt;..........
	0x0030:  0001 de93 4865 6c6c 6f2c 2074 6370 2066  ....Hello,.tcp.f
	0x0040:  6173 7420 6f70 656e                      ast.open
00:36:36.668109 IP localhost.6666 &amp;gt; localhost.52220: Flags [.], ack 21, win 342, options [nop,nop,TS val 122515 ecr 122515], length 0
	0x0000:  4500 0034 69cb 4000 4006 d2f6 7f00 0001  E..4i.@.@.......
	0x0010:  7f00 0001 1a0a cbfc bdf3 b758 da4d 8ae1  ...........X.M..
	0x0020:  8010 0156 fe28 0000 0101 080a 0001 de93  ...V.(..........
	0x0030:  0001 de93                                ....
00:36:36.707264 IP localhost.6666 &amp;gt; localhost.52220: Flags [.], ack 22, win 342, options [nop,nop,TS val 122525 ecr 122515], length 0
	0x0000:  4500 0034 69cc 4000 4006 d2f5 7f00 0001  E..4i.@.@.......
	0x0010:  7f00 0001 1a0a cbfc bdf3 b758 da4d 8ae2  ...........X.M..
	0x0020:  8010 0156 fe28 0000 0101 080a 0001 de9d  ...V.(..........
	0x0030:  0001 de93                                ....


# 第二次，client发送请求时，将cookie写在syn包中，同时带上发送的数据；server端校验后(kernel和tcp/ip协议栈做校验)后返回成功，如此在3次握手中节省了一次rtt时间

00:36:38.744954 IP localhost.52226 &amp;gt; localhost.6666: Flags [S], seq 1820632025:1820632045, win 43690, options [mss 65495,sackOK,TS val 123034 ecr 0,nop,wscale 7,unknown-34 0x38af51c10bf41ca4,nop,nop], length 20
	0x0000:  4500 005c 4343 4000 4006 f956 7f00 0001  E..\CC@.@..V....
	0x0010:  7f00 0001 cc02 1a0a 6c84 a3d9 0000 0000  ........l.......
	0x0020:  d002 aaaa fe50 0000 0204 ffd7 0402 080a  .....P..........
	0x0030:  0001 e09a 0000 0000 0103 0307 220a 38af  ............&amp;quot;.8.
	0x0040:  51c1 0bf4 1ca4 0101 4865 6c6c 6f2c 2074  Q.......Hello,.t
	0x0050:  6370 2066 6173 7420 6f70 656e            cp.fast.open
00:36:38.745022 IP localhost.6666 &amp;gt; localhost.52226: Flags [S.], seq 3848342665, ack 1820632046, win 43690, options [mss 65495,sackOK,TS val 123034 ecr 123034,nop,wscale 7], length 0
	0x0000:  4500 003c 0000 4000 4006 3cba 7f00 0001  E..&amp;lt;..@.@.&amp;lt;.....
	0x0010:  7f00 0001 1a0a cc02 e561 0c89 6c84 a3ee  .........a..l...
	0x0020:  a012 aaaa fe30 0000 0204 ffd7 0402 080a  .....0..........
	0x0030:  0001 e09a 0001 e09a 0103 0307            ............
00:36:38.745072 IP localhost.52226 &amp;gt; localhost.6666: Flags [.], ack 1, win 342, options [nop,nop,TS val 123034 ecr 123034], length 0
	0x0000:  4500 0034 4344 4000 4006 f97d 7f00 0001  E..4CD@.@..}....
	0x0010:  7f00 0001 cc02 1a0a 6c84 a3ee e561 0c8a  ........l....a..
	0x0020:  8010 0156 fe28 0000 0101 080a 0001 e09a  ...V.(..........
	0x0030:  0001 e09a                                ....
00:36:38.745127 IP localhost.52226 &amp;gt; localhost.6666: Flags [F.], seq 1, ack 1, win 342, options [nop,nop,TS val 123034 ecr 123034], length 0
	0x0000:  4500 0034 4345 4000 4006 f97c 7f00 0001  E..4CE@.@..|....
	0x0010:  7f00 0001 cc02 1a0a 6c84 a3ee e561 0c8a  ........l....a..
	0x0020:  8011 0156 fe28 0000 0101 080a 0001 e09a  ...V.(..........
	0x0030:  0001 e09a                                ....
00:36:38.747232 IP localhost.6666 &amp;gt; localhost.52226: Flags [.], ack 2, win 342, options [nop,nop,TS val 123035 ecr 123034], length 0
	0x0000:  4500 0034 ec10 4000 4006 50b1 7f00 0001  E..4..@.@.P.....
	0x0010:  7f00 0001 1a0a cc02 e561 0c8a 6c84 a3ef  .........a..l...
	0x0020:  8010 0156 fe28 0000 0101 080a 0001 e09b  ...V.(..........
	0x0030:  0001 e09a                                ....

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;上述通信过程中

&lt;ul&gt;
&lt;li&gt;第一次，server返回cookie unknown-34 0x38af51c10bf41ca4&lt;/li&gt;
&lt;li&gt;第二次，client发送请求时，将cookie写在syn包中，同时带上发送的数据；server端校验后(kernel和tcp/ip协议栈做校验)后返回成功，如此在3次握手中节省了一次rtt时间&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;也就是说，在net.ipv4.tcp_fastopen设置为3时，tcp fastopen特性使能&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关于如何使能TFO，在前文中的TFO的配置说明中，我们可以看到，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;	The values (bitmap) are
	1: Enables sending data in the opening SYN on the client w/ MSG_FASTOPEN.
		使能client端的TFO特性
	2: Enables TCP Fast Open on the server side, i.e., allowing data in
	   a SYN packet to be accepted and passed to the application before
	   3-way hand shake finishes.
		使能server端的TFO特性
	4: Send data in the opening SYN regardless of cookie availability and
	   without a cookie option.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;并且这个标志是位操作，如果我在本机做实验，将本机作为sever端和client端的话，需要两个位都使能，所以应该将该值设置为3.&lt;/p&gt;

&lt;p&gt;同时我们可以看到，tcp fast open是非常向后兼容的，升级成本不高，需要高于3.7+版本内核，但总体来说值得采用。&lt;/p&gt;

&lt;p&gt;nginx 1.5.18（2013年）开始支持tcp fast open&lt;/p&gt;

&lt;h2 id=&#34;todo-list:dcfa70d5873a9471dad227ae4d6ecbe0&#34;&gt;TODO LIST&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;TFO在移动端场景中的性能体现：android+nginx&lt;/li&gt;
&lt;li&gt;tcp fast open 在内核中的实现&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考链接:dcfa70d5873a9471dad227ae4d6ecbe0&#34;&gt;参考链接&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.sina.com.cn/s/blog_583f42f101011veh.html&#34;&gt;TFO&amp;mdash;google tcp fast open protocol&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/TCP_Fast_Open&#34;&gt;wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.pagefault.info/?p=282&#34;&gt;TFO简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bradleyfalzon/tcp-fast-open&#34;&gt;tfo的golang实现(github)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bradleyf.id.au/nix/shaving-your-rtt-wth-tfo/&#34;&gt;上一行项目的作者bradley falzon&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://static.googleusercontent.com/external_content/untrusted_dlcp/research.google.com/zh-CN/us/pubs/archive/37517.pdf&#34;&gt;google关于tfo的论文&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>effective tips in daily learning</title>
      <link>https://bg2bkk.github.io/post/effective%20tips%20in%20daily%20learning/</link>
      <pubDate>Fri, 06 May 2016 11:39:48 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/effective%20tips%20in%20daily%20learning/</guid>
      <description>

&lt;h2 id=&#34;分布式存储:078ecfed95ee4edc8bfbcc4d829697ee&#34;&gt;分布式存储&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://wuchong.me/blog/2014/08/07/distributed-storage-system-knowledge/&#34;&gt;知识体系&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://taop.marchtea.com/03.02.html&#34;&gt;B-Tree&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;分布式id生成:078ecfed95ee4edc8bfbcc4d829697ee&#34;&gt;分布式ID生成&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;amp;mid=403837240&amp;amp;idx=1&amp;amp;sn=ae9f2bf0cc5b0f68f9a2213485313127&amp;amp;scene=21#wechat_redirect&#34;&gt;ID&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;方案一： 常规数据库的auto increment服务

&lt;ul&gt;
&lt;li&gt;改进：可以将ID划均分给若干数据库，每个数据库自增的起点不一样，可以保证各库生成ID不同

&lt;ul&gt;
&lt;li&gt;缺点是非强一致性&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;方案二： 单点批量生成；ID生成服务每次从数据库预定一定容量的ID，然后派发；可以成倍降低数据库压力；

&lt;ul&gt;
&lt;li&gt;缺点：单点服务、可能造成空洞；&lt;/li&gt;
&lt;li&gt;改进：找备胎，一旦主ID服务挂掉，备胎立刻备上；通过vip+keepalived实现&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;方案三：uuid&lt;/li&gt;
&lt;li&gt;方案四：当前毫秒数；缺点是每个毫秒容量有限，也可能重复&lt;/li&gt;
&lt;li&gt;方案五：将64bit数字作为ID，分别包含字段：毫秒数、业务线、机房、机器、以及毫秒内序列号；根据业务来规划容量；毫秒数可以保证ID是趋势自增的&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/heyuquan/archive/2013/08/16/global-guid-identity-maxId.html&#34;&gt;ID&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;分布式锁:078ecfed95ee4edc8bfbcc4d829697ee&#34;&gt;分布式锁&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/zhengyun_ustc/archive/2012/11/17/topic2.html&#34;&gt;http://www.cnblogs.com/zhengyun_ustc/archive/2012/11/17/topic2.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.jeffkit.info/2011/07/1000/&#34;&gt;http://www.jeffkit.info/2011/07/1000/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;一致性哈希-consistent-hashing:078ecfed95ee4edc8bfbcc4d829697ee&#34;&gt;一致性哈希 consistent hashing&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.codeproject.com/Articles/56138/Consistent-hashing&#34;&gt;http://www.codeproject.com/Articles/56138/Consistent-hashing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.huanghao.me/?p=14&#34;&gt;http://blog.huanghao.me/?p=14&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/sparkliang/article/details/5279393&#34;&gt;http://blog.csdn.net/sparkliang/article/details/5279393&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;并发编程:078ecfed95ee4edc8bfbcc4d829697ee&#34;&gt;并发编程&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://hedengcheng.com/?p=725&#34;&gt;volatile&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://blogread.cn/it/article/7282?f=wb&#34;&gt;并发编程&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.infoq.com/cn/articles/producers-and-consumers-mode&#34;&gt;聊聊并发&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;nginx配置文件:078ecfed95ee4edc8bfbcc4d829697ee&#34;&gt;nginx配置文件&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;rewrite:

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.xiehaichao.com/articles/428.html&#34;&gt;http://www.xiehaichao.com/articles/428.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://seanlook.com/2015/05/17/nginx-location-rewrite/&#34;&gt;http://seanlook.com/2015/05/17/nginx-location-rewrite/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;lua的学习-使用和源码精读:078ecfed95ee4edc8bfbcc4d829697ee&#34;&gt;Lua的学习、使用和源码精读&lt;/h2&gt;

&lt;h2 id=&#34;lua的元表:078ecfed95ee4edc8bfbcc4d829697ee&#34;&gt;lua的元表&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://lua-users.org/wiki/MetamethodsTutorial&#34;&gt;http://lua-users.org/wiki/MetamethodsTutorial&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;元表用来扩展lua对象的功能，元表的含义在于生来就有，lua对象本身会带有这个表，所以称为元表&lt;/li&gt;
&lt;li&gt;metatable也是普通的lua table，包含一系列元方法metamethods，每个元方法有对应的events触发；比如&lt;a href=&#34;http://lua-users.org/wiki/MetatableEvents&#34;&gt;算术运算符、__index 等操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;__index&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://lua-users.org/wiki/MetatableEvents&#34;&gt;http://lua-users.org/wiki/MetatableEvents&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt; &lt;strong&gt;__index&lt;/strong&gt; - Control &amp;lsquo;prototype&amp;rsquo; inheritance. When accessing &amp;ldquo;myTable[key]&amp;rdquo; and the key does not appear in the table, but the metatable has an __index property:
&lt;ul&gt;
&lt;li&gt; if the value is a function, the function is called, passing in the table and the key; the return value of that function is returned as the result.
&lt;/li&gt;&lt;li&gt; if the value is another table, the value of the key in that table is asked for and returned
&lt;ul&gt;
&lt;li&gt; &lt;em&gt;(and if it doesn&amp;rsquo;t exist in &lt;strong&gt;that&lt;/strong&gt; table, but that table&amp;rsquo;s metatable has an __index property, then it continues on up)&lt;/em&gt;
&lt;/li&gt;&lt;/ul&gt;
&lt;/li&gt;&lt;li&gt; &lt;em&gt;Use &amp;ldquo;rawget(myTable,key)&amp;rdquo; to skip this metamethod.&lt;/em&gt;
&lt;/li&gt;&lt;/ul&gt;
&lt;/li&gt;&lt;/ul&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;控制类型继承；当访问myTable[key]，而table中没有key域时，如果元表有__index项：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果__index是函数，则调用该函数&lt;/li&gt;
&lt;li&gt;如果__index是table，返回这个table中key域的值；如果__index是table并且该table没有key域，但是该table有__index，则继续查找(calls fallback function or fallback table)&lt;/li&gt;
&lt;li&gt;使用rawget(myTable, key)可以跳过metatable&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;__index是一个应用广泛并用处很大的元方法metamethod&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果想获取table中的元素key，而key在table中没有找到，该方法可以定义为函数或者一个table，来寻找key。

&lt;ul&gt;
&lt;li&gt;如果__index是函数，该函数的第一个参数是没有找到key的这个table，第二个参数是key；&lt;/li&gt;
&lt;li&gt;如果__index是table，那么将在该table中寻找key，如果没有找到，可以继续从这个table的__index寻找，因此你可以通过__index进行一整个链条的查找。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;__metatable&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;用于隐藏metatable，当调用getmetatable(myTable)时，如果该域不为空，则返回这个域的值，而不是metatable&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://lua-users.org/wiki/LuaClassesWithMetatable&#34;&gt;sample code&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;lua源码精读:078ecfed95ee4edc8bfbcc4d829697ee&#34;&gt;Lua源码精读&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Lua的全局和状态，以及初始化

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/maximuszhou/article/details/46277695&#34;&gt;Lua的全局和状态&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;在调用lua_newstate 初始化Lua虚拟机时，会创建一个全局状态和一个线程（或称为调用栈），这个全局状态在整个虚拟机中是唯一的，供其他线程共享。一个Lua虚拟机中可以包括多个线程，这些线程共享一个全局状态，线程之间也可以调用lua_xmove函数来交换数据。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/ringofthec/archive/2010/11/09/lua_State.html&#34;&gt;LuaVM 初始化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://yq.aliyun.com/articles/1756?spm=5176.100240.searchblog.8.YbMjAK&#34;&gt;lua_State&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;lua与c的交互:078ecfed95ee4edc8bfbcc4d829697ee&#34;&gt;Lua与C的交互&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;* [深入理解Lua与C用于数据交互的栈](http://blog.csdn.net/maximuszhou/article/details/21331819)
* 为啥要通过 栈 来通信呢？
    * Lua是动态类型语言，在Lua语言中没有类型定义的语法，每个值都携带了它自身的类型信息，而C语言是静态类型语言
    * Lua使用垃圾收集，可以自动管理内存，而C语言要求程序自己释放分配的内存，需应用程序自身管理内存
* 压栈的影响
    * C将值压入栈中后，Lua将会生成相应类型的结构，存储和管理这个值
    * Lua不会持有指向VM外部的指针，指向的都是自己的结构和栈上的结构
    * 比如压入字符串，Lua生成Lua_TTSTRING类型的对象，C可以随意释放这个字符串
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://if-yu.info/lua-notes.html&#34;&gt;http://if-yu.info/lua-notes.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;list和nil:078ecfed95ee4edc8bfbcc4d829697ee&#34;&gt;list和nil&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;* https://techsingular.org/2012/12/22/programming-in-lua%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%8D-nil-%E5%92%8C-list/
* nil不但不是无的意思，反而在list中起到占位和有的意思。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;lua的first-class-https-techsingular-org-2012-12-22-programming-in-lua-ef-bc-88-e5-9b-9b-ef-bc-89-ef-bc-8d-nil-e5-92-8c-list:078ecfed95ee4edc8bfbcc4d829697ee&#34;&gt;&lt;a href=&#34;https://techsingular.org/2012/12/22/programming-in-lua%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%8D-nil-%E5%92%8C-list/&#34;&gt;lua的first class&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;可以被赋值给变量；&lt;/li&gt;
&lt;li&gt;可以作为参数；&lt;/li&gt;
&lt;li&gt;可以作为返回值；&lt;/li&gt;
&lt;li&gt;可以作为数据结构的构成部分。( 注意 nil 并不完全符合这个要求，但是可以通过某个 field 的缺失来表示 nil。)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;lua的gc:078ecfed95ee4edc8bfbcc4d829697ee&#34;&gt;Lua的GC&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;* lua的[gc](https://techsingular.org/2013/10/27/lua-%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;lua的table:078ecfed95ee4edc8bfbcc4d829697ee&#34;&gt;lua的table&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;* https://facepunch.com/showthread.php?t=1306348
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;I don&amp;rsquo;t believe this is correct. It was my understanding that Lua tables are implemented as a two-part data structure whereby dense non-negative integer keys are stored as a simple array and are therefore indexed by a simple pointer addition and dereference, which is O(1). All other keys (non-integer, negative and sparse integer) are stored in a hashmap as a chained scatter table which stores key-values pairs as a flat array indexed by the hash of the key. Collisions are resolved by storing pointers to the next element with the same hash alongside this (essentially a linked list of colliding elements). At worst case, where all elements collide, the complexity of this implementation is O(n), however it is expected that on average the number of collisions per element is 1 and the maximum is 2; this means that the average complexity is O(1).&lt;/p&gt;

&lt;p&gt;The implementation of Lua tables is such that, even with a huge number of elements, lookup is as quick as possible.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;lua函数使用:078ecfed95ee4edc8bfbcc4d829697ee&#34;&gt;lua函数使用&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;setmetatable&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.lua.org/manual/5.2/manual.html&#34;&gt;https://www.lua.org/manual/5.2/manual.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;setmetatable(table, metatable)

&lt;ul&gt;
&lt;li&gt;将metatable设置为table的元表，（在Lua中只能设置table的元表，其他类型的对象不行，除非使用C）。如果metatable为nil，则参数cable的元表被清除；如果该table的__metatable不为空，则抛出异常&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;该函数返回table&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;collectgarbage(&amp;ldquo;count&amp;rdquo;)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;垃圾回收函数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.lua.org/manual/5.2/manual.html#2.6&#34;&gt;lua yield 和 resume&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lua.org/manual/5.2/manual.html#pdf-coroutine.resume&#34;&gt;http://www.lua.org/manual/5.2/manual.html#pdf-coroutine.resume&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- http://my.oschina.net/wangxuanyihaha/blog/186401

function foo(a)
    print(&amp;quot;foo&amp;quot;, a)
    return coroutine.yield(2 * a)
end

co = coroutine.create(function ( a, b )
    print(&amp;quot;co-body&amp;quot;, a, b)
    local r = foo(a + 1)
    print(&amp;quot;co-body&amp;quot;, r)
    local r, s = coroutine.yield(a + b, a - b)
    print(&amp;quot;co-body&amp;quot;, r, s)
    return b, &amp;quot;end&amp;quot;
end)

print(&amp;quot;main&amp;quot;, coroutine.resume(co, 1, 10))
print(&amp;quot;main&amp;quot;, coroutine.resume(co, &amp;quot;m&amp;quot;))	-- resume的参数 &#39;m&#39; 是在调用yield传入的，所以本次是在第5行 return m
print(&amp;quot;main&amp;quot;, coroutine.resume(co, &amp;quot;x&amp;quot;, &amp;quot;y&amp;quot;))
print(&amp;quot;main&amp;quot;, coroutine.resume(co, &amp;quot;x&amp;quot;, &amp;quot;y&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;co-body	1	10
foo	2
main	true	4
co-body	m
main	true	11	-9
co-body	x	y
main	true	10	end
main	false	cannot resume dead coroutine
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;lua编码的陷阱:078ecfed95ee4edc8bfbcc4d829697ee&#34;&gt;lua编码的陷阱&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;* [字符串拼接导致垃圾产生](http://tech.uc.cn/?p=1131)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;golang:078ecfed95ee4edc8bfbcc4d829697ee&#34;&gt;golang&lt;/h2&gt;

&lt;h3 id=&#34;golang的并发-协程和channel:078ecfed95ee4edc8bfbcc4d829697ee&#34;&gt;golang的并发、协程和channel&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://ibillxia.github.io/blog/2014/03/16/go-concurrent-programming-first-try/&#34;&gt;golang并发编程初探&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;	for i := 0; i &amp;lt; 10; i++ {
		go func() {
			arr[i] = i + i*i
			chs[i] &amp;lt;- arr[i]
		}()
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类似于如上形式的for循环中启动go协程，在for循环结束时协程才会开执行，所以每个协程用到的i都是最大值10&lt;/p&gt;

&lt;p&gt;可以将i加入到协程的参数中，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;	for i := 0; i &amp;lt; 10; i++ {
		
		chs[i] = make(chan int)
		go func(i) {
			arr[i] = i + i*i
			chs[i] &amp;lt;- arr[i]
		}(i)
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以用局部变量保存i值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;	for i := 0; i &amp;lt; 10; i++ {
		i := i
		chs[i] = make(chan int)
		go func() {
			arr[i] = i + i*i
			chs[i] &amp;lt;- arr[i]
		}()
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.chenwang.net/2015/12/12/%E5%AE%8C%E6%95%B4%E7%9A%84golang-%E5%A4%9A%E5%8D%8F%E7%A8%8B%E4%BF%A1%E9%81%93-%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86%E7%A4%BA%E4%BE%8B/&#34;&gt;golang多协程channel同步&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;sync.WaitGroup&lt;/li&gt;
&lt;li&gt;defer&lt;/li&gt;
&lt;li&gt;recover&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/gophers/article/details/40505683&#34;&gt;golang闭包与协程使用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;golang设计模式:078ecfed95ee4edc8bfbcc4d829697ee&#34;&gt;golang设计模式&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;* [单例模式](http://marcio.io/2015/07/singleton-pattern-in-go/)
* [golang map reduce](https://gist.github.com/mcastilho)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;golang接口:078ecfed95ee4edc8bfbcc4d829697ee&#34;&gt;golang接口&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;* https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/02.6.md
* http://xiaorui.cc/2016/03/11/%E5%85%B3%E4%BA%8Egolang-struct-interface%E7%9A%84%E7%90%86%E8%A7%A3%E4%BD%BF%E7%94%A8/
* http://blog.csdn.net/zhangzhebjut/article/details/24974315
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;UML图&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;实现关系、泛化关系、关联关系、聚合关系 &lt;a href=&#34;http://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html&#34;&gt;http://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;设计模式&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://tengj.top/2016/04/04/sjms3abstractfactory/&#34;&gt;http://tengj.top/2016/04/04/sjms3abstractfactory/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>resume</title>
      <link>https://bg2bkk.github.io/post/resume/</link>
      <pubDate>Fri, 22 Apr 2016 11:25:56 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/resume/</guid>
      <description>

&lt;h1 id=&#34;黄振栋简历:c59a67a3c7bc5faa453847420267045e&#34;&gt;黄振栋简历&lt;/h1&gt;

&lt;h2 id=&#34;联系方式:c59a67a3c7bc5faa453847420267045e&#34;&gt;联系方式&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Email：bg2bkk # gmail.com&lt;/li&gt;
&lt;li&gt;微博：&lt;a href=&#34;http://weibo.com/BG2BKK&#34;&gt;@bg2bkk&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;个人信息:c59a67a3c7bc5faa453847420267045e&#34;&gt;个人信息&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;男/1990&lt;/li&gt;
&lt;li&gt;硕士/哈工大深圳研究生院计算机系&lt;/li&gt;
&lt;li&gt;工作年限：14个月&lt;/li&gt;
&lt;li&gt;英语水平：CET-6&lt;/li&gt;
&lt;li&gt;技术博客：&lt;a href=&#34;http://bg2bkk.github.io&#34;&gt;http://bg2bkk.github.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Github：&lt;a href=&#34;http://github.com/bg2bkk&#34;&gt;http://github.com/bg2bkk&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;教育背景:c59a67a3c7bc5faa453847420267045e&#34;&gt;教育背景&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;- 2012.09 ~ 2015.01 哈尔滨工业大学 计算机 硕士
- 2008.09 ~ 2012.06 哈尔滨工程大学 计算机 学士 
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;技能清单:c59a67a3c7bc5faa453847420267045e&#34;&gt;技能清单&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;c/ lua/ python/ golang/ shell/ vhdl&lt;/li&gt;
&lt;li&gt;nginx/ ngx_lua/ redis&lt;/li&gt;
&lt;li&gt;linux kernel/ performance profiling&lt;/li&gt;
&lt;li&gt;算法、数据结构和设计模式&lt;/li&gt;
&lt;li&gt;linux系统编程、多线程编程、网络编程&lt;/li&gt;
&lt;li&gt;embedded system &amp;amp;&amp;amp; IOT: ble/mqtt/elua&lt;/li&gt;
&lt;li&gt;microprocessor: stm32 51 avr FPGA&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;自我评价:c59a67a3c7bc5faa453847420267045e&#34;&gt;自我评价&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;热爱计算机，热爱编程，热爱程序员这个工作&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;工作经历:c59a67a3c7bc5faa453847420267045e&#34;&gt;工作经历&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;- 2015.01 ~ NOW      新浪微博   系统开发工程师 
- 2013.09 ~ 2014.05  极光推送   后台开发实习生 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;项目经历:c59a67a3c7bc5faa453847420267045e&#34;&gt;项目经历&lt;/h2&gt;

&lt;h4 id=&#34;新浪微博-系统开发工程师-2015年1月-2016年3月:c59a67a3c7bc5faa453847420267045e&#34;&gt;新浪微博 系统开发工程师 （ 2015年1月 ~ 2016年3月 ）&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;手机微博七层动态调度系统dygateway&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;动态调度系统&lt;strong&gt;&lt;em&gt;dygateway&lt;/em&gt;&lt;/strong&gt; 在手机微博7层实现

&lt;ul&gt;
&lt;li&gt;系统资源的动态伸缩&lt;/li&gt;
&lt;li&gt;用户请求的动态分流&lt;/li&gt;
&lt;li&gt;产品服务的灰度发布&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;dygateway作为7层服务时：

&lt;ul&gt;
&lt;li&gt;动态分流子系统 &lt;a href=&#34;https://github.com/CNSRE/ABTestingGateway&#34;&gt;ABTestingGateway&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;根据用户请求的特征和分流策略将请求转发至不同的后端upstream；&lt;/li&gt;
&lt;li&gt;动态设置分流策略，实时生效；&lt;/li&gt;
&lt;li&gt;支持单级分流和多级分流。&lt;/li&gt;
&lt;li&gt;基于ngx_lua 和 redis 开发&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;动态upstream模块&lt;a href=&#34;https://github.com/CNSRE/lua-upstream-nginx-module&#34;&gt;lua-upstream-nginx-module&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;该模块可以实时修改nginx的upstream列表，增减upstream，增减upstream中的member成员，实现动态伸缩。&lt;/li&gt;
&lt;li&gt;nginx模块开发&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;目前应用于手机微博、微博头条等产品线&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!--
修改nginx内部的upstream模块，在高并发压力下性能不下降，实时动态分流
灰度子系统在对用户请求做一定处理，比如添加uri参数、header头部等后，再转发至目标后端。可以动态设置分流策略，实时生效，无需重启
--&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;手机微博 HTTP DNS 服务端开发

&lt;ul&gt;
&lt;li&gt;手机微博httpdns项目用于解决客户端恶意劫持的问题，并能够实现节点的智能调度。&lt;/li&gt;
&lt;li&gt;一期：nginx + edns server松耦合实现

&lt;ul&gt;
&lt;li&gt;参与开发nginx的http dns模块&lt;/li&gt;
&lt;li&gt;对项目进行压测和评估，目前已灰度上线&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;二期：golang + edns查询

&lt;ul&gt;
&lt;li&gt;参与golang server的架构设计及系统开发&lt;/li&gt;
&lt;li&gt;开发golang 版本的edns查询模块&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;httpdns server端一期已上线，手机微博客户端采用渠道包灰度；二期已完成edns查询模块。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;极光推送-jpush-cn-后台开发实习生-2013年9月-2014年5月:c59a67a3c7bc5faa453847420267045e&#34;&gt;极光推送(jpush.cn) 后台开发实习生（ 2013年9月 ~ 2014年5月 ）&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;大规模用户模拟系统&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;实习项目，该系统是极光推送后台系统中用于功能和负载测试的子系统，通过模拟真实用户的功能，保持大规模用户在线，统计模拟用户的运行数据，以测试推送系统的推送速度、负载强度和其他情况。&lt;/li&gt;
&lt;li&gt;在mentor指导下独立完成。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;经过系统设计、功能实现、压力测试及系统调优，单机可实现最高200万TCP长连接，线上运行时单机模拟50万用户，长期稳定运行。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;linux cpp tcp epoll 多线程及线程间通信&lt;/li&gt;
&lt;li&gt;单进程epoll和非阻塞IO实现高并发&lt;/li&gt;
&lt;li&gt;多线程分别实现配置上传下发模块、统计模块、上报模块和心跳模块&lt;/li&gt;
&lt;li&gt;tornado实现管理界面和监控界面&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;项目-演讲和讲义:c59a67a3c7bc5faa453847420267045e&#34;&gt;项目 演讲和讲义&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/WEIBOMSRE/ABTestingGateway&#34;&gt;ABTestingGateway&lt;/a&gt;：手机微博七层动态调度系统中关于灰度发布和动态分流的子项目，660+ stars。&lt;/li&gt;
&lt;li&gt;2015年OSC源创会运维专场：&lt;a href=&#34;https://github.com/WEIBOMSRE/ABTestingGateway/blob/master/doc/%E5%9F%BA%E4%BA%8E%E5%8A%A8%E6%80%81%E7%AD%96%E7%95%A5%E7%9A%84%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83%E7%B3%BB%E7%BB%9F.pdf&#34;&gt;基于动态策略的灰度发布系统&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;兴趣点:c59a67a3c7bc5faa453847420267045e&#34;&gt;兴趣点&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;兴趣广泛，从Linux服务端开发到安卓开发，从单片机开发到FPGA开发，从kernel源码到lua源码，我都有兴趣:)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对所使用的软件或服务，愿意并有能力进行深入理解，从设计思路到源码实现着手&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;TCP/ DNS/ HTTP&lt;/li&gt;
&lt;li&gt;Linux/ Nginx/ Redis/ Lua/&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对动态追踪和性能优化尤其有兴趣&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;linux/nginx的配置参数调优&lt;/li&gt;
&lt;li&gt;通过perf或者systemtap分析性能瓶颈&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Linux kernel&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;tcp/ip stack&lt;/li&gt;
&lt;li&gt;epoll&lt;/li&gt;
&lt;li&gt;memory management&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;个人项目:c59a67a3c7bc5faa453847420267045e&#34;&gt;个人项目&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/BG2BKK/MyDict&#34;&gt;MyDict&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一个离线词典&lt;/li&gt;
&lt;li&gt;原作者采用trie树对离线词库生成索引，我采用三向单词查找树(Ternary search tries TSTs)实现&lt;/li&gt;
&lt;li&gt;数据结构解决实际问题，体现程序员的价值&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/BG2BKK/NFA_by_Python&#34;&gt;NFA_By_Python&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;《计算理论》专业课作业，内容是将使用NFA解析正则表达式，并将其可视化。&lt;/li&gt;
&lt;li&gt;python分析正则表达式，自动生成dot代码，通过graphviz画图并生成pdf&lt;/li&gt;
&lt;li&gt;这恐怕是我离计算机科学最近的一次了:)&lt;/li&gt;
&lt;li&gt;其实想想，计算理论还是非常有趣的，而我也无比热爱这门科学&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/BG2BKK/img_process_vhdl&#34;&gt;img_process_vhdl&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;纯VHDL写的通用图像处理框架，在FPGA进行图像卷积运算，进而可以实现滤波、开闭等操作&lt;/li&gt;
&lt;li&gt;考虑到github上好像逻辑工程师不多，我就不写README了。&lt;/li&gt;
&lt;li&gt;以后再也不碰FPGA了，VHDL这种逻辑语言其实没必要人肉来写&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>DNS with golang</title>
      <link>https://bg2bkk.github.io/post/DNS%20with%20golang/</link>
      <pubDate>Wed, 13 Apr 2016 11:37:24 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/DNS%20with%20golang/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/cobbliu/archive/2013/04/02/2996333.html&#34;&gt;DNS消息格式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/cobbliu/p/3188632.html&#34;&gt;EDNS详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc6891&#34;&gt;rfc6891&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ietf.org/id/draft-ietf-dnsop-edns-client-subnet-08.txt&#34;&gt;edns_client_subnet draft&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://noops.me/?p=653&#34;&gt;小米的ends实践&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;6. respond时也需要增加一个Additional RRs区域，直接把请求的Additional内容发过去就可以(如果支持source netmask，将请求中的source netmask复制到scope netmask中，OpenDNS要求必须支持scope netmask)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;* 意思是非OpenDNS就可以不支持scope netmask吗？目前新浪的仍然不支持
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/miekg/dns&#34;&gt;miekg/dns: golang lib&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;dig with edns&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.gsic.uva.es/~jnisigl/dig-edns-client-subnet.html&#34;&gt;https://www.gsic.uva.es/~jnisigl/dig-edns-client-subnet.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://xmodulo.com/geographic-location-ip-address-command-line.html&#34;&gt;http://xmodulo.com/geographic-location-ip-address-command-line.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;在线查询：curl ipinfo.io/23.66.166.151&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;DNS报文格式&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;IP packet

&lt;ul&gt;
&lt;li&gt;IP Header 20 bytes&lt;/li&gt;
&lt;li&gt;IP Data: UDP

&lt;ul&gt;
&lt;li&gt;UDP Header 8 bytes&lt;/li&gt;
&lt;li&gt;UDP Data: DNS

&lt;ul&gt;
&lt;li&gt;DNS Header 12 bytes&lt;/li&gt;
&lt;li&gt;DNS Data: RR

&lt;ul&gt;
&lt;li&gt;RR: Question[]&lt;/li&gt;
&lt;li&gt;RR: Answer[]&lt;/li&gt;
&lt;li&gt;RR: Authority[]&lt;/li&gt;
&lt;li&gt;RR: Additional[]&lt;/li&gt;
&lt;li&gt;RR

&lt;ul&gt;
&lt;li&gt;QName&lt;/li&gt;
&lt;li&gt;QType&lt;/li&gt;
&lt;li&gt;QClass&lt;/li&gt;
&lt;li&gt;RDLENGTH&lt;/li&gt;
&lt;li&gt;RDATA&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;RR OPT

&lt;ul&gt;
&lt;li&gt;QName null&lt;/li&gt;
&lt;li&gt;QType OPT=41&lt;/li&gt;
&lt;li&gt;QClass = UDP payload 2bytes&lt;/li&gt;
&lt;li&gt;TTL = Extended-RCODE 1byte: extend + VERSION 1byte: 0 + Z 2bytes: 0&lt;/li&gt;
&lt;li&gt;RDLen len of data(OPT)&lt;/li&gt;
&lt;li&gt;OPT

&lt;ul&gt;
&lt;li&gt;Option-Code 2bytes: EDNS0_SUBNET&lt;/li&gt;
&lt;li&gt;Option-Length 2bytes&lt;/li&gt;
&lt;li&gt;Option-Data&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;Family 1byte: IPV4(1)&lt;/li&gt;
&lt;li&gt;Source Netmask 1byte: 32&lt;/li&gt;
&lt;li&gt;Scope Netmask 1byte: 0&lt;/li&gt;
&lt;li&gt;Client Subnet 4bytes: 65.135.152.203&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;我们总是在追一些时髦的技术，而不顾基础还不牢靠&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;我们总是看见新的框架，然而框架本质上仍然是那些东西，mvc，cs&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- http://www.tcpipguide.com/free/index.htm --&gt;

&lt;style type=&#34;text/css&#34;&gt;
div.t-h:hover &gt; div {display:block;}
.t-m-s {font-size:80%;border: 2px solid #ccc;border-spacing:0;border-collapse:collapse;}
.g-h-s {background:#9bf;color:#339;padding:4px; font-size:80%;font-weight:normal;border:1px solid #ccc;}
&lt;/style&gt;

&lt;table class=&#34;t-m-s&#34;&gt;
&lt;div align=&#34;center&#34;&gt;&lt;table border=&#34;3&#34; cellpadding=&#34;4&#34; cellspacing=&#34;2&#34;&gt;&lt;caption align=&#34;top&#34;&gt;&lt;p align=&#34;center&#34;&gt;&lt;font face=&#34;Arial&#34;&gt;&lt;b&gt;TCP Message Format &lt;/b&gt;&lt;/font&gt;&lt;/p&gt;&lt;/caption&gt;
&lt;tbody&gt;&lt;tr class=&#34;g-h-s&#34;&gt;
&lt;td&gt;Octet&lt;/td&gt;
&lt;td&gt;Bits&lt;/td&gt;
&lt;td&gt;Len&lt;/td&gt;
&lt;td&gt;Name&lt;/td&gt;
&lt;td&gt;Notes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0-1&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;Source port&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2-3&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;Destination Port&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4-7&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;Sequence number&lt;/td&gt;
&lt;td&gt;position of last octet we sent.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8-11&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;Acknowledge Number&lt;/td&gt;
&lt;td&gt;Next octet number we expect from the peer.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;0-3&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;HLEN&lt;/td&gt;
&lt;td&gt;4 bits. The number of 32 bit multiples (4 octets) in the TCP header including any &#39;options&#39; fields.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;4-7&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;Reserved&lt;/td&gt;
&lt;td&gt;should be zero&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;Code bits&lt;/td&gt;
&lt;td&gt;8 bits (6 used) valid if 1&lt;br&gt;
bit 0 (URG) Urgent&lt;br&gt;
bit 1 (ACK) Acknowledgement&lt;br&gt;
bit 2 (PSH) Requests PUSH&lt;br&gt;
bit 3 (RST) Reset connection&lt;br&gt;
bit 4 (SYN) Sync sequence numbers&lt;br&gt;
bit 5 (FIN) sender finished&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;14-15&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;Window&lt;/td&gt;
&lt;td&gt;Specifies the amount of data we can accept.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;16-17&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;Checksum&lt;/td&gt;
&lt;td&gt;Standard IP checksum. Includes a &lt;a href=&#34;#tcp-check&#34; class=&#34;t-db&#34;&gt;TCP pseudo header&lt;/a&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;18-19&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;Urgent pointer&lt;/td&gt;
&lt;td&gt;Points to end of urgent data.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;t-c&#34;&gt;
&lt;td colspan=&#34;5&#34;&gt;&lt;a href=&#34;#tcp_opts&#34; class=&#34;t-db&#34;&gt;TCP Options&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;t-c&#34;&gt;
&lt;td colspan=&#34;5&#34;&gt;TCP data&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/div&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>github 上那些令我感到惊艳又实用的项目</title>
      <link>https://bg2bkk.github.io/post/github%20%E4%B8%8A%E9%82%A3%E4%BA%9B%E4%BB%A4%E6%88%91%E6%84%9F%E5%88%B0%E6%83%8A%E8%89%B3%E5%8F%88%E5%AE%9E%E7%94%A8%E7%9A%84%E9%A1%B9%E7%9B%AE/</link>
      <pubDate>Tue, 12 Apr 2016 10:19:38 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/github%20%E4%B8%8A%E9%82%A3%E4%BA%9B%E4%BB%A4%E6%88%91%E6%84%9F%E5%88%B0%E6%83%8A%E8%89%B3%E5%8F%88%E5%AE%9E%E7%94%A8%E7%9A%84%E9%A1%B9%E7%9B%AE/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/phodal&#34;&gt;https://github.com/phodal&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/martinezjavier/ldd3&#34;&gt;https://github.com/martinezjavier/ldd3&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ldd3在kernel-2.6.32、kernel-2.6.35和kernel-2.6.37调试通过，可供学习。&lt;/li&gt;
&lt;li&gt;我使用ubuntu-10.04，kernle-2.6.32测试&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/duxing2007/ldd3-examples-3.x&#34;&gt;https://github.com/duxing2007/ldd3-examples-3.x&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ldd3在kernel-4.2.0-27、ubuntu-14.04测试，调试通过，可供学习&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/cmus/cmus&#34;&gt;https://github.com/cmus/cmus&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;命令行式的音乐播放器，依赖的解码库较多&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://code.facebook.com/posts/215466732167400/wangle-an-asynchronous-c-networking-and-rpc-library/&#34;&gt;wangle&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;facebook的RPC框架&lt;/li&gt;
&lt;li&gt;所依赖的一些异步库，比如&lt;a href=&#34;https://github.com/facebook/folly&#34;&gt;folly&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;github主页看起来非常清爽，代码质量十分之高，而且不是那种为了kpi而造轮子的，每个项目都有用处，高层项目构建于基础项目&lt;/li&gt;
&lt;li&gt;facebook主页可以多看看&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/cyfdecyf/spinlock&#34;&gt;https://github.com/cyfdecyf/spinlock&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://locklessinc.com/articles/locks/&#34;&gt;自旋锁专业研究&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/nlynch-mentor/vdsotest&#34;&gt;vdsotest&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;vdso研究学习&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;google&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/google/googletest&#34;&gt;googletest&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/gperftools/gperftools&#34;&gt;gperftool&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;c gui lib&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/vurtun/nuklear&#34;&gt;https://github.com/vurtun/nuklear&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/andlabs/libui&#34;&gt;https://github.com/andlabs/libui&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;redis-lua bloom filter&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/erikdubbelboer/redis-lua-scaling-bloom-filter&#34;&gt;https://github.com/erikdubbelboer/redis-lua-scaling-bloom-filter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;redis实现的布隆过滤器&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>shadowsocks go through the Fuck GFW</title>
      <link>https://bg2bkk.github.io/post/shadowsocks%20go%20through%20the%20F%2A%2Ak%20GFW/</link>
      <pubDate>Mon, 11 Apr 2016 00:33:17 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/shadowsocks%20go%20through%20the%20F%2A%2Ak%20GFW/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;买VPS，vultr的设备，使用起来还是蛮简单的。信用卡一张，注册并扣费0.1美元会送50美元，两个月内用完。我开始部署了一个日本的最便宜的5美元一月的vps，使用起来还不错，youtube 480P没问题；但是我通过这送的50美元实验了以下几个配置的机器速度，洛杉矶机房20美元，洛杉矶机房5美元，日本机房5美元，日本机房10美元，发现ping vps-ip时美国机房都是170ms，日本机房是220ms，原因可能是即使日本离得近，去日本的路由也要绕道美国才到日本的，所以我们直接选择美国机房好了。位于西海岸的洛杉矶机房，让你打开youtube 1080P毫无压力，白天晚上都没问题。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如何手动搭建shadowsocks服务呢，网上有太多的教程了&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;python版shadowsocks

&lt;ul&gt;
&lt;li&gt;ss服务的鼻祖，支持多用户多端口配置&lt;/li&gt;
&lt;li&gt;参考教程：&lt;a href=&#34;https://pypi.python.org/pypi/shadowsocks&#34;&gt;py版ss服务&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wget --no-check-certificate https://raw.githubusercontent.com/tennfy/shadowsocks-libev/master/debian_shadowsocks_tennfy.sh
chmod a+x debian_shadowsocks_tennfy.sh

sudo ./debian_shadowsocks_tennfy.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;    * /etc/init.d/shadowsocks-libev start
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;shadowsocks客户端&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;全平台：windows、linux、OSX；android、ios；&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://shadowsocks.com/client.html&#34;&gt;客户端&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/shadowsocks/shadowsocks-windows/releases&#34;&gt;windows&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/shadowsocks/shadowsocks-qt5/wiki/Installation&#34;&gt;linux&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ubuntu用户建议使用apt-get安装&lt;/li&gt;
&lt;li&gt;其他发行版用户。。。我还不知道&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/shadowsocks/shadowsocks-iOS/releases&#34;&gt;OSX&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;我没用过&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://pan.baidu.com/s/1YbQTg&#34;&gt;android&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.iyingsuo.com/ios-shadowsocks-tutorials.html&#34;&gt;ios&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果您觉得shadowsocks很容易搭建起来，想试一下的话，可以通过的推荐链接来注册，这样会有一定奖励:&lt;a href=&#34;http://www.vultr.com/?ref=6870148&#34;&gt;http://www.vultr.com/?ref=6870148&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>nginx gdb utils的编译 安装和使用</title>
      <link>https://bg2bkk.github.io/post/nginx-gdb-utils%E7%9A%84%E7%BC%96%E8%AF%91%20%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Fri, 25 Mar 2016 20:16:51 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/nginx-gdb-utils%E7%9A%84%E7%BC%96%E8%AF%91%20%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;1、想用&lt;a href=&#34;https://github.com/openresty/nginx-gdb-utils&#34;&gt;nginx-gdb-utils&lt;/a&gt;来监控ngx_lua的内存使用情况&lt;/li&gt;
&lt;li&gt;2、在CentOS 6.5上，gdb为7.2，python为2.6，没有一个符合的，想强上，没上了，只能在7上搞&lt;/li&gt;
&lt;li&gt;3、CentSO 7的gdb是7.6，版本也很老，对于nginx-gdb-utils来说。python倒是2.7，可以搞&lt;/li&gt;
&lt;li&gt;4、&lt;a href=&#34;http://www.linuxfromscratch.org/blfs/view/svn/general/gdb.html&#34;&gt;gdb&lt;/a&gt;需要编译安装，首先下载gdb-7.11&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;    cd gdb-7.11
    ./configure --with-python=python2.7
    报错，报python2.7找不到，换成

    ./configure --with-python=/usr/bin/python2.7
    依然报错
    很奇怪，难道不是要python2.7吗，怎么报找不到。
    后来才知道，需要python，要的不是python2.7的可执行文件，而是python的库文件等待

    sudo yum install python2.7-devel

    make -j24 --with-python
    注意我这里不用写--with-python=blahblah了
    终于不报错了

    make -C gdb install 
    报错，报没有makeinfo的错误，经查，makeinfo是texinfo的一部分，用来生成说明文档的，因为它而不能安装，蛋疼

    sudo yum install texinfo

    make -C gdb install
    安装在/usr/local/bin/gdb

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;5、将nginx-gdb-utils写入gdb初始化文件中，这样以后就不用每次加载py文件了&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;vim ~/.gdbinit

directory /path/to/nginx-gdb-utils

py import sys
py sys.path.append(&amp;quot;/path/to/nginx-gdb-utils&amp;quot;)

source luajit20.gdb
source ngx-lua.gdb
source luajit21.py
source ngx-raw-req.py
set python print-stack full
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但其实一般而言我们都是用root用户的，所以在sudo或者直接是root用户下时，需要重新写~/.gdbinit，这时应该是在/root/.gdbinit了&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;6、/usr/local/bin/gdb -p 12345&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;7、lgcstat&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;发现报一些函数或者变量找不到，比如Lgref找不到，这个原因是相关软件没有把用 -g 选项把符号编译进去&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;8、对于LuaJit而言，make CCDEBUG=-g -B -j8&lt;/li&gt;
&lt;li&gt;9、对于lua-cjson而言，make CCDEBUG=-g -B -j8&lt;/li&gt;
&lt;li&gt;10、对于tengine、nginx或者openresty而言，CFLAGS=&amp;ldquo;-g -O2&amp;rdquo; ./configure&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;11、自此就可以愉快的玩耍了。这些工具还是很有意思的。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>effective tips in daily work</title>
      <link>https://bg2bkk.github.io/post/effective%20tips%20in%20daily%20work/</link>
      <pubDate>Thu, 24 Mar 2016 16:36:33 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/effective%20tips%20in%20daily%20work/</guid>
      <description>

&lt;h2 id=&#34;linux获取系统调度时间片长度:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;Linux获取系统调度时间片长度&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#define _GNU_SOURCE
#include &amp;lt;sched.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;assert.h&amp;gt;

	int
main(int argc, char *argv[])
{
	int ret, i;  
	struct timespec tp;  
	ret = sched_rr_get_interval(0, &amp;amp;tp);  
	if(ret == -1)  
		printf(&amp;quot;sched_rr_get_interval error.\n&amp;quot;);  
	printf(&amp;quot;The time is %ds:%ldns.\n&amp;quot;, (int)tp.tv_sec, tp.tv_nsec);  
	return 0;  
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./cpu_time_slice.o 
The time is 0s:16000000ns.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见Ubuntu-16.04 64bit的系统进程时间片是16ms&lt;/p&gt;

&lt;h2 id=&#34;c语言中short-int-long内存占用:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;C语言中short、int、long内存占用&lt;/h2&gt;

&lt;p&gt;随着工作年限的增加，很多基本功反而落了下来，甚至开始怀疑short等类型的内存占用问题了呵呵。印象里一直记得int和long类型都是4字节大小啊&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

struct test{
	char *ch1;
	int i;
	long ch2;
} aa;

int main()
{
	printf(&amp;quot;Linux-64Bit-platform\n&amp;quot;);
	printf(&amp;quot;	%lu\n&amp;quot;, (unsigned long)sizeof(aa));
	printf(&amp;quot;	sizeof short : %d\n&amp;quot;, sizeof(short));
	printf(&amp;quot;	sizeof int   : %d\n&amp;quot;, sizeof(int));
	printf(&amp;quot;	sizeof long  : %d\n&amp;quot;, sizeof(long));
	
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
Linux-64Bit-platform
	24
	sizeof short : 2
	sizeof int   : 4
	sizeof long  : 8

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
Linux-32Bit-platform
	24
	sizeof short : 2
	sizeof int   : 4
	sizeof long  : 4

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看来，long和int大小一样已经是32位机器的老黄历了，基础知识还是应该常用常新啊&lt;/p&gt;

&lt;h2 id=&#34;文件操作的线程安全相关-待续:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;文件操作的线程安全相关（待续）&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://stackoverflow.com/questions/29981050/concurrent-writing-to-a-file&#34;&gt;http://stackoverflow.com/questions/29981050/concurrent-writing-to-a-file&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;ubuntu关闭键盘和触摸板的方法:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;ubuntu关闭键盘和触摸板的方法&lt;/h2&gt;

&lt;p&gt;家里的猫就是喜欢趴在笔记本键盘上看你干活，我只能再买一个键盘，然后笔记本键盘留给猫大爷了。&lt;/p&gt;

&lt;p&gt;然而它还喜欢在键盘上跳舞，这样太影响输入了，只能想办法把笔记本键盘关掉。&lt;/p&gt;

&lt;p&gt;在ubuntu下，键盘鼠标触控板都属于xinput设备，可以通过以下命令查看：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
$ xinput  --list
⎡ Virtual core pointer                    	id=2	[master pointer  (3)]
⎜   ↳ Virtual core XTEST pointer              	id=4	[slave  pointer  (2)]
⎜   ↳ SynPS/2 Synaptics TouchPad              	id=16	[slave  pointer  (2)]
⎜   ↳ Rapoo Rapoo Gaming Keyboard             	id=11	[slave  pointer  (2)]
⎜   ↳ RAPOO Rapoo 2.4G Wireless Device        	id=12	[slave  pointer  (2)]
⎜   ↳ Wacom ISDv4 E6 Pen stylus               	id=13	[slave  pointer  (2)]
⎜   ↳ Wacom ISDv4 E6 Finger touch             	id=14	[slave  pointer  (2)]
⎜   ↳ Wacom ISDv4 E6 Pen eraser               	id=18	[slave  pointer  (2)]
⎜   ↳ TPPS/2 IBM TrackPoint                   	id=19	[slave  pointer  (2)]
⎣ Virtual core keyboard                   	id=3	[master keyboard (2)]
    ↳ Virtual core XTEST keyboard             	id=5	[slave  keyboard (3)]
    ↳ Power Button                            	id=6	[slave  keyboard (3)]
    ↳ Video Bus                               	id=7	[slave  keyboard (3)]
    ↳ Sleep Button                            	id=8	[slave  keyboard (3)]
    ↳ Integrated Camera                       	id=9	[slave  keyboard (3)]
    ↳ Rapoo Rapoo Gaming Keyboard             	id=10	[slave  keyboard (3)]
    ↳ AT Translated Set 2 keyboard            	id=15	[slave  keyboard (3)]
    ↳ ThinkPad Extra Buttons                  	id=17	[slave  keyboard (3)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到笔记本键盘是&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;    ↳ AT Translated Set 2 keyboard            	id=15	[slave  keyboard (3)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而触控板是&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;⎜   ↳ SynPS/2 Synaptics TouchPad              	id=16	[slave  pointer  (2)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;他们的id分别是 15和 16，所以采用以下命令关掉就可以&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo sudo xinput set-prop 15 &amp;quot;Device Enabled&amp;quot; 0
sudo sudo xinput set-prop 16 &amp;quot;Device Enabled&amp;quot; 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;小于1024的保留端口都有哪些:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;小于1024的保留端口都有哪些&lt;/h2&gt;

&lt;p&gt;我们会遇到如下情况：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sudo tcpdump -i any port 1080
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on any, link-type LINUX_SLL (Linux cooked), capture size 262144 bytes
15:08:42.421693 IP localhost.55092 &amp;gt; localhost.socks: Flags [.], ack 1960200857, win 342, options [nop,nop,TS val 4687328 ecr 4676064], length 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我想监听1080端口，tcpdump为什么不乖乖显示1080，而是出现个socks呢？（可以通过&lt;strong&gt;&lt;em&gt;-n&lt;/em&gt;&lt;/strong&gt;参数解决）为什么1080是socks，而不是别的呢？&lt;/p&gt;

&lt;p&gt;这是因为低于1024的保留端口大多有自己的名字，他们&lt;a href=&#34;http://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml&#34;&gt;由IANA分配&lt;/a&gt;，通常用于系统进程，而我们可以在&lt;strong&gt;&lt;em&gt;/etc/services&lt;/em&gt;&lt;/strong&gt;文件中找到：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#
# From ``Assigned Numbers&#39;&#39;:
#
#&amp;gt; The Registered Ports are not controlled by the IANA and on most systems
#&amp;gt; can be used by ordinary user processes or programs executed by ordinary
#&amp;gt; users.
#
#&amp;gt; Ports are used in the TCP [45,106] to name the ends of logical
#&amp;gt; connections which carry long term conversations.  For the purpose of
#&amp;gt; providing services to unknown callers, a service contact port is
#&amp;gt; defined.  This list specifies the port used by the server process as its
#&amp;gt; contact port.  While the IANA can not control uses of these ports it
#&amp;gt; does register or list uses of these ports as a convienence to the
#&amp;gt; community.
#
socks		1080/tcp			# socks proxy server
socks		1080/udp
proofd		1093/tcp
proofd		1093/udp
rootd		1094/tcp
rootd		1094/udp
openvpn		1194/tcp
openvpn		1194/udp
rmiregistry	1099/tcp			# Java RMI Registry
rmiregistry	1099/udp
kazaa		1214/tcp
kazaa		1214/udp
nessus		1241/tcp			# Nessus vulnerability
nessus		1241/udp			#  assessment scanner
lotusnote	1352/tcp	lotusnotes	# Lotus Note
lotusnote	1352/udp	lotusnotes
ms-sql-s	1433/tcp			# Microsoft SQL Server
ms-sql-s	1433/udp
ms-sql-m	1434/tcp			# Microsoft SQL Monitor
ms-sql-m	1434/udp
ingreslock	1524/tcp
ingreslock	1524/udp
prospero-np	1525/tcp			# Prospero non-privileged

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;git修改默认分支名:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;git修改默认分支名&lt;/h2&gt;

&lt;p&gt;在develop分支改动太大了，导致merge 到master分支时非常被动，这个时候我想，干脆将develop分支作为分支好了。还好碰到&lt;a href=&#34;http://stackoverflow.com/questions/1485578/change-a-git-remote-head-to-point-to-something-besides-master&#34;&gt;stackoverflow的一个帖子&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;git branch -m master oldmaster&lt;/li&gt;
&lt;li&gt;git branch -m develop master&lt;/li&gt;
&lt;li&gt;git push -f origin master&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;另一个方法是从github的&lt;a href=&#34;https://help.github.com/articles/setting-the-default-branch/&#34;&gt;项目主页上更改&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;编译openssl-1-0-2g:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;编译openssl 1.0.2g&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./config shared -fPIC zlib-dynamic &amp;amp;&amp;amp; make depend -j   &amp;amp;&amp;amp; make -j
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;编译nginx-tengine-cpp模块:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;编译nginx/tengine: CPP模块&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./configure --add-module=../cpp_module  --with-ld-opt=&amp;quot;-lstdc++&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;curl-i-和-i的区别:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;curl -i 和 -I的区别&lt;/h2&gt;

&lt;p&gt;man page:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;	-i, --include
		(HTTP) Include the HTTP-header in the output. The HTTP-header includes things like server-name, date of the document, HTTP-version and more...
		
	-I, --head
		(HTTP/FTP/FILE) Fetch the HTTP-header only! HTTP-servers feature the command HEAD which this uses to get nothing but the header of a document. When used on an FTP or FILE file, curl displays the file size and last modification time only.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-i选项会打印出HTTP头部的一些信息，这个选项是curl软件的选项，这些信息本来就是存在的&lt;/p&gt;

&lt;p&gt;-I选项会发送HEAD请求，获取信息&lt;/p&gt;

&lt;h2 id=&#34;linux系统如何将父子进程一起kill掉:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;linux系统如何将父子进程一起kill掉&lt;/h2&gt;

&lt;p&gt;对于普通进程而言，kill掉父进程将会连带着把子进程kill掉；而对于daemon等类型进程而言，kill掉父进程，子进程会被daemon接管，所以如果想父子一起kill掉的话，不能直接kill父进程。&lt;/p&gt;

&lt;p&gt;有&lt;a href=&#34;http://blog.csdn.net/lalaguozhe/article/details/11142855&#34;&gt;两种方法&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;kill &amp;ndash; -PPID&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;PPID前面有&lt;strong&gt;&lt;em&gt;-&lt;/em&gt;&lt;/strong&gt;号，可以将父子进程kill掉&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用exec或者xargs来kill掉他们&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;dns查询中-域名是否可以有多个cname呢:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;dns查询中，域名是否可以有多个cname呢？&lt;/h2&gt;

&lt;p&gt;不可以
    * &lt;a href=&#34;http://serverfault.com/questions/574072/can-we-have-multiple-cnames-for-a-single-name&#34;&gt;http://serverfault.com/questions/574072/can-we-have-multiple-cnames-for-a-single-name&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;git代理访问:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;git代理访问&lt;/h2&gt;

&lt;p&gt;git config &amp;ndash;global http.proxy 10.8.0.1:8118&lt;/p&gt;

&lt;h2 id=&#34;ubuntu操作-挂载-格式化sd卡:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;ubuntu操作、挂载、格式化SD卡&lt;/h2&gt;

&lt;p&gt;玩树莓派等板子的时候，需要从host机器将os镜像烧进sd卡，然后启动。那么ubuntu如何操作呢？&lt;/p&gt;

&lt;p&gt;fdisk -l命令可以用来查看系统中的存储硬件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;

Disk /dev/sda: 111.8 GiB, 120034123776 bytes, 234441648 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: gpt
Disk identifier: C27256BB-CE04-48C2-96F4-8F79FAE2AE87

Device     Start       End   Sectors   Size Type
/dev/sda1   2048 234440703 234438656 111.8G Linux filesystem


Disk /dev/sdb: 167.7 GiB, 180045766656 bytes, 351651888 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x42b438a2

Device     Boot     Start       End   Sectors  Size Id Type
/dev/sdb1  *         2048 105887743 105885696 50.5G  7 HPFS/NTFS/exFAT
/dev/sdb2       105887744 187807665  81919922 39.1G 83 Linux
/dev/sdb3       187807744 228767743  40960000 19.5G  7 HPFS/NTFS/exFAT
/dev/sdb4       228769790 351649791 122880002 58.6G  f W95 Ext&#39;d (LBA)
/dev/sdb5       228769792 351649791 122880000 58.6G  7 HPFS/NTFS/exFAT


Disk /dev/sdc: 14.9 GiB, 16021192704 bytes, 31291392 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x00000000

Device     Boot Start      End  Sectors  Size Id Type
/dev/sdc1        8192 31291391 31283200 14.9G  c W95 FAT32 (LBA)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果sd卡（tf卡）通过usb 读卡器接入电脑，则会显示为 /dev/sdc&lt;/p&gt;

&lt;p&gt;如果是标准sd卡（大卡），则会显示为 /dev/mmblck0&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
Disk /dev/mmcblk0: 14.9 GiB, 16021192704 bytes, 31291392 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x00000000

Device         Boot Start      End  Sectors  Size Id Type
/dev/mmcblk0p1       8192 31291391 31283200 14.9G  c W95 FAT32 (LBA)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;推荐使用USB读卡器，速度较为快一些。&lt;/p&gt;

&lt;h2 id=&#34;lua库文件的加载路径:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;Lua库文件的加载路径&lt;/h2&gt;

&lt;p&gt;Lua 提供一个名为 &lt;a href=&#34;http://www.lua.org/manual/5.1/manual.html#pdf-require&#34;&gt;require&lt;/a&gt; 的函数来加载模块，使用也很简单，它只有一个参数，这个参数就是要指定加载的模块名，&lt;a href=&#34;http://dhq.me/lua-learning-notes-package-and-module&#34;&gt;例如&lt;/a&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&amp;quot;&amp;lt;模块名&amp;gt;&amp;quot;)
-- 或者是
-- require &amp;quot;&amp;lt;模块名&amp;gt;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后会返回一个由模块常量或函数组成的 table，并且还会定义一个包含该 table 的全局变量。&lt;/p&gt;

&lt;p&gt;或者给加载的模块定义一个别名变量，方便调用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local m = require(&amp;quot;module&amp;quot;)
print(m.constant)
m.func3()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于自定义的模块，模块文件不是放在哪个文件目录都行，函数 require 有它自己的文件路径加载策略，它会尝试从 Lua 文件或 C 程序库中加载模块。&lt;/p&gt;

&lt;p&gt;require 用于搜索 Lua 文件的路径是存放在全局变量 package.path 中，当 Lua 启动后，会以环境变量 LUA_PATH 的值来初始这个环境变量。如果没有找到该环境变量，则使用一个编译时定义的默认路径来初始化。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
Lua 5.1.5  Copyright (C) 1994-2012 Lua.org, PUC-Rio
&amp;gt;  print(package.path)
~/lua/?.lua;/usr/local/share/lua/5.1/?.lua;/home/huang/workspace/luactor/?.lua;./?.lua;/usr/local/share/lua/5.1/?.lua;/usr/local/share/lua/5.1/?/init.lua;/usr/local/lib/lua/5.1/?.lua;/usr/local/lib/lua/5.1/?/init.lua;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果没有 LUA_PATH 这个环境变量，也可以自定义设置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;huang@ThinkPad-X220:~/workspace/luapkg/luasocket-2.0.2$ export LUA_PATH=&amp;quot;4;;&amp;quot;
huang@ThinkPad-X220:~/workspace/luapkg/luasocket-2.0.2$ lua
Lua 5.1.5  Copyright (C) 1994-2012 Lua.org, PUC-Rio
&amp;gt;  print(package.path)
4;./?.lua;/usr/local/share/lua/5.1/?.lua;/usr/local/share/lua/5.1/?/init.lua;/usr/local/lib/lua/5.1/?.lua;/usr/local/lib/lua/5.1/?/init.lua;
&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，随便加的环境变量&amp;rdquo;4;&amp;ldquo;写在了package.path中。&lt;/p&gt;

&lt;p&gt;而为什么4需要两个&amp;rsquo;；&amp;rsquo;号呢：文件路径以 &amp;ldquo;;&amp;rdquo; 号分隔，最后的 2 个 &amp;ldquo;;;&amp;rdquo; 表示新加的路径后面加上原来的默认路径。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;huang@ThinkPad-X220:~/workspace/luapkg/luasocket-2.0.2$ export LUA_PATH=&amp;quot;4;&amp;quot;
huang@ThinkPad-X220:~/workspace/luapkg/luasocket-2.0.2$ lua
Lua 5.1.5  Copyright (C) 1994-2012 Lua.org, PUC-Rio
&amp;gt; print(package.path)
4;
&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见如果只有一个；号，将只采用这个分号。&lt;/p&gt;

&lt;p&gt;如果找过目标文件，则会调用 package.loadfile 来加载模块。否则，就会去找 C 程序库。搜索的文件路径是从全局变量 package.cpath 获取，而这个变量则是通过环境变量 LUA_CPATH 来初始。搜索的策略跟上面的一样，只不过现在换成搜索的是 so 或 dll 类型的文件。如果找得到，那么 require 就会通过 package.loadlib 来加载它。&lt;/p&gt;

&lt;p&gt;我们也可以在lua代码中&lt;a href=&#34;https://github.com/rtsisyk/luafun&#34;&gt;动态修改package.path变量&lt;/a&gt;，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;package.path = &amp;quot;../?.lua;&amp;quot;..package.path
require &amp;quot;fun&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这点对于我们自己的lua project的设置来说无疑是很方便的。
&lt;a href=&#34;http://www.runoob.com/lua/lua-modules-packages.html&#34;&gt;参考链接&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;cpp调用c函数:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;cpp调用c函数&lt;/h2&gt;

&lt;p&gt;由于CPP在链接时与C不太一样，因此在调用C函数时，&lt;a href=&#34;http://www.cnblogs.com/skynet/archive/2010/07/10/1774964.html&#34;&gt;需要做一定处理。&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;将C函数的声明房子 &lt;strong&gt;&lt;em&gt;#ifdef __cplusplus&lt;/em&gt;&lt;/strong&gt; 块中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#ifdef __cplusplus
extern &amp;quot;C&amp;quot; {
#endif
 
/*.
 * c functions declarations
..*/

#ifdef __cplusplus
}
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;多少人在猜你机器的密码呢:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;多少人在猜你机器的密码呢&lt;/h2&gt;

&lt;p&gt;VPS在公网就是个待宰的肥肉，都想去登陆，那&lt;a href=&#34;https://plus.google.com/+AlbertSu2015/posts/Uu1vbeJY1Hw&#34;&gt;都谁猜我的IP了呢？&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo grep &amp;quot;Failed password for root&amp;quot; /var/log/auth.log | awk &#39;{print $11}&#39; | sort | uniq -c | sort -nr | more
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;grep的简单使用-与-或-非:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;grep的简单使用，与 或 非&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;或操作&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;grep -E &#39;123|abc&#39; filename  // 找出文件（filename）中包含123或者包含abc的行
egrep &#39;123|abc&#39; filename    // 用egrep同样可以实现
awk &#39;/123|abc/&#39; filename   // awk 的实现方式
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;与操作&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;grep pattern1 files | grep pattern2 ：显示既匹配 pattern1 又匹配 pattern2 的行。
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;其他操作&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
grep -i pattern files ：不区分大小写地搜索。默认情况区分大小写，
grep -l pattern files ：只列出匹配的文件名，
grep -L pattern files ：列出不匹配的文件名，
grep -w pattern files ：只匹配整个单词，而不是字符串的一部分（如匹配‘magic’，而不是‘magical’），
grep -v pattern files ：不匹配pattern
grep -C number pattern files ：匹配的上下文分别显示[number]行，
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;iptables的简单使用:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;iptables的简单使用&lt;/h2&gt;

&lt;p&gt;其实并不想写iptables相关的内容，因为用的不熟，但是一些常用的命令还是记一下吧&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://linux.cn/article-1586-1.html&#34;&gt;iptables的详细解释&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Linux系统中,防火墙(Firewall),网址转换(NAT),数据包(package)记录,流量统计,这些功能是由Netfilter子系统所提供的，而iptables是控制Netfilter的工具。iptables将许多复杂的规则组织成成容易控制的方式，以便管理员可以进行分组测试，或关闭、启动某组规则。
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;https://blog.phpgao.com/vps_iptables.html
http://www.tabyouto.com/bandwagon-vps-for-shadowsocks-was-hacked.html
http://my.oschina.net/yqc/blog/82111?fromerr=VxVIazGW
http://www.vpser.net/security/linux-iptables.html
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 列出所有规则
iptables -L -n

# 更新iptables规则，规则写在/etc/iptables.rules
iptables-restore &amp;lt; /etc/iptables.rules

# 保存iptables规则，规则写在/etc/iptables.rules
iptables-save &amp;gt; /etc/iptables.rules

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的是Debian/Ubuntu上iptables是不会保存规则的。&lt;/p&gt;

&lt;p&gt;需要按如下步骤进行，让网卡关闭是保存iptables规则，启动时加载iptables规则：&lt;/p&gt;

&lt;p&gt;创建/etc/network/if-post-down.d/iptables 文件，添加如下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash
iptables-save &amp;gt; /etc/iptables.rules
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行：chmod +x /etc/network/if-post-down.d/iptables 添加执行权限。&lt;/p&gt;

&lt;p&gt;创建/etc/network/if-pre-up.d/iptables 文件，添加如下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash
iptables-restore &amp;lt; /etc/iptables.rules
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行：chmod +x /etc/network/if-pre-up.d/iptables 添加执行权限。&lt;/p&gt;

&lt;p&gt;iptables的一些常用规则：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#允许ping
iptables -A INPUT -p icmp -m icmp --icmp-type 8 -j ACCEPT
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果想清空的话，先执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/sbin/iptables -P INPUT ACCEPT
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/sbin/iptables -F
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;vps简单的ssh登陆设置:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;VPS简单的ssh登陆设置&lt;/h2&gt;

&lt;p&gt;初次使用VPS，不懂得安全的重要性，直到扣款时候才心疼，这个时候，弱口令，密码登陆什么的，还是都放弃吧，只用ssh登陆，并且换一个自己的端口。&lt;a href=&#34;https://imququ.com/post/bandwagon-vps-and-basicly-usage.html&#34;&gt;参考链接&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;简单来说，任何一台主机想登陆VPS的主机都需要有本身的ssh公钥私钥&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd ~/.ssh/
ssh-keygen -t rsa -C &amp;quot;username@gmail.com&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后复制~/.ssh/id_rsa.pub中的内容，就是本机的公钥。&lt;/p&gt;

&lt;p&gt;将公钥添加到VPS服务器的/home/username/.ssh/authorized_keys中，本机就能以username用户名登陆VPS了&lt;/p&gt;

&lt;p&gt;然后在/etc/ssh/sshd_config中禁用禁用 VPS 的密码登录和 root 帐号登录，将以下两项改为no&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;PasswordAuthentication no
PermitRootLogin no

Port 11111

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;随后重启SSH服务&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo service ssh restart
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;vim删除空行:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;vim删除空行&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;从网页上copy下代码后，发现很多情况下有不想要的空行，非常影响阅读，通过&lt;a href=&#34;http://bbs.chinaunix.net/thread-510754-1-1.html&#34;&gt;vim的正则&lt;/a&gt;可以解决

&lt;ul&gt;
&lt;li&gt;Delete all blank lines (^ is start of line; \s* is zero or more whitespace characters; $ is end of line)&lt;/li&gt;
&lt;li&gt;删除所有空白行(^是行的开始，\s*是零个或者多个空白字符；$是行尾)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;:g/^\s*$/d
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ubuntu通过命令设置系统时间:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;ubuntu通过命令设置系统时间&lt;/h2&gt;

&lt;p&gt;在嵌入式开发中，在pcduino或者rpi板子上安装好linux后，系统时间是UTC时间1970年，对于有些软件来说可能影响安装，所以需要命令行修改date&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo date -s &amp;quot;13 DEC 2015 20:43&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ubuntu终端下中文设置:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;ubuntu终端下中文设置&lt;/h2&gt;

&lt;p&gt;在安装完ubuntu系统后，我们发现中文支持的不好，主要体现在locale的错误，&lt;a href=&#34;http://www.linuxidc.com/Linux/2015-08/122501.htm&#34;&gt;解决方法：&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;perl: warning: Setting locale failed.
perl: warning: Please check that your locale settings:
	LANGUAGE = (unset),
	LC_ALL = (unset),
	LC_PAPER = &amp;quot;zh_CN.UTF-8&amp;quot;,
	LC_ADDRESS = &amp;quot;zh_CN.UTF-8&amp;quot;,
	LC_MONETARY = &amp;quot;zh_CN.UTF-8&amp;quot;,
	LC_NUMERIC = &amp;quot;zh_CN.UTF-8&amp;quot;,
	LC_TELEPHONE = &amp;quot;zh_CN.UTF-8&amp;quot;,
	LC_IDENTIFICATION = &amp;quot;zh_CN.UTF-8&amp;quot;,
	LC_MEASUREMENT = &amp;quot;zh_CN.UTF-8&amp;quot;,
	LC_TIME = &amp;quot;zh_CN.UTF-8&amp;quot;,
	LC_NAME = &amp;quot;zh_CN.UTF-8&amp;quot;,
	LANG = &amp;quot;en_US.UTF-8&amp;quot;
    are supported and installed on your system.
perl: warning: Falling back to the standard locale (&amp;quot;C&amp;quot;).

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是因为中文包没有安装好的缘故，如下命令就可以解决：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;添加简体中文支持
sudo apt-get -y install language-pack-zh-hans language-pack-zh-hans-base

添加繁体中文支持
sudo apt-get -y install language-pack-zh-hant language-pack-zh-hant-base

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果还不行，先观察下locale的配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;huang@localhost:~$ locale
locale: Cannot set LC_CTYPE to default locale: No such file or directory
locale: Cannot set LC_MESSAGES to default locale: No such file or directory
locale: Cannot set LC_ALL to default locale: No such file or directory
LANG=en_US.UTF-8
LANGUAGE=
LC_CTYPE=&amp;quot;en_US.UTF-8&amp;quot;
LC_NUMERIC=zh_CN.UTF-8
LC_TIME=zh_CN.UTF-8
LC_COLLATE=&amp;quot;en_US.UTF-8&amp;quot;
LC_MONETARY=zh_CN.UTF-8
LC_MESSAGES=&amp;quot;en_US.UTF-8&amp;quot;
LC_PAPER=zh_CN.UTF-8
LC_NAME=zh_CN.UTF-8
LC_ADDRESS=zh_CN.UTF-8
LC_TELEPHONE=zh_CN.UTF-8
LC_MEASUREMENT=zh_CN.UTF-8
LC_IDENTIFICATION=zh_CN.UTF-8
LC_ALL=
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再重新配置下语言包&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;huang@localhost:~$  sudo locale-gen &amp;quot;en_US.UTF-8&amp;quot;
Generating locales...
  en_US.UTF-8... done
Generation complete.
huang@localhost:~$ sudo  pip install shadowsocks^C
huang@localhost:~$  sudo locale-gen &amp;quot;zh_CN.UTF-8&amp;quot;
Generating locales...
  zh_CN.UTF-8... done
Generation complete.
huang@localhost:~$ sudo dpkg-reconfigure locales
Generating locales...
  en_US.UTF-8... done
  zh_CN.UTF-8... up-to-date
  zh_HK.UTF-8... done
  zh_SG.UTF-8... done
  zh_TW.UTF-8... done
Generation complete.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般就都能解决&lt;/p&gt;

&lt;h2 id=&#34;linux终端下的颜色设置输出:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;Linux终端下的颜色设置输出&lt;/h2&gt;

&lt;p&gt;Linux终端下，如果有一个彩色的终端，可以明显提升人的阅读兴趣，通过printf的简单设置即可&lt;a href=&#34;http://www.w2bc.com/Article/39141&#34;&gt;实现彩色输出&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;\033[显示方式;前景色;背景色m

    显示方式、前景色、背景色至少一个存在即可。
    格式：\033[显示方式;前景色;背景色m
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;前景色  背景色  颜色
30  40  黑色
31  41  红色
32  42  绿色
33  43  黃色
34  44  蓝色
35  45  紫红色
36  46  青蓝色
37  47  白色


显示方式    意义
0   终端默认设置
1   高亮显示
4   使用下划线
5   闪烁
7   反白显示
8   不可见

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;\033[1;31;40m    &amp;lt;!--1-高亮显示 31-前景色红色  40-背景色黑色--&amp;gt;
\033[0m          &amp;lt;!--采用终端默认设置，即取消颜色设置--&amp;gt;

printf(&amp;quot;\033[1;31;40m&amp;quot;);
printf(&amp;quot;\033[0m&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;tsar监控系统负载和nginx运行情况:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;tsar监控系统负载和nginx运行情况&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/alibaba/tsar&#34;&gt;tsar&lt;/a&gt;是阿里巴巴发布的一款能够实时监控系统状态的命令行工具，并且支持第三方模块扩展，其中比较注明的是nginx模块。使用tsar时，可以将系统负载和nginx运行情况同步同时打出，可以用来定位系统瓶颈，所以广受好评。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;tsar -li1&lt;/em&gt;&lt;/strong&gt; 是其最经典的用法，可以将一般我们感兴趣的监控项每秒更新一次并输出&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Time              ---cpu-- ---mem-- ---tcp-- -----traffic---- --sda---  ---load- 
Time                util     util   retran    bytin  bytout     util     load1   
25/03/16-19:03:30   0.08    10.22     0.00     1.4K    1.2K     0.00     0.33  
25/03/16-19:03:31   0.08    10.21     0.00   424.00  468.00     0.00     0.33   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果想使能nginx模块，需要对其进行配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;1. mkdir /etc/tsar/conf.d
2. touch /etc/tsar/conf.d/nginx.conf

3. 写入如下内容并保存
mod_nginx on

####add it to tsar default output
output_stdio_mod mod_nginx

####add it to center db
#output_db_mod mod_nginx

####add it to nagios send
####set nagios threshold for alert
#output_nagios_mod mod_nginx

#threshold nginx.value1;N;N;N;N;
#threshold nginx.value2;N;N;N;N;
#threshold nginx.value3;N;N;N;N;

表示使能nginx模块，并使用stdio输出

4. tsar -li1

Time              ---cpu-- ---mem-- ---tcp-- -----traffic---- --sda---  ---load- ------------------nginx----------------- 
Time                util     util   retran    bytin  bytout     util     load1      qps      rt  sslqps  spdyps  sslhst   
25/03/16-19:06:19   0.08    11.40     7.14   302.00  546.00     0.00     0.02     1.00    0.00    0.00    0.00    0.00   

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;wrk在centos系统上的编译方法:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;wrk在CentOS系统上的编译方法&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/wg/wrk&#34;&gt;wrk&lt;/a&gt;作为一款可以内嵌lua脚本的，支持多线程的压测工具，受到了广泛欢迎。在高版本CentOS 7上，直接在wrk目录下执行make，可以首先编译deps/luajit，得到deps/luajit/libluajit.a，然而在低版本上，CentOS 6.5系统中，会报一些莫名奇妙的错误。&lt;/p&gt;

&lt;p&gt;解决方法是，查看wrk的Makefile，发现wrk依赖于luajit，那么首先进入deps/luajit编译它，并且是静态编译&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd wrk
cd deps/luajit
make -j24 BUILDMODE=static

cd ../..
make -j24

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;rpmbuild环境的快速初始化:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;rpmbuild环境的快速初始化&lt;/h2&gt;

&lt;p&gt;需要将代码打包为CentOS的RPM包时，可以先自己在本地新建一个环境&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;1. mkdir -p ~/rpmbuild/{SOURCES,BUILD,BUILDROOT,RPMS,SRPMS,SPECS}
2. 将代打包的代码压缩包 software.tar.gz 放入SOURCES文件夹
3. 将 software.spec 放入SPECS文件夹
4. rpmbuild -ba path/to/software.spec 即可
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;git记住密码-不用每次都输密码才登入:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;git记住密码，不用每次都输密码才登入&lt;/h2&gt;

&lt;p&gt;git有两种方式，一种是ssh方式，配置公钥私钥，对于新手而言还是比较麻烦的；另一种是http方式，这里有一个办法可以让git记住密码，避免每次都需要输入密码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;1. touch ~/.git-credentials
2. 将  https://{username}:{password}@github.com  写入该文件
3. git config --global credential.helper store  就可以使得git记住密码了
4. 此时查看 ~/.gitconfig，发现多了一项
    
    [credential] 
    helper = store 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;centos系统上某些软件-比如gcc-python等版本过低的解决方案:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;centos系统上某些软件，比如gcc、python等版本过低的解决方案&lt;/h2&gt;

&lt;p&gt;在CentOS Server上，经常会遇到某些软件依赖版本过低的问题，比如CentOS 6.5的python是2.7版本的，gcc是4.2版本的，那么我们如何获得一个干净的、与原版本无冲突的运行环境呢。CentOS系提供了一个叫SCL的工具，可以帮我们实现目的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sudo wget http://people.centos.org/tru/devtools-1.1/devtools-1.1.repo -P /etc/yum.repos.d
$ sudo sh -c &#39;echo &amp;quot;enabled=1&amp;quot; &amp;gt;&amp;gt; /etc/yum.repos.d/devtools-1.1.repo&#39;
$ sudo yum install devtoolset-1.1
$ scl enable devtoolset-1.1 bash
$ gcc --version
# 通过devtoolset工具可以暂时提高gcc版本，而不更改之前服务器的配置，这个很有效果，高版本的gcc会智能保留symbol。
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# CentOS 6.5
sudo yum install centos-release-SCL
sudo yum install python27
scl enable python27 bash
python --version
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ubuntu系统上某些软件-比如gcc等版本过高的解决方案:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;ubuntu系统上某些软件，比如gcc等版本过高的解决方案&lt;/h2&gt;

&lt;p&gt;与CentOS相反，debian系发行版的软件版本都很高，Ubuntu 16.04的gcc 版本已经到了5.2，然而编译一些早期linux内核的话，需要gcc-4.7左右的版本，这时候我们怎么办呢，有两个方法：
* 通过apt安装低版本gcc
    * sudo apt-get install gcc-4.7
    * 在编译linux 内核时， make CC=gcc-4.7 即可
* update-alternatives可以帮忙更改符号链接，指向不同版本的gcc
    * &lt;a href=&#34;http://www.metsky.com/archives/607.html&#34;&gt;参考链接1&lt;/a&gt;
    * &lt;a href=&#34;http://blog.csdn.net/zyxlinux888/article/details/6708775&#34;&gt;参考链接2&lt;/a&gt; &lt;a href=&#34;http://blog.csdn.net/zyxlinux888/article/details/6709036&#34;&gt;附赠&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;python的matplotlib库实现绘制图标:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;python的matplotlib库实现绘制图标&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;sudo apt-get install python-matplotlib&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://matplotlib.org/index.html&#34;&gt;参考链接&lt;/a&gt;
&lt;a href=&#34;http://matplotlib.org/examples/index.html&#34;&gt;example&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;python使用requests库发送http请求:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;python使用requests库发送http请求&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://cn.python-requests.org/zh_CN/latest/user/quickstart.html#json&#34;&gt;参考链接&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;python解析命令行参数-argparse:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;python解析命令行参数：argparse&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.xiayf.cn/2013/03/30/argparse/&#34;&gt;参考链接&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;git比较两次commit的差异:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;git比较两次commit的差异&lt;/h2&gt;

&lt;p&gt;通过比较两次commit的代码差异，能够快速理解此次commit的目的，理解作者意图&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;git log

&lt;ul&gt;
&lt;li&gt;查看commit历史&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;commit 2279c3f4a8a42e696a0f34e6e9b6289487da92c1
Author: bg2bkk &amp;lt;bg2bkk@gmail.com&amp;gt;
Date:   Sun Mar 13 09:12:26 2016 +0800

    add SO_REUSEADDR和SO_REUSEPORT.md

commit 2b9d85f8427c5ca9e4f9c128c22acd280eb94405
Author: bg2bkk &amp;lt;bg2bkk@gmail.com&amp;gt;
Date:   Sat Mar 12 01:16:00 2016 +0800

    add 采用二级指针实现单链表操作 单链表翻转 删除单链表结点
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;git diff commit 2279c3f4a8a42e696a0f34e6e9b6289487da92c1 2b9d85f8427c5ca9e4f9c128c22acd280eb94405&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;git返回强制返回某次提交:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;git返回强制返回某次提交&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;git log&lt;/li&gt;
&lt;li&gt;git reset 5f4769a98985b5acfea45462df27830e51a75145 &amp;ndash;hard

&lt;ul&gt;
&lt;li&gt;可见commit号很重要&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;iptables允许端口被外网访问:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;iptables允许端口被外网访问&lt;/h2&gt;

&lt;p&gt;防火墙设置，配置1985端口可以被外网访问&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;sudo iptables -A INPUT -m state &amp;ndash;state NEW -m tcp -p tcp &amp;ndash;dport 1985 -j ACCEPT&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;tcpdump过滤指定标志的packet:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;tcpdump过滤指定标志的packet&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# tcp包里有个flags字段表示包的类型，tcpdump可以根据该字段抓取相应类型的包：
# tcp[13] 就是 TCP flags (URG,ACK,PSH,RST,SYN,FIN)
# Unskilled 32
# Attackers 16
# Pester     8
# Real       4
# Security   2
# Folks      1

#抓取fin包：
tcpdump -ni any port 9001 and &#39;tcp[13] &amp;amp; 1 != 0 &#39; -s0  -w fin.cap -vvv
#抓取syn+fin包：
tcpdump -ni any port 9001 and &#39;tcp[13] &amp;amp; 3 != 0 &#39; -s0  -w syn_fin.cap -vvv
#抓取rst包：
tcpdump -ni any port 9001 and &#39;tcp[13] &amp;amp; 4 != 0 &#39; -s0  -w rst.cap -vvv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://babyhe.blog.51cto.com/1104064/1395489&#34;&gt;参考链接&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;查看进程的内存占用情况:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;查看进程的内存占用情况&lt;/h2&gt;

&lt;p&gt;用Ternary Search Tree代替Trie Tree后，我想知道我的进程内存占用有多大区别。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ps -e -o &amp;lsquo;pid,comm,args,pcpu,rsz,vsz,stime,user,uid&amp;rsquo; | grep MyDict&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;rsz是实际占用内存，单位是KB&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;pmap -d pid&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>New evolvement of Epoll</title>
      <link>https://bg2bkk.github.io/post/New%20Evolvement%20of%20Epoll/</link>
      <pubDate>Tue, 22 Mar 2016 01:48:41 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/New%20Evolvement%20of%20Epoll/</guid>
      <description>

&lt;h2 id=&#34;epoll在linux-内核中的新发展:b489f0f2178b22438ad2d1ac9c25dd2c&#34;&gt;EPOLL在linux 内核中的新发展&lt;/h2&gt;

&lt;p&gt;Epoll是linux专有的系统调用，用于快速地高效轮询大规模文件描述符fd。这个API在kernel-2.5版本时就已经合并，并使用至今。即使如此，epoll和其他接口一样，仍然有提升空间。现在有两个patch为epoll系列系统调用添加了新的功能。&lt;/p&gt;

&lt;h2 id=&#34;epoll概述:b489f0f2178b22438ad2d1ac9c25dd2c&#34;&gt;epoll概述&lt;/h2&gt;

&lt;p&gt;epoll的功能与select或者poll类似，但是epoll在应对轮询处理大规模文件描述符时拥有更灵活的选项和更高的性能。每次调用select和poll，都会将被轮询的fd集合复制，生成新的fd集合，所以内核需要检查每一个描述符是否合法，是否IO就绪，然后将执行监听的进程添加到相应的唤醒等待队列。但实际上，一般情况下，在两次select或者poll调用之间，有事件产生的fd并不多，所以对每个fd都进行前述流程实际上有很多不必要的重复性操作。Epoll将设置被监听fd和轮询fd是否就绪这两个任务分开，从而解决这一问题。&lt;/p&gt;

&lt;p&gt;使用epoll的话，必须首先新建epoll fd用于轮询，新建epfd通过如下调用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;    #include &amp;lt;sys/poll.h&amp;gt;

    int epoll_create(int size);
    int epoll_create1(int flags);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;两者都返回epoll fd，而epoll_create()的size参数已经不再有意义，epoll_create1()的flag参数可以设置epfd的CLOSE_ON_EXEC标志。&lt;/p&gt;

&lt;p&gt;第二步是添加所有被监听的fd，通过调用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;    int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参数op是EPOLL_CTL_ADD时，fd将被添加进epfd轮询的fd集合中，event参数用于指定哪个类型的事件被轮询，读事件、写事件或者其他事件，详情参考&lt;a href=&#34;http://man7.org/linux/man-pages/man2/epoll_ctl.2.html&#34;&gt;man page&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;最后，等待集合中fd是否就绪的工作由以下函数实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;    int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
    int epoll_pwait(int epfd, struct epoll_event *events, int maxevents, 
                                                int timeout, const sigset_t *sigmask);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有事件发生时，epoll_wait将返回，产生的时间存在参数events中，最多maxevents个事件。如果timeout时间内没有事件发生，epoll_wait也将返回，timeout的单位是ms。epoll_pwait可以使用信号集sigmask来屏蔽特定信号，可以使应用程序安全的等待fd就绪或者捕获信号。二者的关系和select与pselect关系一样。&lt;/p&gt;

&lt;h2 id=&#34;patch-1-epoll-ctl-batch-和-epoll-pwait1:b489f0f2178b22438ad2d1ac9c25dd2c&#34;&gt;patch 1：epoll_ctl_batch() 和 epoll_pwait1()&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lwn.net/Articles/633195/&#34;&gt;Fam Zheng为epoll引入了两个新的系统调用&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;Fam的第一个系统调用是&lt;strong&gt;&lt;em&gt;epoll_ctl_batch&lt;/em&gt;&lt;/strong&gt;，用来解决一个性能问题：每次调用epoll_ctl，都只能添加、修改和删除一个fd，如果有大量fd需要修改，那么需要调用相应次数的epoll_ctl来实现，这会导致大量系统调用发生，而这个场景却是经常发生的。Fam引入的epoll_ctl_batch()通过在一个系统调用中添加多个fd来解决这个问题：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;    int epoll_ctl_batch(int epfd, int flags, int ncmds, struct epoll_ctl_cmd *cmds);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结构体epoll_ctl_cmd用于描述一个待添加的事件，可以看作是epoll_ctl参数的一次打包：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct epoll_ctl_cmd {
      /* Reserved flags for future extension, must be 0. */
      int flags;
      /* The same as epoll_ctl() op parameter. */
      int op;
      /* The same as epoll_ctl() fd parameter. */
      int fd;
      /* The same as the &amp;quot;events&amp;quot; field in struct epoll_event. */
      uint32_t events;
      /* The same as the &amp;quot;data&amp;quot; field in struct epoll_event. */
      uint64_t data;
      /* Output field, will be set to the return code after this
       * command is executed by kernel */
      int result;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将一个epoll_ctl_cmd数组cmds传入，则epoll_ctl_batch可以在一次系统调用中添加多个fd。&lt;/p&gt;

&lt;p&gt;Fam的第二个系统调用是&lt;strong&gt;&lt;em&gt;epoll_pwait1&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;    struct epoll_wait_params{
        int clockid;
        struct timespec timeout;
        sigset_t *sigmask;
        size_t sigsetsize;
    }

    int epoll_pwait(int epfd, int flags, struct epoll_event *events, int maxevents, 
                                                struct epoll_wait_params *params);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;本版本的epoll_pwait1()添加了一个flags参数，但是并未定义任何flag值，所以flags置为0即可。其他参数，包括时间控制、信号屏蔽设置，都写在params参数中，目的是为应用程序提供更精细的时间控制。对于epoll_wait()来说，毫秒级的时钟分辨率已经被证明在一些场景中过于粗糙，新的系统供调用提供了纳秒级别的精度，解决了这个问题。&lt;/p&gt;

&lt;h2 id=&#34;patch2-多线程环境下更好的性能-解决-惊群-问题:b489f0f2178b22438ad2d1ac9c25dd2c&#34;&gt;patch2: 多线程环境下更好的性能，解决“惊群”问题&lt;/h2&gt;

&lt;p&gt;Jason Baron（Akamai公司）主要解决一个相对来说不那么常见的场景下，epoll现有的一个问题。通常情况下，一个给定的fd只被一个进程轮询，但是在Jason的场景中，会有多个进程轮询同一个fd集合。在这个场景设定下，一个fd有事件产生时将会唤醒所有监听进程，即使最后只有一个进程能够得到处理该事件的机会，这就是所谓的“惊群”问题。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://lwn.net/Articles/632590/&#34;&gt;Jason的解决方案&lt;/a&gt;是通过epoll_ctl向被轮询的fd再添加两个新的flag，第一个是&lt;strong&gt;&lt;em&gt;EPOLLEXCLUSIVE&lt;/em&gt;&lt;/strong&gt;，保证只有一个进程能被唤醒然后处理事件。该flag使得，有事件发生时，简单的用add_wait_queue_exclusive()代替add_wait_queue()，互斥的将进程放入等待队列中。很明显，所有轮询同一个fd的进程都要使用互斥模式来实现只有一个进程唤醒的效果。&lt;/p&gt;

&lt;p&gt;不过，这个变化没有完全解决问题，因为这会导致当有事件发生时，唤醒的都是同一个进程。由于Epoll存在的一个原因是，在两次epoll_wait()调用之间,，进程能留在epfd的等待唤醒队列中，处于等待队列头部的进程仍然在队列头部，所以这个进程将被唤醒并处理所有互斥模式的fd（这句翻译我有疑问）。但是我们的目的是，多个进程轮询同一fd集合时，能够散开执行，而每次都唤醒的是同一个进程与此相悖。为解决这个问题，Jason添加了另一个flag，叫做 EPOLLROUNDROBIN，使得内核按顺序处理唤醒每个进程。&lt;/p&gt;

&lt;p&gt;引入一个新的等待队列函数用来支持实现这种方式&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;    void add_wait_queue_rr(wait_queue_head_t *q, wait_queue_t *wait);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用该函数后，当wait返回时，只有一个进程被唤醒，效果和add_wait_queue_exclusive()一样。但是，这个被唤醒的进程，将被从队列头移到队列尾，直到它前面的所有进程都得到唤醒机会后，才能再次被唤醒。&lt;/p&gt;

&lt;p&gt;Jason的提交patch的同时也提交了一个用于压测的程序，压测结果显示，互斥模式使得执行时间降低了50%，当有大量的唤醒发生时，“惊群”效应带来的性能损耗就不会发生了。&lt;/p&gt;

&lt;h2 id=&#34;结语:b489f0f2178b22438ad2d1ac9c25dd2c&#34;&gt;结语&lt;/h2&gt;

&lt;p&gt;以上提到的两个patch已经被多次review和comments，Fam的patch自从&lt;a href=&#34;https://lwn.net/Articles/630097/&#34;&gt;1月份提出&lt;/a&gt;后进行了多次修改。现在的编辑们对API相关的patch投入了越来越多的关注和审视，这是对的，因为API将会长期有效，(API lives forever),甚至是永远有效。所以最好在向用户推出之前就搞定所有bug，以提供永久支持的态度提交。这些patch目前看来已经接近就绪，可能将会在下一个窗口中合并。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>openresty学习过程中的一些tips</title>
      <link>https://bg2bkk.github.io/post/openresty%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9Btips/</link>
      <pubDate>Mon, 14 Mar 2016 16:36:14 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/openresty%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9Btips/</guid>
      <description>

&lt;h2 id=&#34;openresty中如何写redis或者mysql的wraper:d90c926ba9cb9e1e62be5d1b7a7aa7fb&#34;&gt;openresty中如何写redis或者mysql的wraper&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://zivn.me/2013/08/05/Something-about-Openresty/&#34;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;ngx-lua获取post字段参数:d90c926ba9cb9e1e62be5d1b7a7aa7fb&#34;&gt;ngx_lua获取post字段参数&lt;/h2&gt;

&lt;p&gt;在用户请求为POST方式时，如果想获取post中的各参数字段，比如post数据为 &amp;ldquo;uid=100&amp;amp;ip=10.13.112.53&amp;rdquo;，此时想获取该字段的话，可以调用&lt;a href=&#34;https://github.com/openresty/lua-nginx-module#ngxreqget_post_args&#34;&gt;ngx.req.get_post_args&lt;/a&gt;函数。按惯例返回table类型，post数据的各字段为table的key&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;function get_uid()
	local args = ngx.req.get_post_args()
	local uid = args[&#39;uid&#39;]
	return uid
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于HTTP的POST提交数据的方式，网上有很多讨论&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://imququ.com/post/four-ways-to-post-data-in-http.html&#34;&gt;四种常见的POST提交数据方式&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;application/x-www-form-urlencoded&lt;/li&gt;
&lt;li&gt;multipart/form-data&lt;/li&gt;
&lt;li&gt;application/json&lt;/li&gt;
&lt;li&gt;text/xml&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;HTTP &lt;a href=&#34;http://jaseywang.me/2012/03/03/http-headers-%E9%83%A8%E5%88%86%E5%AD%97%E6%AE%B5%E7%AC%94%E8%AE%B0/&#34;&gt;header头的一些字段&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ngx_lua同样提供了读写HTTP请求中&lt;a href=&#34;https://github.com/openresty/lua-nginx-module#ngxreqget_uri_args&#34;&gt;uri参数&lt;/a&gt;，读写HTTP请求中的&lt;a href=&#34;https://github.com/openresty/lua-nginx-module#ngxreqget_uri_args&#34;&gt;HEADER头部&lt;/a&gt;，这些在ngx_lua开发中为我们提供了丰富的工具，非常好的功能。&lt;/p&gt;

&lt;p&gt;最后回到主题，当我读出uid字段后，有时候会发现报错&amp;rdquo;requesty body in temp file not supported&amp;rdquo;，原因在于nginx会将用户请求的body字段缓存起来，如果超出缓存大小，则将用户body数据写到文件中；而ngx.req.get_post_args()是不支持从文件中读取数据的。因此解决办法是：适当加大 &lt;a href=&#34;http://wiki.nginx.org/HttpCoreModule#client_body_buffer_size&#34;&gt;nginx 的 client_body_buffer_size 配置&lt;/a&gt;, 当 client_body_buffer_size 配置为和 client_max_body_size 一样大时，nginx就不会把请求体缓冲到文件系统了（但也要仔细内存占用）。&lt;/p&gt;

&lt;p&gt;对于client_max_body_size来说，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Syntax:		client_max_body_size size;
Default:	client_max_body_size 1m;
Context:	http, server, location

Sets the maximum allowed size of the client request body, specified in the “Content-Length” request header field. If the size in a request exceeds the configured value, the 413 (Request Entity Too Large) error is returned to the client. Please be aware that browsers cannot correctly display this error. Setting size to 0 disables checking of client request body size.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;设置允许的client body最大值，对http server来说是种保护。&lt;/p&gt;

&lt;p&gt;对于client_body_buffer_size来说，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Syntax:		client_body_buffer_size size;
Default:	client_body_buffer_size 8k|16k;
Context:	http, server, location

Sets buffer size for reading client request body. In case the request body is larger than the buffer, the whole body or only its part is written to a temporary file. By default, buffer size is equal to two memory pages. This is 8K on x86, other 32-bit platforms, and x86-64. It is usually 16K on other 64-bit platforms.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果client body size大于默认值，则nginx将会把body缓存在文件中。将client body buffer size设置为和client_max_body_size一样大，nginx将不会把它写进文件中。&lt;/p&gt;

&lt;h2 id=&#34;ngx-lua中判断table为空:d90c926ba9cb9e1e62be5d1b7a7aa7fb&#34;&gt;ngx_lua中判断table为空&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;lua的table中，有两类kv，一类是以数字为index，比如{&amp;lsquo;abc&amp;rsquo;, &amp;lsquo;efg&amp;rsquo;}中，{k=1, v=abc}, {k=2, v=efg}，另一类以自己kv存储，比如{[&amp;lsquo;abc&amp;rsquo;] = &amp;lsquo;efg&amp;rsquo;}，k为abc的元素，v为efg&lt;/li&gt;
&lt;li&gt;#table中，#标识符是返回以数字为index的key，从1开始算，连续的key的数量&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local t = {}
t[1] = &#39;a&#39;
t[2] = &#39;b&#39;
t[20] = &#39;c&#39;

print(#t)
2
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;因此#号不能获得table的真实大小，也不能用于判断table是否为空&lt;/li&gt;
&lt;li&gt;table.maxn(tab)，maxn返回table中以数字为key的元素中，数字最大的那个&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local t = {}
t[1] = &#39;a&#39;
t[2] = &#39;b&#39;
t[20] = &#39;c&#39;

print(table.maxn(t))
20
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;next就是pairs遍历table时用来取下一个内容的函数，因此next(tab)可以用来判断table是否为空，如果next(tab)返回为nil的话，说明第一个元素不存在，所以该table为空&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://moonbingbing.gitbooks.io/openresty-best-practices/content/lua/not_nill.html&#34;&gt;参考链接&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;ngx-lua中的参数获得:d90c926ba9cb9e1e62be5d1b7a7aa7fb&#34;&gt;ngx_lua中的参数获得&lt;/h2&gt;

&lt;p&gt;ngx_lua中获得req参数有如下几个方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ngx.var.arg_city 获取city参数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;host:port/uri?city=abc    &lt;strong&gt;&lt;em&gt;ngx.var.arg_city = abc&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;host:port/uri?city=       &lt;strong&gt;&lt;em&gt;ngx.var.arg_city = &amp;ldquo;&lt;/em&gt;&lt;/strong&gt;, and its length is 0&lt;/li&gt;
&lt;li&gt;host:port/uri?city        &lt;strong&gt;&lt;em&gt;ngx.var.arg_city = nil&lt;/em&gt;&lt;/strong&gt;，cause it doesn&amp;rsquo;t exist yet&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ngx.req.get_headers()[&amp;lsquo;city&amp;rsquo;]，获取http请求头中的city参数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;host:port/uri -H &amp;lsquo;city:abc&amp;rsquo;   &lt;strong&gt;&lt;em&gt;结果为abc&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;host:port/uri -H &amp;lsquo;city:&amp;rsquo;      &lt;strong&gt;&lt;em&gt;结果为nil&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://groups.google.com/forum/#!topic/openresty/fQvG_TvDAvU&#34;&gt;thread&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;虽然init_worker_by_lua阶段不能使用cosocket，不过可以先通过一个timer（定时时间为0让其立即调用）来发出对外的socket io操作，以实现一些初始化的目的。&lt;/li&gt;
&lt;li&gt;openresty的两个缓存中，ngx shared dict是跨worker共享的，是一个单纯的kv缓存；预计接下来会有patch能够支持lpush等redis操作；lua-resty-lrucache是每个worker的Lua VM空间内缓存，不能跨worker共享，优点是可以存储所有lua对象，比如table，而不需要序列化和反序列化&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;worker 启动时，upstream 是空的，即 _M.data={}，所以这个时候是不能提供服务的。所以每次 reload config 都会导致一段时间内服务不可访问。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在 init_worker_by_lua 执行 cosocket 相关的 API 是不允许的（后期可能会添加支持），但可以调用标准 SOCKET 完成初始化加载，例如借助 luasocket 完成数据源获取并初始化 _M 。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不清楚 init_worker_by_lua 里是否可以进行文件操作？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;是可以的，这个确定。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在ngx lua性能分析方面，agentzh提出一系列的工具，主要是nginx-systemtap-toolkit和stapxx两个工程。我们使用的脚本，&lt;a href=&#34;https://groups.google.com/forum/#!topic/openresty/bOwgPymXQzg&#34;&gt;说明文档&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;引用：
	我们有一整套的基于 systemtap 的工具链可以用于在线或者离线的性能分析。 
	你的 nginx 进程的 CPU 使用率如果很高的话，可以使用 C 级别的 on-CPU 时间火焰图工具对你最忙的 nginx worker 进程进行采样： 
	    https://github.com/agentzh/nginx-systemtap-toolkit#sample-bt 
	如果你的 nginx 进程的 CPU 很低，但请求延时很高，则有两种可能： 
	1. 你的 nginx 阻塞在了某些阻塞的 IO 操作（比如文件 IO）或者系统的同步锁上，此时你可以使用 C 级别的 off-CPU 
	时间火焰图工具对某个典型的 nginx worker 进程进行采样： 
	   https://github.com/agentzh/nginx-systemtap-toolkit#sample-bt-off-cpu 
	如果你发现 Lua 代码占用了大部分的 CPU 时间，则可以进一步使用 ngx-lua-exec-time 工具加以确认： 
	    https://github.com/agentzh/stapxx#ngx-lua-exec-time 
	进一步地，你可以使用 Lua 代码级别的 on-CPU 火焰图工具在 Lua 层面上分析 CPU 时间的分布。如果你使用的是 LuaJIT 
	2.0.x，则可以使用下面这个工具进行采样： 
	    https://github.com/agentzh/nginx-systemtap-toolkit#ngx-sample-lua-bt 
	如果你使用的是 LuaJIT 2.1，则可以使用 lj-lua-stacks 工具进行采样： 
	    https://github.com/agentzh/stapxx#lj-lua-stacks 
	2. 你的 nginx 通过 ngx_lua 的 cosocket 或者 ngx_proxy 这样的 upstream 
	模块和上游服务进行通信时，上游服务的延时过大。此时你可以分别使用 
	ngx-lua-tcp-recv-time、ngx-lua-udp-recv-time 以及 ngx-single-req-latency 
	工具进行分析： 
	    https://github.com/agentzh/stapxx#ngx-lua-tcp-recv-time 
	    https://github.com/agentzh/stapxx#ngx-lua-udp-recv-time 
	    https://github.com/agentzh/stapxx#ngx-single-req-latency  



    - 我们主要使用四个工具来生成火焰图以分析性能，sample-bt、sample-bt-off-cpu、ngx-sample-lua-bt 和 lj-lua-stacks。
    - 实际使用中命令：
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;1、sudo ./sample-bt -p 8736 -t 20 -u -a &#39;-DMAXSKIPPED=10000&#39; &amp;gt; a.bt
2、sudo ./sample-bt-off-cpu -p 8736 -t 20 -u &amp;gt; b.bt
3、sudo ./ngx-sample-lua-bt --luajit20 -p 44252 -t 20 &amp;gt; c.bt
4、sudo ./samples/lj-lua-stacks.sxx --skip-badvars -x 44250 -I tapset/ &amp;gt; d.bt
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;- 通过a.bt生成火焰图
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;	../FlameGraph/stackcollapse-stap.pl a.bt | ../FlameGraph/flamegraph.pl &amp;gt; a.svg
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;- 通过脚本ngx-lua-conn-pools来追踪ngx lua connection pool的工作情况。        
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;    sudo ./ngx-lua-conn-pools  --luajit20 -p 28261
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>coroutine and goroutine</title>
      <link>https://bg2bkk.github.io/post/coroutine%20and%20goroutine/</link>
      <pubDate>Sun, 13 Mar 2016 17:59:29 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/coroutine%20and%20goroutine/</guid>
      <description>

&lt;h4 id=&#34;协程是什么-what-is-coroutine:1a17fb99183985490e9adefe8aecc78f&#34;&gt;协程是什么？ what is coroutine ?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Coroutine&#34;&gt;协程的概念&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;Coroutines are computer program components that generalize subroutines for nonpreemptive multitasking, by allowing multiple entry points for suspending and resuming execution at certain locations. Coroutines are well-suited for implementing more familiar program components such as cooperative tasks, exceptions, event loop, iterators, infinite lists and pipes.&lt;/p&gt;

&lt;p&gt;According to Donald Knuth, the term coroutine was coined by Melvin Conway in 1958, after he applied it to construction of an assembly program.[1] The first published explanation of the coroutine appeared later, in 1963.[2]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;协程是为实现非抢占式多任务而提出的计算机子程序，通过提供多个程序入口使得程序可以在特定地址挂起和恢复执行。协程天生的支持实现常见程序组件，比如协作式任务、异常、时间循环、迭代器、无边界列表和管道等。&lt;/p&gt;

&lt;p&gt;根据祖师爷高纳德节说，协程的概念由Melvin Conway在1958年提出，随后他将协程应用在编写汇编程序上。协程的第一个公开发表的解释出现在1963年。&lt;/p&gt;

&lt;p&gt;可见协程的概念比多线程还早，而且按照Knuth的说法，&lt;a href=&#34;http://coolshell.cn/articles/10975.html&#34;&gt;”子例程是协程的特例“，一次子例程调用就是一次子函数调用&lt;/a&gt;，协程是类函数一样的组件，我们可以在单线程中创建N多个协程，只要内存够用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 协程与子例程的[区别](https://en.wikipedia.org/wiki/Coroutine)
    * 子例程只有一个调用入口起点，子例程退出后，执行结束；子例程只返回一次，在两次调用之间不保存状态；
    * 协程有多个入口，调用起始点、或者从上一次返回点接着执行；从协程自己的角度来看，他放弃执行时不是退出，而是去调用另一个协程，或者说将CPU主动让给另一个协程；协程保存状态;
        * 计算机科学中，[yield](https://en.wikipedia.org/wiki/Yield_(multithreading))用于使处理器放弃当前运行的线程thread，并将它放入运行队列的末尾
        * 协程coroutine中的yield需要显式调用
    * 每个子例程可以转换为一个不带yield的协程
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;协程有关的四个概念：&lt;a href=&#34;https://en.wikipedia.org/wiki/Coroutine&#34;&gt;coroutine&lt;/a&gt;、&lt;a href=&#34;https://en.wikipedia.org/wiki/Yield_(multithreading&#34;&gt;yield&lt;/a&gt;、&lt;a href=&#34;https://en.wikipedia.org/wiki/Continuation&#34;&gt;Continuation&lt;/a&gt;、&lt;a href=&#34;https://en.wikipedia.org/wiki/Cooperative_multitasking&#34;&gt;cooperative multitasking&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Call_stack#Unwinding&#34;&gt;call stack&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html&#34;&gt;Coroutines in C&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.hawkwithwind.net/blog/2011/02/18/%E5%8D%8F%E7%A8%8B%E7%9A%84c%E5%AE%9E%E7%8E%B0/&#34;&gt;给你一个直观的认识&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
int function(void) {
	static int i, state = 0;
	switch (state) {
		case 0: goto LABEL0;
		case 1: goto LABEL1;
	}
LABEL0: /* start of function */
	for (i = 0; i &amp;lt; 10; i++) {
		printf(&amp;quot;\t\t\ti = %d\n&amp;quot;, i);
		state = 1; /* so we will come back to LABEL1 */
		return i;
LABEL1:
		; /* resume control straight after the return */
	}
}

int main(){
	int j = 0;
	for ( j = 0; j &amp;lt; 21; j++){
		printf(&amp;quot;j = %d, func = %d\n&amp;quot;, j, function());
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;			i = 0
j = 0, func = 0
			i = 1
j = 1, func = 1
			i = 2
j = 2, func = 2
			i = 3
j = 3, func = 3
			i = 4
j = 4, func = 4
			i = 5
j = 5, func = 5
			i = 6
j = 6, func = 6
			i = 7
j = 7, func = 7
			i = 8
j = 8, func = 8
			i = 9
j = 9, func = 9
j = 10, func = 10
j = 11, func = 11
j = 12, func = 12
j = 13, func = 13
j = 14, func = 14
j = 15, func = 15
j = 16, func = 16
j = 17, func = 17
j = 18, func = 18
j = 19, func = 19
j = 20, func = 20
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;执行结果分析&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;变量i 和 state 都是 static类型的，是文件全局作用域的&lt;/li&gt;
&lt;li&gt;首次执行function函数时，state = 0，goto 到 LABEL0，然后进行正常循环和返回&lt;/li&gt;
&lt;li&gt;当function调用次数超过十次后，每次进入function函数内部时，由switch分发到LABEL1；执行完循环体后，对i增1，然后进行判断是否 i &amp;lt; 10，发现不满足，退出程序&lt;/li&gt;
&lt;li&gt;可能我们会比较纠结function程序在 i &amp;gt; 10后不再执行return i语句，为什么还会返回自增后的结果呢？

&lt;ul&gt;
&lt;li&gt;说实话我也并不能很好解释。我通过查看汇编代码，发现仍然会执行将i值转到ecx寄存器，我们的function返回值就从ecx拿到的。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;return在这里并不是返回的意思，而是yield的意思&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;仍然有两种更优化的写法: &lt;a href=&#34;http://coolshell.cn/articles/10975.html&#34;&gt;左耳朵耗子的例子&lt;/a&gt;和&lt;a href=&#34;http://www.hawkwithwind.net/blog/2011/02/18/%E5%8D%8F%E7%A8%8B%E7%9A%84c%E5%AE%9E%E7%8E%B0/&#34;&gt;上例&lt;/a&gt;的来源都是天才程序员  &lt;a href=&#34;http://www.chiark.greenend.org.uk/~sgtatham/&#34;&gt;imon Tatham&lt;/a&gt;对&lt;a href=&#34;http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html&#34;&gt;协程做的尝试&lt;/a&gt;，以及关于swtich-case写法的duff机器的&lt;a href=&#34;http://bbs.chinaunix.net/thread-1833313-1-1.html&#34;&gt;讨论&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.colaghost.net/os/unix_linux/341&#34;&gt;协程实现的基础&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;makecontext函数将context的eip设置为func参数的地址，所以当该context得以执行时，func函数就开始执行了。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/ylyuanlu/article/details/18947951&#34;&gt;http://blog.csdn.net/ylyuanlu/article/details/18947951&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/yxysdcl/article/details/5569351&#34;&gt;http://blog.csdn.net/yxysdcl/article/details/5569351&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;推荐的一些协程库&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://dunkels.com/adam/pt/&#34;&gt;protothread&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;其实c里面最好的协程库，就是嵌入LuaVM啦。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;setjump-longjmp:1a17fb99183985490e9adefe8aecc78f&#34;&gt;setjump &amp;amp; longjmp&lt;/h2&gt;

&lt;h5 id=&#34;man-longjmp:1a17fb99183985490e9adefe8aecc78f&#34;&gt;man longjmp&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;NAME
       longjmp, siglongjmp - nonlocal jump to a saved stack context

SYNOPSIS
       #include &amp;lt;setjmp.h&amp;gt;

       void longjmp(jmp_buf env, int val);
       void siglongjmp(sigjmp_buf env, int val);

DESCRIPTION
       longjmp()  and  setjmp(3) are useful for dealing with errors and interrupts encountered in a low-level subroutine of a program.  longjmp() restores the environment saved by the last call of setjmp(3)
       with the corresponding env argument.  After longjmp() is completed, program execution continues as if the corresponding call of setjmp(3) had just returned the value val.  longjmp() cannot cause 0 to
       be returned.  If longjmp() is invoked with a second argument of 0, 1 will be returned instead.

	   longjmp和setjmp在处理程序调用子例程过程中遇到错误或中断时非常有用。longjmp将恢复最近一次调用setjmp时通过env参数保存的上下文环境。longjmp完成后，原来调用setjmp的地方将会返回，并且setjmp的返回值是longjmp的val参数。longjmp不会返回0。如果longjmp调用时第二个参数是0，那么它将会返回1.

       siglongjmp()  is  similar  to longjmp() except for the type of its env argument.  If, and only if, the sigsetjmp(3) call that set this env used a nonzero savesigs flag, siglongjmp() also restores the
       signal mask that was saved by sigsetjmp(3).

RETURN VALUE
       These functions never return.

&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;man-setjmp:1a17fb99183985490e9adefe8aecc78f&#34;&gt;man setjmp&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;NAME
       setjmp, sigsetjmp - save stack context for nonlocal goto

SYNOPSIS
       #include &amp;lt;setjmp.h&amp;gt;

       int setjmp(jmp_buf env);
       int sigsetjmp(sigjmp_buf env, int savesigs);
	 
DESCRIPTION
       setjmp()  and  longjmp(3)  are  useful for dealing with errors and interrupts encountered in a low-level subroutine of a program.  setjmp() saves the stack context/environment in env for later use by
       longjmp(3).  The stack context will be invalidated if the function which called setjmp() returns.

       sigsetjmp() is similar to setjmp().  If, and only if, savesigs is nonzero, the process&#39;s current signal mask is saved in env and will be restored if a siglongjmp(3) is later performed with this env.

RETURN VALUE
       setjmp() and sigsetjmp() return 0 if returning directly, and nonzero when returning from longjmp(3) or siglongjmp(3) using the saved context.

&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例代码:1a17fb99183985490e9adefe8aecc78f&#34;&gt;示例代码&lt;/h5&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.linux.org.tw/~jserv/archives/001848.html&#34;&gt;代码地址&lt;/a&gt; 博客评论区&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;stdio.h&amp;gt;                                                                                  
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;setjmp.h&amp;gt;

jmp_buf jmpbuf_th0;
jmp_buf jmpbuf_th1;

static int cnt1 = 0;
static int cnt0 = 0;

static void thread_0()
{
	printf(&amp;quot;%s \n\n&amp;quot;, __FUNCTION__);
	sleep(1);
	longjmp(jmpbuf_th0, cnt0++);
}

static void thread_1()
{
	printf(&amp;quot;%s \n\n&amp;quot;, __FUNCTION__);
	sleep(1);
	longjmp(jmpbuf_th1, cnt1++);
}


int main()
{
	int rc0, rc1 = 0;

entry_thread_0:
	rc0 = setjmp(jmpbuf_th0);
	printf(&amp;quot;rc0 = %d\n&amp;quot;, rc0);
	if (rc0 != 0)
		thread_1();
entry_thread_1:
	rc1 = setjmp(jmpbuf_th1);
	printf(&amp;quot;rc1 = %d\n&amp;quot;, rc1);
	thread_0();

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;rc0 = 0
rc1 = 0
thread_0 

rc0 = 1
thread_1 

rc1 = 1
thread_0 

rc0 = 1
thread_1 

rc1 = 1
thread_0 

rc0 = 2
thread_1 

rc1 = 2
thread_0 

rc0 = 3
thread_1 

rc1 = 3
thread_0 

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;执行过程分析&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;setjmp和longjmp都是基于程序空间中额外的jmpbuf&lt;/li&gt;
&lt;li&gt;setjmp将当前环境存储在jmpbuf中，longjmp到同一个jmpbuf时，setjmp将会再次返回，返回值是longjmp的第二个参数val&lt;/li&gt;
&lt;li&gt;如果setjmp不是因为longjmp返回的，返回值为0&lt;/li&gt;
&lt;li&gt;不知道为什么执行结果中，自增的cnt0和cnt1在值为1的时候停顿了一次？&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/nasrallahmounir/context-switch-setjmp-longjm&#34;&gt;setjump &amp;amp; longjmp 进阶实现&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/mrquincle/event-abbey&#34;&gt;setjump &amp;amp; longjmp 进阶实现&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;ucontext:1a17fb99183985490e9adefe8aecc78f&#34;&gt;ucontext&lt;/h2&gt;

&lt;h5 id=&#34;man-getcontext:1a17fb99183985490e9adefe8aecc78f&#34;&gt;man getcontext&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;In  a  System  V-like  environment,  one has the two types mcontext_t and ucontext_t defined in &amp;lt;ucontext.h&amp;gt; and the four functions getcontext(), setcontext(), makecontext(3), and swapcontext(3) that
allow user-level context switching between multiple threads of control within a process.

The mcontext_t type is machine-dependent and opaque.  The ucontext_t type is a structure that has at least the following fields:

    typedef struct ucontext {
        struct ucontext *uc_link;
        sigset_t         uc_sigmask;
        stack_t          uc_stack;
        mcontext_t       uc_mcontext;
        ...
    } ucontext_t;

with sigset_t and stack_t defined in &amp;lt;signal.h&amp;gt;.  Here uc_link points to the context that will be resumed when the current context terminates (in case the current context was created  using  makecon‐
text(3)),  uc_sigmask is the set of signals blocked in this context (see sigprocmask(2)), uc_stack is the stack used by this context (see sigaltstack(2)), and uc_mcontext is the machine-specific rep‐
resentation of the saved context, that includes the calling thread&#39;s machine registers.

The function getcontext() initializes the structure pointed at by ucp to the currently active context.

The function setcontext() restores the user context pointed at by ucp.  A successful call does not return.  The context should have been obtained by a call  of  getcontext(),  or  makecontext(3),  or
passed as third argument to a signal handler.

If the context was obtained by a call of getcontext(), program execution continues as if this call just returned.

If the context was obtained by a call of makecontext(3), program execution continues by a call to the function func specified as the second argument of that call to makecontext(3).  When the function
func returns, we continue with the uc_link member of the structure ucp specified as the first argument of that call to makecontext(3).  When this member is NULL, the thread exits.

If the context was obtained by a call to a signal handler, then old standard text says that &amp;quot;program execution continues with the program instruction following the instruction interrupted by the sig‐
nal&amp;quot;.  However, this sentence was removed in SUSv2, and the present verdict is &amp;quot;the result is unspecified&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;man-makecontext:1a17fb99183985490e9adefe8aecc78f&#34;&gt;man makecontext&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;In  a  System  V-like  environment,  one has the type ucontext_t defined in &amp;lt;ucontext.h&amp;gt; and the four functions getcontext(3), setcontext(3), makecontext() and swapcontext() that allow user-level context switching between multiple threads of control within a
process.

在类System V环境下，结构体ucontext_t和四个函数 getcontext、setcontext、makecontext和swapcontext提供了在一个进程内通过用户级上下文切换的方式实现多线程的方式

For the type and the first two functions, see getcontext(3).

The makecontext() function modifies the context pointed to by ucp (which was obtained from a call to getcontext(3)).  Before invoking makecontext(), the caller must allocate a new stack for this context and assign its address to ucp-&amp;gt;uc_stack, and  define  a
successor context and assign its address to ucp-&amp;gt;uc_link.

makecontext函数将修改ucp指向的 ucontext_t（必须是从getcontext获得的对象），在调用makecontext前，调用者必须为改上下文分配一个新的栈，并将ucp-&amp;gt;uc_stack指向栈的地址，同时将ucp-&amp;gt;uc_link指向下一个context

When  this  context  is  later activated (using setcontext(3) or swapcontext()) the function func is called, and passed the series of integer (int) arguments that follow argc; the caller must specify the number of these arguments in argc.  When this function
returns, the successor context is activated.  If the successor context pointer is NULL, the thread exits.

当该context稍后被激活(通过setcontext或者swapcontext)，makecontext函数参数中的func将被调用，同时向func传递argc个参数。当func返回时，下一个context将被激活调用。如果下一个context是null的话，该线程结束。

The swapcontext() function saves the current context in the structure pointed to by oucp, and then activates the context pointed to by ucp.

swapcontext函数将当前context保存在oucp结构体，同时激活ucp指向的context。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;man-page-中的例子:1a17fb99183985490e9adefe8aecc78f&#34;&gt;man page 中的例子&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#include &amp;lt;ucontext.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

static ucontext_t uctx_main, uctx_func1, uctx_func2;

#define handle_error(msg) \
    do { perror(msg); exit(EXIT_FAILURE); } while (0)

static void
func1(void)
{
    printf(&amp;quot;func1: started\n&amp;quot;);
    printf(&amp;quot;func1: swapcontext(&amp;amp;uctx_func1, &amp;amp;uctx_func2)\n&amp;quot;);
    if (swapcontext(&amp;amp;uctx_func1, &amp;amp;uctx_func2) == -1)
        handle_error(&amp;quot;swapcontext&amp;quot;);
    printf(&amp;quot;func1: returning\n&amp;quot;);
}

static void
func2(void)
{
    printf(&amp;quot;func2: started\n&amp;quot;);
    printf(&amp;quot;func2: swapcontext(&amp;amp;uctx_func2, &amp;amp;uctx_func1)\n&amp;quot;);
    if (swapcontext(&amp;amp;uctx_func2, &amp;amp;uctx_func1) == -1)
        handle_error(&amp;quot;swapcontext&amp;quot;);
    printf(&amp;quot;func2: returning\n&amp;quot;);
}

int
main(int argc, char *argv[])
{
    char func1_stack[16384];
    char func2_stack[16384];

    if (getcontext(&amp;amp;uctx_func1) == -1)
        handle_error(&amp;quot;getcontext&amp;quot;);
    uctx_func1.uc_stack.ss_sp = func1_stack;
    uctx_func1.uc_stack.ss_size = sizeof(func1_stack);
    uctx_func1.uc_link = &amp;amp;uctx_main;
    makecontext(&amp;amp;uctx_func1, func1, 0);

    if (getcontext(&amp;amp;uctx_func2) == -1)
        handle_error(&amp;quot;getcontext&amp;quot;);
    uctx_func2.uc_stack.ss_sp = func2_stack;
    uctx_func2.uc_stack.ss_size = sizeof(func2_stack);
    /* Successor context is f1(), unless argc &amp;gt; 1 */
    uctx_func2.uc_link = (argc &amp;gt; 1) ? NULL : &amp;amp;uctx_func1;
    makecontext(&amp;amp;uctx_func2, func2, 0);

    printf(&amp;quot;main: swapcontext(&amp;amp;uctx_main, &amp;amp;uctx_func2)\n&amp;quot;);
    if (swapcontext(&amp;amp;uctx_main, &amp;amp;uctx_func2) == -1)
        handle_error(&amp;quot;swapcontext&amp;quot;);

    printf(&amp;quot;main: exiting\n&amp;quot;);
    exit(EXIT_SUCCESS);
}


// http://stackoverflow.com/questions/20778735/is-the-type-stack-t-no-longer-defined-on-linux

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ gcc context.c -o context.o

$ ./context.o 
main: swapcontext(&amp;amp;uctx_main, &amp;amp;uctx_func2)
func2: started
func2: swapcontext(&amp;amp;uctx_func2, &amp;amp;uctx_func1)
func1: started
func1: swapcontext(&amp;amp;uctx_func1, &amp;amp;uctx_func2)
func2: returning
func1: returning
main: exiting
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过manpage中提供的ucontext_t源码，结合man page中的解释，我们对此做一分析。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;执行过程详解

&lt;ul&gt;
&lt;li&gt;getcontext(&amp;amp;uctx_func2) 用当前上下文初始化ucontext_t结构体对象：uctx_func2&lt;/li&gt;
&lt;li&gt;在调用makecontext前，调用者为该上下文分配一个新的栈，并将成员uc_stack指向栈的地址，同时将uc_link指向下一个context。此时argc为0，所以uctx_func2的uc_link指向uctx_func1，也就是说当uctx_func2执行完后，会自动激活uctx_func1执行&lt;/li&gt;
&lt;li&gt;makecontext(&amp;amp;uctx_func2, func2, 0) 函数设置当uctx_func2激活时，调用func2函数，参数为0个；当func2返回时，下一个context将被激活，在这里是uctx_func1&lt;/li&gt;
&lt;li&gt;swapcontext(&amp;amp;uctx_main, &amp;amp;uctx_func2) 函数将进程当前执行的上下文保存在uctx_main中，并激活uctx_func2；uctx_func2开始执行，首先被执行的是func2函数，

&lt;ul&gt;
&lt;li&gt;func2: started&lt;/li&gt;
&lt;li&gt;func2: swapcontext(&amp;amp;uctx_func2, &amp;amp;uctx_func1)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;随后func2函数调用 swapcontext(&amp;amp;uctx_func2, &amp;amp;uctx_func1)，将当前上下文环境保存在uctx_func2中，激活uctx_func1；uctx_func1开始执行，首先执行的是func1，打印出：

&lt;ul&gt;
&lt;li&gt;func1: started&lt;/li&gt;
&lt;li&gt;func1: swapcontext(&amp;amp;uctx_func1, &amp;amp;uctx_func2)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;随后func1函数调用swapcontext(&amp;amp;uctx_func1, &amp;amp;uctx_func2)，将当前上下文环境保存在uctx_func1中，并激活uctx_func2；上一次uctx_func2保存的上下文环境将被回复，然后进程执行返回到上次被swap_context的点，打印出:

&lt;ul&gt;
&lt;li&gt;func2: returning&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;func2函数返回后，uctx_func2也就返回了，下一个context将被激活，也就是uctx_func1；打印出：

&lt;ul&gt;
&lt;li&gt;func1: returning&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;uctx_func1也执行结束，而它的下一个context是uctx_main，在main函数中最开始调用swap_context(&amp;amp;uctx_main, &amp;amp;uctx_func2)时，当时程序执行的上下文的地址就是这句，那么在main中继续执行，打印出：

&lt;ul&gt;
&lt;li&gt;main: exiting&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./context.o x
main: swapcontext(&amp;amp;uctx_main, &amp;amp;uctx_func2)
func2: started
func2: swapcontext(&amp;amp;uctx_func2, &amp;amp;uctx_func1)
func1: started
func1: swapcontext(&amp;amp;uctx_func1, &amp;amp;uctx_func2)
func2: returning
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;执行过程详解

&lt;ul&gt;
&lt;li&gt;当argc个数不为0时，uctx_func2的uc_link为NULL，所以如果uctx_func2结束生命周期，那么整个进程将会退出&lt;/li&gt;
&lt;li&gt;在第一次swap_context(&amp;amp;uctx_main, &amp;amp;uctx_func2)时开始调用func2，func2中打印出：

&lt;ul&gt;
&lt;li&gt;func2: started&lt;/li&gt;
&lt;li&gt;func2: swapcontext(&amp;amp;uctx_func2, &amp;amp;uctx_func1)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;随后swap执行uctx_func1，打印：

&lt;ul&gt;
&lt;li&gt;func1: started&lt;/li&gt;
&lt;li&gt;func1: swapcontext(&amp;amp;uctx_func1, &amp;amp;uctx_func2)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;随后swap返回uctx_func2，打印：

&lt;ul&gt;
&lt;li&gt;func2: returning&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;而func2返回时，由于uctx_func2-&amp;gt;uc_link为NULL，所以整个进程退出，并不会返回到之前保存过的uctx_main执行上下文中。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过以上分析，您有没有对协程有一个直观的认识呢？本质上，协程调度只是将当前执行的上下文保存起来；调度协程的时候就是将两个执行上下文context切换；指定context的下一个context，在本context执行结束后自动激活下一个context，实现协作；本context执行过程中，通过swap_context主动让出CPU，而不是被抢占放弃CPU。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;可以参考下&lt;a href=&#34;http://courses.cs.vt.edu/~cs3214/spring2016/examples/threads/coroutines.c&#34;&gt;进一步的实现&lt;/a&gt;，加深下印象：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdbool.h&amp;gt;
#include &amp;lt;ucontext.h&amp;gt;

static char stack[2][65536];            // a stack for each coroutine
static ucontext_t coroutine_state[2];   // container to remember context

// switch current coroutine (0 -&amp;gt; 1 -&amp;gt; 0 -&amp;gt; 1 ...)
static inline void
yield_to_next(void) 
{
    static int current = 0;

    int prev = current;
    int next = 1 - current;

    current = next;
    swapcontext(&amp;amp;coroutine_state[prev], &amp;amp;coroutine_state[next]);
}

static void
coroutine(int coroutine_number)
{
    int i;
    for (i = 0; i &amp;lt; 5; i++) {
        printf(&amp;quot;Coroutine %d counts i=%d (&amp;amp;i=%p)\n&amp;quot;, coroutine_number, i, &amp;amp;i);
        yield_to_next();
    }
}

int
main()
{
    ucontext_t return_to_main;

    // set up
    int i;
    for (i = 0; i &amp;lt; 2; i++) {
        // initialize ucontext_t
        getcontext(&amp;amp;coroutine_state[i]);
        // set up per-context stack
        coroutine_state[i].uc_stack.ss_sp = stack[i];
        coroutine_state[i].uc_stack.ss_size = sizeof(stack[i]);
        // when done, resume &#39;return_to_main&#39; context
        coroutine_state[i].uc_link = &amp;amp;return_to_main;
        // let context[i] perform a call to coroutine(i) when swapped to
        makecontext(&amp;amp;coroutine_state[i], (void (*)(void))coroutine, 1, i);
    }

    printf(&amp;quot;Starting coroutines...\n&amp;quot;);
    swapcontext(&amp;amp;return_to_main, &amp;amp;coroutine_state[0]);
    printf(&amp;quot;Done.\n&amp;quot;);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://1234n.com/?post/aukxju&#34;&gt;another demo&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://1234n.com/?post/4vzsvm&#34;&gt;lib&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://www.gnu.org/software/pth/&#34;&gt;gnu portable threads&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ossp.org/pkg/lib/pth/&#34;&gt;pt&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://swtch.com/libtask/&#34;&gt;libtask&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/foxmailed/p/3509359.html&#34;&gt;libtask的coroutine&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/cloudwu/coroutine&#34;&gt;云风的实现&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;其他一些应用&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/colaghost/coroutine_event&#34;&gt;coroutine-libevent&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;在libevent里通过协程实现同步&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;lua的协程:1a17fb99183985490e9adefe8aecc78f&#34;&gt;Lua的协程&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;lua不支持那种真正的多线程（共享同一地址空间的抢占式线程），原因是&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ANSI C没有原生的多线程，所以lua不能直接调用实现&lt;/li&gt;
&lt;li&gt;最重要的原因是，我们不认为多线程在lua中是个好主意&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;多线程是提供给底层编程的。多线程的同步机制，比如信号量和监控都是在操作系统上下文实现的，而非应用程序。调试多线程比较麻烦。而且，由于程序临界区的同步和竞争，多线程也会引起性能下降。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;多线程引起的问题，主要是抢占式线程和共享内存导致的，lua解决这两个问题的方法是：lua coroutine是协作式的，非抢占式的，所以能避免线程切换导致的问题；lua coroutine之间不共享内存。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;我见过的最lua的&lt;a href=&#34;https://techsingular.org/2012/12/22/programming-in-lua%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%8D-nil-%E5%92%8C-list/&#34;&gt;lua代码和博客&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;lua的&lt;a href=&#34;https://techsingular.org/2013/05/09/programming-in-lua%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%8D-coroutine-lua-stack/&#34;&gt;coroutine and stack&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;lua的c runtime stack和lua runtime stack是&lt;a href=&#34;https://techsingular.org/2013/07/14/programming-in-lua%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%8Dcontinuation/&#34;&gt;什么样子的&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://www.zhihu.com/question/21483863&#34;&gt;https://www.zhihu.com/question/21483863&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://www.zhihu.com/question/30133749&#34;&gt;lua协程调度&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;lua内部

&lt;ul&gt;
&lt;li&gt;当resume的时候，就切换lua_state环境，然后setjmp，紧接着由于pc指向新地址，所以会直接跳转到该位置&lt;/li&gt;
&lt;li&gt;当yield时，直接回复环境，然后longjmp到该resume点&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;lua with C

&lt;ul&gt;
&lt;li&gt;当在C函数内入yield时，会恢复环境，longjmp到resume点，之后再次resume的时候，会因为环境被破坏，导致resume出错，此时lua会调用k系列函数，让resume继续下去&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.ibm.com/developerworks/cn/opensource/os-cn-python-yield/&#34;&gt;lua实现调度器&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://www.lua.org/pil/9.2.html&#34;&gt;consumer-producer&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.lua.org/manual/5.2/manual.html#2.6&#34;&gt;lua yield 和 resume&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lua.org/manual/5.2/manual.html#pdf-coroutine.resume&#34;&gt;http://www.lua.org/manual/5.2/manual.html#pdf-coroutine.resume&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- http://my.oschina.net/wangxuanyihaha/blog/186401

function foo(a)
    print(&amp;quot;foo&amp;quot;, a)
    return coroutine.yield(2 * a)
end

co = coroutine.create(function ( a, b )
    print(&amp;quot;co-body&amp;quot;, a, b)
    local r = foo(a + 1)
    print(&amp;quot;co-body&amp;quot;, r)
    local r, s = coroutine.yield(a + b, a - b)
    print(&amp;quot;co-body&amp;quot;, r, s)
    return b, &amp;quot;end&amp;quot;
end)

print(&amp;quot;main&amp;quot;, coroutine.resume(co, 1, 10))
print(&amp;quot;main&amp;quot;, coroutine.resume(co, &amp;quot;m&amp;quot;))	-- resume的参数 &#39;m&#39; 是在调用yield传入的，所以本次是在第5行 return m
print(&amp;quot;main&amp;quot;, coroutine.resume(co, &amp;quot;x&amp;quot;, &amp;quot;y&amp;quot;))
print(&amp;quot;main&amp;quot;, coroutine.resume(co, &amp;quot;x&amp;quot;, &amp;quot;y&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;co-body	1	10
foo	2
main	true	4
co-body	m
main	true	11	-9
co-body	x	y
main	true	10	end
main	false	cannot resume dead coroutine
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;python的协程-待续:1a17fb99183985490e9adefe8aecc78f&#34;&gt;python的协程(待续)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ibm.com/developerworks/cn/opensource/os-cn-python-yield/&#34;&gt;http://www.ibm.com/developerworks/cn/opensource/os-cn-python-yield/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;golang的协程-待续:1a17fb99183985490e9adefe8aecc78f&#34;&gt;golang的协程(待续)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/13107958/what-exactly-does-runtime-gosched-do&#34;&gt;http://stackoverflow.com/questions/13107958/what-exactly-does-runtime-gosched-do&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;stm32-contiki-coroutine:1a17fb99183985490e9adefe8aecc78f&#34;&gt;stm32/ contiki/ coroutine&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://wiki.csie.ncku.edu.tw/embedded/Lab2&#34;&gt;stm32上的协程实现&lt;/a&gt;
    * &lt;a href=&#34;http://blog.linux.org.tw/~jserv/archives/001848.html&#34;&gt;http://blog.linux.org.tw/~jserv/archives/001848.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>HTTP2的实践过程</title>
      <link>https://bg2bkk.github.io/post/HTTP2%E7%9A%84%E5%AE%9E%E8%B7%B5%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Sat, 12 Mar 2016 16:17:52 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/HTTP2%E7%9A%84%E5%AE%9E%E8%B7%B5%E8%BF%87%E7%A8%8B/</guid>
      <description>

&lt;h2 id=&#34;目录:7c9d76473bce6d4e5d302b3b042a765b&#34;&gt;目录&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;前言&lt;/li&gt;
&lt;li&gt;基于openssl自建证书

&lt;ul&gt;
&lt;li&gt;CentOS&lt;/li&gt;
&lt;li&gt;Ubuntu&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;nginx的支持HTTP/2的patch&lt;/li&gt;
&lt;li&gt;nghttp2安装，配置，使用

&lt;ul&gt;
&lt;li&gt;nghttpd作为http2 server&lt;/li&gt;
&lt;li&gt;nghttp作为http2 client&lt;/li&gt;
&lt;li&gt;nghttpx作为proxy，转向nginx后端&lt;/li&gt;
&lt;li&gt;h2load作为压测工具&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;前言:7c9d76473bce6d4e5d302b3b042a765b&#34;&gt;前言&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;在研究HTTP/2协议时，常常和https协议混在一起，而二者之间的关系是怎样的呢？&lt;/li&gt;
&lt;li&gt;现有的http2 server中，nginx基于1.9.*有HTTP/2协议的patch，还有nghttp2 server，已经有人运行在个人博客做前端。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;只说实践过程，作为记录。&lt;/p&gt;

&lt;p&gt;关于涉及到的概念等，需要在别的文档中写。&lt;/p&gt;

&lt;h2 id=&#34;基于openssl自建证书:7c9d76473bce6d4e5d302b3b042a765b&#34;&gt;基于openssl自建证书&lt;/h2&gt;

&lt;p&gt;在线上配置HTTPS时，需要从权威CA申请证书，在nginx中配置证书crt和私钥key。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    listen 8443 ssl;
    ssl_certificate  /usr/lib/ssl/nginx.crt;
    ssl_certificate_key /usr/lib/ssl/nginx.key;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而在线下调试时，如果需要配置https，则需要自建和签发证书。
&lt;a href=&#34;http://segmentfault.com/a/1190000002569859&#34;&gt;基于openssl自建证书&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;在centos系统上自建证书:7c9d76473bce6d4e5d302b3b042a765b&#34;&gt;在CentOS系统上自建证书&lt;/h3&gt;

&lt;p&gt;1.自建CA，颁发证书&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;CA首先需要自建证书，作为颁发证书所用的根证书。CA的openssl配置文件/etc/pki/tls/openssl.cnf：

####################################################################
[ ca ]
default_ca	= CA_default		# The default ca section

####################################################################
[ CA_default ]

dir		= /etc/pki/CA		# Where everything is kept
certs		= $dir/certs		# Where the issued certs are kept
crl_dir		= $dir/crl		# Where the issued crl are kept
database	= $dir/index.txt	# database index file.
#unique_subject	= no			# Set to &#39;no&#39; to allow creation of
					# several ctificates with same subject.
new_certs_dir	= $dir/newcerts		# default place for new certs.

certificate	= $dir/cacert.pem 	# The CA certificate
serial		= $dir/serial 		# The current serial number
crlnumber	= $dir/crlnumber	# the current crl number
					# must be commented out to leave a V1 CRL
crl		= $dir/crl.pem 		# The current CRL
private_key	= $dir/private/cakey.pem# The private key
RANDFILE	= $dir/private/.rand	# private random number file

x509_extensions	= usr_cert		# The extentions to add to the cert

# Comment out the following two lines for the &amp;quot;traditional&amp;quot;
# (and highly broken) format.
name_opt 	= ca_default		# Subject Name options
cert_opt 	= ca_default		# Certificate field options



default_days	= 365			# how long to certify for
default_crl_days= 30			# how long before next CRL
default_md	= default		# use public key default MD
preserve	= no			# keep passed DN ordering

policy		= policy_match

# For the CA policy
[ policy_match ]
countryName		= match
stateOrProvinceName	= match
organizationName	= match
organizationalUnitName	= optional
commonName		= supplied
emailAddress		= optional
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中我们可以看到根地址在/etc/pki/CA下，且指明了CA证书certificate是该目录下的cacert.pem，私钥在private/cakey.pem中，CA需要匹配countryName、stateOrProvinceName和organizationName，且commonName需要提供，这点比较重要。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;在/etc/pki/CA下创建初始文件

$ touch serial index.txt
$ echo 01 &amp;gt; serial

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.生成根密钥&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cd /etc/pki/CA
$ openssl genrsa -out private/cakey.pem 2048
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.生成根证书&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;使用req指令，通过私钥，生成自签证书
$ openssl req -new -x509 -key private/cakey.pem -out cacert.pem
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter &#39;.&#39;, the field will be left blank.
-----
Country Name (2 letter code) [XX]:CN
State or Province Name (full name) []:BeiJing
Locality Name (eg, city) [Default City]:
Organization Name (eg, company) [Default Company Ltd]:
Organizational Unit Name (eg, section) []:
Common Name (eg, your name or your server&#39;s hostname) []:root
Email Address []:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.为nginx server生成密钥&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ mkdir /data/zhendong/nginx_ssl
$ openssl genrsa -out nginx.key 2048
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.为nginx生成 证书签署请求&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ openssl req -new -key nginx.key -out nginx.csr
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter &#39;.&#39;, the field will be left blank.
-----
Country Name (2 letter code) [XX]:CN
State or Province Name (full name) []:BeiJing
Locality Name (eg, city) [Default City]:
Organization Name (eg, company) [Default Company Ltd]:
Organizational Unit Name (eg, section) []:
Common Name (eg, your name or your server&#39;s hostname) []:localhost
Email Address []:

Please enter the following &#39;extra&#39; attributes
to be sent with your certificate request
A challenge password []:
An optional company name []:

Common Name填成nginx server的server_name用来访问。
在openssl.cnf中需要match的项目，一定要一样。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;6.向CA请求证书&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ openssl ca -in nginx.csr -out nginx.crt

如果失败，可以尝试以下命令

$ openssl x509 -req -in nginx.csr -CA /etc/pki/CA/cacert.pem -CAkey /etc/pki/CA/private/cakey.pem -CAcreateserial -out nginx.crt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;7.配置nginx&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;listen 8443 ssl ;
ssl_certificate  /data1/zhendong/nginx_ssl/nginx.crt;
ssl_certificate_key /data1/zhendong/nginx_ssl/nginx.key;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;8.通过curl访问&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ curl --cacert /etc/pki/CA/cacert.pem https://localhost:8443/
this is abtesting server

$ curl --cacert /etc/pki/CA/cacert.pem https://127.0.0.1:8443/
curl: (51) SSL: certificate subject name &#39;localhost&#39; does not match target host name &#39;127.0.0.1&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;###在Ubuntu系统上自建证书&lt;/p&gt;

&lt;p&gt;Ubuntu系统与CentOS的不同之处在于软件包管理不同，当克服这部分不同后，就可以执行与CentOS系统一样的操作。&lt;/p&gt;

&lt;p&gt;首先Ubuntu的openssl目录在&lt;strong&gt;/usr/lib/ssl&lt;/strong&gt;下，而实际上这是一个软链接。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;huang@ThinkPad-X220:/usr/lib/ssl$ ll /usr/lib/ssl/ total 52
drwxr-xr-x   3 root root  4096  8月 27 12:18 ./
drwxr-xr-x 238 root root 40960  8月 26 11:18 ../
lrwxrwxrwx   1 root root    14  2月  4  2015 certs -&amp;gt; /etc/ssl/certs/
drwxr-xr-x   2 root root  4096  7月  8 14:34 misc/
lrwxrwxrwx   1 root root    20  6月 11 23:35 openssl.cnf -&amp;gt; /etc/ssl/openssl.cnf
lrwxrwxrwx   1 root root    16  2月  4  2015 private -&amp;gt; /etc/ssl/private/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不管怎样，我们的工作将在&lt;strong&gt;/usr/lib/ssl&lt;/strong&gt;进行。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;/usr/lib/ssl/openssl.cnf内容如下：
####################################################################
[ ca ]
default_ca	= CA_default		# The default ca section

####################################################################
[ CA_default ]

dir		= ./demoCA		# Where everything is kept
certs		= $dir/certs		# Where the issued certs are kept
crl_dir		= $dir/crl		# Where the issued crl are kept
database	= $dir/index.txt	# database index file.
#unique_subject	= no			# Set to &#39;no&#39; to allow creation of
					# several ctificates with same subject.
new_certs_dir	= $dir/newcerts		# default place for new certs.

certificate	= $dir/cacert.pem 	# The CA certificate
serial		= $dir/serial 		# The current serial number
crlnumber	= $dir/crlnumber	# the current crl number
					# must be commented out to leave a V1 CRL
crl		= $dir/crl.pem 		# The current CRL
private_key	= $dir/private/cakey.pem# The private key
RANDFILE	= $dir/private/.rand	# private random number file

x509_extensions	= usr_cert		# The extentions to add to the cert
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从配置文件中看到，我们需要在&lt;strong&gt;/usr/lib/ssl&lt;/strong&gt;下建立&lt;strong&gt;demoCA&lt;/strong&gt;目录以及其他。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cd /usr/lib/ssl
$ mkdir demoCA
$ mkdir demoCA/newcerts
$ mkdir demoCA/private
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;余下的操作将与在CentOS系统上没有区别。最后执行情况为：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ curl --cacert /usr/lib/ssl/demoCA/cacert.pem https://localhost:8443
this is abtesting server
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;nginx的支持http-2的patch:7c9d76473bce6d4e5d302b3b042a765b&#34;&gt;nginx的支持HTTP/2的patch&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;nginx目前已正式支持HTTP/2，包括tengine-2.1.2+ 和 openresty&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;nginx在8月份的时候从1.9.3版本推出了支持HTTP/2的&lt;a href=&#34;http://nginx.org/patches/http2/&#34;&gt;patch&lt;/a&gt;，使用时与标准nginx并无区别。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cd nginx-1.9.4/
$ patch -p1 &amp;lt; patch.http2-v3_1.9.4.txt  
$ ./configure --with-http_v2_module --with-http_ssl_module
$ make
$ make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;支持http2的nginx关键配置为&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;	listen 8443 http2;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只需要在listen后加http2就可以了。目前curl在基于nghttp2提供的HTTP/2库后，可以支持访问http2的server，但是目前没有配置成功，所以对支持http2的nginx进行访问的工作，将在介绍完nghttp2后一并记录。&lt;/p&gt;

&lt;h2 id=&#34;nghttp2安装-配置-使用:7c9d76473bce6d4e5d302b3b042a765b&#34;&gt;nghttp2安装，配置，使用&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/tatsuhiro-t/nghttp2&#34;&gt;nghttp2&lt;/a&gt;是由tatsuhiro开发的，之前的spdylay也是他开发的，一直走在http2.0的前列。nghttp2包括了HTTP/2.0的库，基于这个库tatsu实现了HTTP/2.0的server、client和压测工具h2load。&lt;/p&gt;

&lt;p&gt;由于nghttp2所依赖的库太新了，目前只在Ubuntu系统成功安装。安装过程：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ autoreconf -i
$ automake
$ autoconf
$ ./configure
$ make
```	

其中**./configure**的结果非常重要

```bash
    Version:        1.2.2-DEV shared 14:8:0
    Host type:      x86_64-unknown-linux-gnu
    Install prefix: /usr/local
    C compiler:     gcc
    CFLAGS:         -g -O2
    WARNCFLAGS:     
    LDFLAGS:        
    LIBS:           
    CPPFLAGS:       
    C preprocessor: gcc -E
    C++ compiler:   g++
    CXXFLAGS:       -g -O2 -std=c++11
    CXXCPP:         g++ -E
    Library types:  Shared=yes, Static=yes
    Python:
      Python:         /usr/bin/python
      PYTHON_VERSION: 2.7
      pyexecdir:      ${exec_prefix}/lib/python2.7/dist-packages
      Python-dev:     yes
      PYTHON_CPPFLAGS:-I/usr/include/python2.7
      PYTHON_LDFLAGS: -L/usr/lib -lpython2.7
      Cython:         cython
    Test:
      CUnit:          yes
      Failmalloc:     yes
    Libs:
      OpenSSL:        yes
      Libxml2:        yes
      Libev:          yes
      Libevent(SSL):  yes
      Spdylay:        yes
      Jansson:        yes
      Jemalloc:       yes
      Zlib:           yes
      Boost CPPFLAGS: 
      Boost LDFLAGS:  
      Boost::ASIO:    
      Boost::System:  
      Boost::Thread:  
    Features:
      Applications:   yes
      HPACK tools:    yes
      Libnghttp2_asio:no
      Examples:       yes
      Python bindings:yes
      Threading:      yes
      Third-party:    yes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译帮助文档&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make html
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;nghttpd作为http2-server:7c9d76473bce6d4e5d302b3b042a765b&#34;&gt;nghttpd作为http2 server&lt;/h3&gt;

&lt;p&gt;http2-no-tls&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nghttpd -v 8080   -n 24 --no-tls -d ~/workspace/Nginx_ABTesting/utils/html/ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;http2-with-tls&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nghttpd -v 8080 -n 24 /usr/lib/ssl/nginx.key /usr/lib/ssl/nginx.crt -d ~/workspace/Nginx_ABTesting/utils/html/  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于nghttpd的选项，其实可以与nginx配置做到一一对照的。目前对nghttpd的源码及实现了解的比较少，因其日本人的过于C++代码的风格实在晦涩难懂，所以很少做调优。&lt;/p&gt;

&lt;h3 id=&#34;nghttp作为http2-client:7c9d76473bce6d4e5d302b3b042a765b&#34;&gt;nghttp作为http2 client&lt;/h3&gt;

&lt;p&gt;http2-client-no-tls&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nghttp http://127.0.0.1:8080
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;http2-client-with-tls&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nghttp --cert /usr/lib/ssl/demoCA/cacert.pem https://127.0.0.1:8080

nghttp https://127.0.0.1:8080
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;经过使用，nghttp也可以对nginx发出http2请求并成功返回。&lt;/p&gt;

&lt;p&gt;通过strace和阅读源码，nghttp（包括压测工具h2load）作为client时，会读取系统的证书/usr/lib/ssl/demoCA/cacert.pem，因此可以不用指定。&lt;/p&gt;

&lt;h3 id=&#34;nghttpx作为proxy-转向nginx后端:7c9d76473bce6d4e5d302b3b042a765b&#34;&gt;nghttpx作为proxy，转向nginx后端&lt;/h3&gt;

&lt;p&gt;client ——&amp;gt; http2-proxy-no-tls ——&amp;gt; http1.1 upstream(nginx):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# nghttpx -f127.0.0.1,8080 -b127.0.0.1,8022 --frontend-no-tls

# curl 127.0.0.1:8022
this is beta3 server

# nghttp http://127.0.0.1:8080
this is beta3 server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;client ——&amp;gt; http2-proxy-with-tls ——&amp;gt; http1.1 upstream(nginx):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# nghttpx -f127.0.0.1,8080 -b127.0.0.1,8022 /usr/lib/ssl/nginx.key /usr/lib/ssl/nginx.crt

# nghttp https://127.0.0.1:8080
this is beta3 server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;采用nginx-http2作为proxy，使用方法与nginx-http1.1没有区别。&lt;/p&gt;

&lt;h3 id=&#34;h2load作为压测工具:7c9d76473bce6d4e5d302b3b042a765b&#34;&gt;h2load作为压测工具&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ h2load -n100 -c10 -t4  https://127.0.0.1:8080
starting benchmark...
spawning thread #0: 3 concurrent clients, 25 total requests
spawning thread #1: 3 concurrent clients, 25 total requests
spawning thread #2: 2 concurrent clients, 25 total requests
spawning thread #3: 2 concurrent clients, 25 total requests
Protocol: TLSv1.2
Cipher: ECDHE-RSA-AES128-GCM-SHA256
progress: 8% done
progress: 16% done
progress: 24% done
progress: 32% done
progress: 40% done
progress: 48% done
progress: 56% done
progress: 64% done
progress: 72% done
progress: 80% done
progress: 88% done
progress: 96% done

finished in 67.29ms, 1486 req/s, 111.02KB/s
requests: 100 total, 100 started, 100 done, 100 succeeded, 0 failed, 0 errored
status codes: 100 2xx, 0 3xx, 0 4xx, 0 5xx
traffic: 7650 bytes total, 3450 bytes headers, 2100 bytes data
                     min         max         mean         sd        +/- sd
time for request:      343us      8.76ms      1.40ms      1.49ms    91.00%
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;h2load的使用与wrk没有区别，参数都是一样的。&lt;/p&gt;

&lt;p&gt;根据不同配置，我们有以下几种场景：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;server/proxy			https

nginx-http/1.1			with-tls
nginx-http/2			no-tls
nghttpd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相结合，压测场景比较多。幸运的是，不论server是nginx还是nghttpd，其参数和调优都可以指定，比如线程数；不论wrk还是h2load，参数也可以指定，使用起来区别不大。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>design patterns 设计模式</title>
      <link>https://bg2bkk.github.io/post/design%20patterns%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 11 Mar 2016 11:33:10 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/design%20patterns%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <description>

&lt;h2 id=&#34;uml类图:05beb03bd2b20b37622e83e38123d90b&#34;&gt;UML类图&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html&#34;&gt;认真读图&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;单例模式:05beb03bd2b20b37622e83e38123d90b&#34;&gt;单例模式&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://marcio.io/2015/07/singleton-pattern-in-go/&#34;&gt;单例模式&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://tengj.top/2016/04/06/sjms4singleton/&#34;&gt;http://tengj.top/2016/04/06/sjms4singleton/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://liuxp0827.blog.51cto.com/5013343/1354360&#34;&gt;http://liuxp0827.blog.51cto.com/5013343/1354360&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;工厂模式:05beb03bd2b20b37622e83e38123d90b&#34;&gt;工厂模式&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://tengj.top/2016/04/02/sjms1simpleFactory/&#34;&gt;简单工厂模式&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.oschina.net/code/snippet_1469272_34383&#34;&gt;design pattern in GO&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;interface　相当于是　abstract class&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://tengj.top/2016/04/03/sjms2factorymethod/&#34;&gt;工厂方法模式&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;工厂方法模式的用意是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类中。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://tengj.top/2016/04/04/sjms3abstractfactory/&#34;&gt;抽象工厂模式&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;抽象工厂模式可以向客户端提供一个接口，使得客户端在不必指定产品的具体类型的情况下，创建多个产品族中的产品对象。这就是抽象工厂的用意。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;设计模式的不同实现:05beb03bd2b20b37622e83e38123d90b&#34;&gt;设计模式的不同实现&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dabing1022/LuaAndLove2dLearningTest/tree/master/DesignPattern&#34;&gt;lua&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.qiuzhufu.com/archives/tag/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F&#34;&gt;java&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.jellythink.com/archives/878&#34;&gt;cpp&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/iluwatar/java-design-patterns&#34;&gt;java&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://design-patterns.readthedocs.io/zh_CN/latest/index.html#&#34;&gt;book&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>