<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>BG2BKK Site</title>
    <link>https://bg2bkk.github.io/</link>
    <description>Recent content on BG2BKK Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 03 May 2016 16:39:34 +0800</lastBuildDate>
    <atom:link href="https://bg2bkk.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>X86调用约定</title>
      <link>https://bg2bkk.github.io/post/X86%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/</link>
      <pubDate>Tue, 03 May 2016 16:39:34 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/X86%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/X86%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A&#34;&gt;https://zh.wikipedia.org/wiki/X86%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ABI&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;调用约定  calling conventions&lt;/li&gt;
&lt;li&gt;类型表示  type representation&lt;/li&gt;
&lt;li&gt;名称修饰  name mangling&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;cdecl( C declaration )&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Developing stm32 on Linux</title>
      <link>https://bg2bkk.github.io/post/Developing%20stm32%20on%20Linux/</link>
      <pubDate>Tue, 12 Apr 2016 10:20:13 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/Developing%20stm32%20on%20Linux/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;stlink&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/texane/stlink&#34;&gt;https://github.com/texane/stlink&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;用于下载调试&lt;/li&gt;
&lt;li&gt;将windows keil编译出的elf、bin等文件烧进stm32，正常工作&lt;/li&gt;
&lt;li&gt;todo: stflash&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/rowol/stm32_discovery_arm_gcc&#34;&gt;https://github.com/rowol/stm32_discovery_arm_gcc&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;gcc to make stm32&lt;/li&gt;
&lt;li&gt;gcc makefile&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;stm32cubemx&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;用于生成代码&lt;/li&gt;
&lt;li&gt;生成代码后报 Gtk-Message: Failed to load module &amp;ldquo;overlay-scrollbar&amp;rdquo;

&lt;ul&gt;
&lt;li&gt;原因：The Message lines mean you are missing the overlay-scrollbar-gtk2 and unity-gtk2-module packages.&lt;/li&gt;
&lt;li&gt;解决办法：&lt;a href=&#34;http://askubuntu.com/questions/453124/gtk-message-and-warnings-in-ubuntu-14-04&#34;&gt;http://askubuntu.com/questions/453124/gtk-message-and-warnings-in-ubuntu-14-04&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;apt-get install overlay-scrollbar-gtk2&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>github 上那些令我感到惊艳又实用的项目</title>
      <link>https://bg2bkk.github.io/post/github%20%E4%B8%8A%E9%82%A3%E4%BA%9B%E4%BB%A4%E6%88%91%E6%84%9F%E5%88%B0%E6%83%8A%E8%89%B3%E5%8F%88%E5%AE%9E%E7%94%A8%E7%9A%84%E9%A1%B9%E7%9B%AE/</link>
      <pubDate>Tue, 12 Apr 2016 10:19:38 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/github%20%E4%B8%8A%E9%82%A3%E4%BA%9B%E4%BB%A4%E6%88%91%E6%84%9F%E5%88%B0%E6%83%8A%E8%89%B3%E5%8F%88%E5%AE%9E%E7%94%A8%E7%9A%84%E9%A1%B9%E7%9B%AE/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/phodal&#34;&gt;https://github.com/phodal&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>shadowsocks go through the Fuck GFW</title>
      <link>https://bg2bkk.github.io/post/shadowsocks%20go%20through%20the%20F%2A%2Ak%20GFW/</link>
      <pubDate>Mon, 11 Apr 2016 00:33:17 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/shadowsocks%20go%20through%20the%20F%2A%2Ak%20GFW/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;买VPS，vultr的设备，使用起来还是蛮简单的。信用卡一张，注册并扣费0.1美元会送50美元，两个月内用完。我开始部署了一个日本的最便宜的5美元一月的vps，使用起来还不错，youtube 480P没问题；但是我通过这送的50美元实验了以下几个配置的机器速度，洛杉矶机房20美元，洛杉矶机房5美元，日本机房5美元，日本机房10美元，发现ping vps-ip时美国机房都是170ms，日本机房是220ms，原因可能是即使日本离得近，去日本的路由也要绕道美国才到日本的，所以我们直接选择美国机房好了。位于西海岸的洛杉矶机房，让你打开youtube 1080P毫无压力，白天晚上都没问题。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如何手动搭建shadowsocks服务呢，网上有太多的教程了&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;python版shadowsocks

&lt;ul&gt;
&lt;li&gt;ss服务的鼻祖，支持多用户多端口配置&lt;/li&gt;
&lt;li&gt;参考教程：&lt;a href=&#34;https://pypi.python.org/pypi/shadowsocks&#34;&gt;py版ss服务&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wget --no-check-certificate https://raw.githubusercontent.com/tennfy/shadowsocks-libev/master/debian_shadowsocks_tennfy.sh
chmod a+x debian_shadowsocks_tennfy.sh

sudo ./debian_shadowsocks_tennfy.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;    * /etc/init.d/shadowsocks-libev start
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;shadowsocks客户端&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;全平台：windows、linux、OSX；android、ios；&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://shadowsocks.com/client.html&#34;&gt;客户端&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/shadowsocks/shadowsocks-windows/releases&#34;&gt;windows&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/shadowsocks/shadowsocks-qt5/wiki/Installation&#34;&gt;linux&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ubuntu用户建议使用apt-get安装&lt;/li&gt;
&lt;li&gt;其他发行版用户。。。我还不知道&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/shadowsocks/shadowsocks-iOS/releases&#34;&gt;OSX&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;我没用过&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://pan.baidu.com/s/1YbQTg&#34;&gt;android&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.iyingsuo.com/ios-shadowsocks-tutorials.html&#34;&gt;ios&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果您觉得shadowsocks很容易搭建起来，想试一下的话，可以通过的推荐链接来注册，这样会有一定奖励:&lt;a href=&#34;http://www.vultr.com/?ref=6870148&#34;&gt;http://www.vultr.com/?ref=6870148&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>DNS with golang</title>
      <link>https://bg2bkk.github.io/post/DNS%20with%20golang/</link>
      <pubDate>Fri, 08 Apr 2016 12:05:30 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/DNS%20with%20golang/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Record Tyeps&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;DNS Management: Record Types and When To Use Them&#34;&gt;Record Types&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A records:    A 记录&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;CNAME&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;MX Record&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;miekg/dns&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;dig with edns&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.gsic.uva.es/~jnisigl/dig-edns-client-subnet.html&#34;&gt;https://www.gsic.uva.es/~jnisigl/dig-edns-client-subnet.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://xmodulo.com/geographic-location-ip-address-command-line.html&#34;&gt;http://xmodulo.com/geographic-location-ip-address-command-line.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;curl ipinfo.io/23.66.166.151&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;发现UDP和TCP发出的包，效果大不同&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;急需DNS抓包工具&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;DNS报文格式&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;IP packet

&lt;ul&gt;
&lt;li&gt;IP Header 20 bytes&lt;/li&gt;
&lt;li&gt;IP Data: UDP

&lt;ul&gt;
&lt;li&gt;UDP Header 8 bytes&lt;/li&gt;
&lt;li&gt;UDP Data: DNS

&lt;ul&gt;
&lt;li&gt;DNS Header 12 bytes&lt;/li&gt;
&lt;li&gt;DNS Data: RR

&lt;ul&gt;
&lt;li&gt;RR: Question&lt;/li&gt;
&lt;li&gt;RR: Answer&lt;/li&gt;
&lt;li&gt;RR: Authority&lt;/li&gt;
&lt;li&gt;RR: Additional&lt;/li&gt;
&lt;li&gt;RR

&lt;ul&gt;
&lt;li&gt;QName&lt;/li&gt;
&lt;li&gt;QType&lt;/li&gt;
&lt;li&gt;QClass&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;RR OPT

&lt;ul&gt;
&lt;li&gt;QName null&lt;/li&gt;
&lt;li&gt;QType OPT=41&lt;/li&gt;
&lt;li&gt;QClass = UDP payload 2bytes&lt;/li&gt;
&lt;li&gt;TTL = Extended-RCODE 1byte: extend + VERSION 1byte: 0 + Z 2bytes: 0&lt;/li&gt;
&lt;li&gt;RDLen len of data(OPT)&lt;/li&gt;
&lt;li&gt;OPT

&lt;ul&gt;
&lt;li&gt;Option-Code 2bytes: EDNS0_SUBNET&lt;/li&gt;
&lt;li&gt;Option-Length 2bytes&lt;/li&gt;
&lt;li&gt;Option-Data&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;Family 1byte: IPV4(1)&lt;/li&gt;
&lt;li&gt;Source Netmask 1byte: 32&lt;/li&gt;
&lt;li&gt;Scope Netmask 1byte: 0&lt;/li&gt;
&lt;li&gt;Client Subnet 4bytes: 65.135.152.203&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;我们总是在追一些时髦的技术，而不顾基础还不牢靠&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;我们总是看见新的框架，然而框架本质上仍然是那些东西，mvc，cs&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>googletest framework初步上手</title>
      <link>https://bg2bkk.github.io/post/googletest%20framework%E5%88%9D%E6%AD%A5%E4%B8%8A%E6%89%8B/</link>
      <pubDate>Sun, 03 Apr 2016 13:14:13 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/googletest%20framework%E5%88%9D%E6%AD%A5%E4%B8%8A%E6%89%8B/</guid>
      <description>&lt;p&gt;刷leetcode的时候，需要调试代码。
需要本地有开发环境，结果没有，上学的时候还自己弄了一个，lowb的很。近来还是想刷leetcode，发现还是需要个环境，这个时候我的想法就不一样了。上学的时候是，看见问题了就直接去解决这个问题，并不会多想；上一年班后，现在看这个问题，就会寻思下，有没有更好的办法，业界通用做法是什么，业界里的标杆公司和标杆人物又是怎么做的。&lt;/p&gt;

&lt;p&gt;我寻思了我的场景，发现我应该是要做单元测试的，写好一个函数或者接口，提交给测试框架（leetcode），那么就找找吧。&lt;/p&gt;

&lt;p&gt;所以我第一步是先google，关键词“c 单元测试”，中文信息还是比较少的，直接搜&amp;rdquo;c unit test&amp;rdquo;，效果还是不错的。首先是&lt;a href=&#34;http://stackoverflow.com/questions/65820/unit-testing-c-code&#34;&gt;stackoverflow的结果&lt;/a&gt;，提到很多，junit，cunit等等，最后一个答案是googletest，眼前一亮，github搜一下，&lt;a href=&#34;https://github.com/google/googletest&#34;&gt;得到结果&lt;/a&gt;，是一个一直活跃着的项目。两篇博文，&lt;a href=&#34;https://meekrosoft.wordpress.com/2009/10/04/testing-c-code-with-the-googletest-framework/&#34;&gt;&amp;lsquo;testing c++ code with the GoogleTest framework&amp;rsquo;&lt;/a&gt;和&lt;a href=&#34;https://meekrosoft.wordpress.com/2009/11/09/unit-testing-c-code-with-the-googletest-framework/&#34;&gt;&amp;lsquo;unit testing c code with the GoogleTest framework&amp;rsquo;&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;googletest其实由googletest和googlemock组成，前者是单元测试，后者是模拟c模块的。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/google/googletest/blob/master/googletest/README.md&#34;&gt;googletest&lt;/a&gt;的使用文档和&lt;a href=&#34;http://blog.csdn.net/russell_tao/article/details/7333226&#34;&gt;陶辉的实践过程&lt;/a&gt;，还有&lt;a href=&#34;http://www.cnblogs.com/coderzh/archive/2009/04/06/1426755.html&#34;&gt;coderzh的实践过程&lt;/a&gt;，&lt;a href=&#34;https://www.ibm.com/developerworks/cn/linux/l-cn-cppunittest/&#34;&gt;IBM的教程&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>stapxx使用过程</title>
      <link>https://bg2bkk.github.io/post/stapxx%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Fri, 01 Apr 2016 18:38:31 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/stapxx%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B/</guid>
      <description>

&lt;h2 id=&#34;lj-gc:044f08471c528eccf9b1c5e4ae42c4ec&#34;&gt;lj-gc&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;usage:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[zhendong@D13124441 stapxx]$ sudo ./stap++  ./samples/lj-gc.sxx -x 43376
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;error:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Found exact match for libluajit: /usr/local/lib/libluajit-5.1.so.2.1.0
WARNING: cannot find module /usr/local/lib/libluajit-5.1.so.2.1.0 debuginfo: No DWARF information found [man warning::debuginfo]
semantic error: type definition &#39;lua_State&#39; not found in &#39;/usr/local/lib/libluajit-5.1.so.2.1.0&#39;: operator &#39;@cast&#39; at stapxx-QIH_WYIt/luajit.stp:162:12
        source:     return @cast(L, &amp;quot;lua_State&amp;quot;, &amp;quot;/usr/local/lib/libluajit-5.1.so.2.1.0&amp;quot;)-&amp;gt;glref-&amp;gt;ptr32
                           ^

Pass 2: analysis failed.  [man error::pass2]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;reason:&lt;/p&gt;

&lt;p&gt;libluajit-5.1没有dwarf信息，需要重新编译&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;resolve:&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make CCDEBUG=&amp;quot;-g -O0 -gdwarf-2&amp;quot; -j
# -gdwarf-2将会保持DWARF参数
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;elf一般由多个节(section)组成，不熟悉的可以看关于&lt;a href=&#34;http://blog.csdn.net/coutcin/article/details/1065470&#34;&gt;elf文件格式的文章&lt;/a&gt;。调试信息被包含在某几个节中，如果是用dwarf2格式编译的，这些节的名字一般是以.debug开头，如.debug_info，.debug_line，.debug_frame等，如果是用dwarf1格式编译的，这些节的名字一般是.debug，.line等。现在的编译器默认大多数是dwarf2格式编译，当然可以通过gcc的编译选项改变。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 查看elf文件的各段头部
readelf -S elffile

# 查看elf文件的.debug_info段，关键在于info的i，所以采用 -wi参数
readelf -wi src/libluajit.so

# 查看elf文件的.debug_line段，关键在于info的l，所以采用 -wl参数
readelf -wl src/libluajit.so

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于LuaJIT来说，-O0和-O2(默认)对于DWARF信息来说没有区别，因为dwarf信息是调试信息。而-gdwarf-2和-g的差别在于，前者能够保留更详细一步的信息(对于.dubeg_info段而言)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#output by -gdwarf-2
 &amp;lt;2&amp;gt;&amp;lt;134&amp;gt;: Abbrev Number: 8 (DW_TAG_member)
    &amp;lt;135&amp;gt;   DW_AT_name        : env	
    &amp;lt;139&amp;gt;   DW_AT_decl_file   : 2	
    &amp;lt;13a&amp;gt;   DW_AT_decl_line   : 661	
    &amp;lt;13c&amp;gt;   DW_AT_type        : &amp;lt;0x3b9&amp;gt;	
    &amp;lt;140&amp;gt;   DW_AT_data_member_location: 2 byte block: 23 2c 	(DW_OP_plus_uconst: 44)

#output by -g
 &amp;lt;2&amp;gt;&amp;lt;11c&amp;gt;: Abbrev Number: 8 (DW_TAG_member)
    &amp;lt;11d&amp;gt;   DW_AT_name        : env	
    &amp;lt;121&amp;gt;   DW_AT_decl_file   : 2	
    &amp;lt;122&amp;gt;   DW_AT_decl_line   : 661	
    &amp;lt;124&amp;gt;   DW_AT_type        : &amp;lt;0x37e&amp;gt;	
    &amp;lt;128&amp;gt;   DW_AT_data_member_location: 44	
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;correct result&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[zhendong@D13124441 stapxx]$ sudo ./stap++  ./samples/lj-gc.sxx -x 13337
Found exact match for libluajit: /usr/local/lib/libluajit-5.1.so.2.1.0
Start tracing 13337 (/usr/local/nginx/sbin/nginx)
Total GC count: 128828 bytes

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;extrainfo&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在压测时，采用-c10000的压力，发现压力较大时报错&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[zhendong@D13124441 stapxx]$ sudo ./stap++  ./samples/lj-gc.sxx -x 13337
Found exact match for libluajit: /usr/local/lib/libluajit-5.1.so.2.1.0
ERROR: read fault [man error::fault] at 0x000000000077d8e8 (addr) near operator &#39;@var&#39; at stapxx-j8srK_I0/nginx.config.stp:7:80
Start tracing 13337 (/usr/local/nginx/sbin/nginx)
WARNING: Number of errors: 1, skipped probes: 0
WARNING: /usr/bin/staprun exited with status: 1
Pass 5: run failed.  [man error::pass5]

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重启解决，很无奈&lt;/p&gt;

&lt;h2 id=&#34;ngx-lua-shdict-info:044f08471c528eccf9b1c5e4ae42c4ec&#34;&gt;ngx-lua-shdict-info&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;采用openresty才能正常使用也是够了&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[zhendong@D13124441 stapxx]$ sudo ./stap++ ./samples/ngx-lua-shdict-info.sxx -x 5545 &amp;ndash;arg dict=kv_api_root_upstream
Start tracing 5545 (/data1/zhendong/openresty-1.9.7.4/build/nginx-1.9.7/objs/nginx)
shm zone &amp;ldquo;api_root_sysConfig&amp;rdquo;
shm zone &amp;ldquo;kv_api_root_upstream&amp;rdquo;
shm zone &amp;ldquo;kv_api_root_upstream&amp;rdquo;
    owner: ngx_http_lua_shdict
    total size: 102400 KB
    free pages: 96392 KB (24098 pages, 29 blocks)
    rbtree black height: 10&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>minimal linux distro制作过程</title>
      <link>https://bg2bkk.github.io/post/minimal%20linux%20distro%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Wed, 30 Mar 2016 15:13:13 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/minimal%20linux%20distro%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8B/</guid>
      <description>&lt;p&gt;github:     &lt;a href=&#34;https://github.com/ivandavidov/minimal&#34;&gt;https://github.com/ivandavidov/minimal&lt;/a&gt;
blog:   &lt;a href=&#34;http://minimal.linux-bg.org/&#34;&gt;http://minimal.linux-bg.org/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;sudo apt-get install isolinux
  sudo apt-get install syslinux syslinux-common syslinux-efi syslinux-utils
  sudo apt-get install syslinux-themes-ubuntu-xenial&lt;/p&gt;

&lt;p&gt;7gen iso img时报找不到 isolinux.bin错误，需要事先copy到这里
sudo cp /usr/share/syslinux/themes/ubuntu-xenial/isolinux-live/isolinux.bin /usr/lib/syslinux/isolinux.bin&lt;/p&gt;

&lt;p&gt;sh ./qemu64.sh时，报can&amp;rsquo;t load ldlinux.c32, 首先将ldlinux.c32copy到该目录下&lt;/p&gt;

&lt;p&gt;sudo cp /usr/share/syslinux/themes/ubuntu-xenial/isolinux-live/ldlinux.c32 /usr/lib/syslinux/&lt;/p&gt;

&lt;p&gt;修改kernel的 &lt;a href=&#34;https://github.com/mhiramat/boot2minc/blob/master/src/patches/kernel/x86-copy-linux-c32-for-newer.patch&#34;&gt;arch/x86/boot/Makefile&lt;/a&gt;
将如下信息&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;           if [ -f /usr/$$i/syslinux/ldlinux.c32 ] ; then \
               cp /usr/$$i/syslinux/ldlinux.c32 $(obj)/isoimage ; \
           fi ; \
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;写在&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;        if [ -f /usr/$$i/syslinux/isolinux.bin ] ; then \
                    cp /usr/$$i/syslinux/isolinux.bin $(obj)/isoimage ; \
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后&lt;/p&gt;

&lt;p&gt;在&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;break ; \
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/2009/10/5_ways_to_search_for_files_using_the_terminal.html&#34;&gt;http://www.ruanyifeng.com/blog/2009/10/5_ways_to_search_for_files_using_the_terminal.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;另外一个版本和方法&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://mgalgs.github.io/2015/05/16/how-to-build-a-custom-linux-kernel-for-qemu-2015-edition.html&#34;&gt;http://mgalgs.github.io/2015/05/16/how-to-build-a-custom-linux-kernel-for-qemu-2015-edition.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/SunliyMonkey/tiny_linux&#34;&gt;https://github.com/SunliyMonkey/tiny_linux&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>TODO List</title>
      <link>https://bg2bkk.github.io/post/TODO%20List/</link>
      <pubDate>Mon, 28 Mar 2016 14:43:15 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/TODO%20List/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;python crawler&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://aosabook.org/en/index.html&#34;&gt;http://aosabook.org/en/index.html&lt;/a&gt;     done&lt;/li&gt;
&lt;li&gt;scrapy: xpath&lt;/li&gt;
&lt;li&gt;scrapy: login and cookie&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;ol&gt;
&lt;li&gt;xv6 lecture and homework&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;cs635&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;ol&gt;
&lt;li&gt;Programming In Lua. en version. edition 3&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;coroutine and goroutine&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;ol&gt;
&lt;li&gt;compile linux kernel and boot from qemu&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;busybox&lt;/li&gt;
&lt;li&gt;buildroot&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;ol&gt;
&lt;li&gt;build a image file for rpi and boot&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;ol&gt;
&lt;li&gt;Bluetooth low energy of Android&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;development&lt;/li&gt;
&lt;li&gt;adnroid develop&lt;/li&gt;
&lt;li&gt;stm32 with st-link&lt;/li&gt;
&lt;li&gt;stm32 with sb on linux&lt;/li&gt;
&lt;li&gt;stm32 qemu-system-arm&lt;/li&gt;
&lt;li&gt;stm32 Makefile&lt;/li&gt;
&lt;li&gt;stm32 Hal&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;ol&gt;
&lt;li&gt;ngx_lua waf&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;kong&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;ol&gt;
&lt;li&gt;彻底用明白git&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;ol&gt;
&lt;li&gt;nginx的upstream模块，以及nginx plus的dynamic upstream模块的实现&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;ol&gt;
&lt;li&gt;leetcode&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;ol&gt;
&lt;li&gt;编程之美——编程珠玑——算法——算法导论&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;ol&gt;
&lt;li&gt;简历以及准备面试&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>nginx gdb utils的编译 安装和使用</title>
      <link>https://bg2bkk.github.io/post/nginx-gdb-utils%E7%9A%84%E7%BC%96%E8%AF%91%20%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Fri, 25 Mar 2016 20:16:51 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/nginx-gdb-utils%E7%9A%84%E7%BC%96%E8%AF%91%20%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</guid>
      <description>&lt;p&gt;1、想用&lt;a href=&#34;https://github.com/openresty/nginx-gdb-utils&#34;&gt;nginx-gdb-utils&lt;/a&gt;来监控ngx_lua的内存使用情况
2、在CentOS 6.5上，gdb为7.2，python为2.6，没有一个符合的，想强上，没上了，只能在7上搞
3、CentSO 7的gdb是7.6，版本也很老，对于nginx-gdb-utils来说。python倒是2.7，可以搞
4、&lt;a href=&#34;http://www.linuxfromscratch.org/blfs/view/svn/general/gdb.html&#34;&gt;gdb&lt;/a&gt;需要编译安装，首先下载gdb-7.11&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;    cd gdb-7.11
    ./configure --with-python=python2.7
    报错，报python2.7找不到，换成

    ./configure --with-python=/usr/bin/python2.7
    依然报错
    很奇怪，难道不是要python2.7吗，怎么报找不到。
    后来才知道，需要python，要的不是python2.7的可执行文件，而是python的库文件等待

    sudo yum install python2.7-devel

    make -j24 --with-python
    注意我这里不用写--with-python=blahblah了
    终于不报错了

    make -C gdb install 
    报错，报没有makeinfo的错误，经查，makeinfo是texinfo的一部分，用来生成说明文档的，因为它而不能安装，蛋疼

    sudo yum install texinfo

    make -C gdb install
    安装在/usr/local/bin/gdb

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5、将nginx-gdb-utils写入gdb初始化文件中，这样以后就不用每次加载py文件了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;vim ~/.gdbinit

directory /path/to/nginx-gdb-utils

py import sys
py sys.path.append(&amp;quot;/path/to/nginx-gdb-utils&amp;quot;)

source luajit20.gdb
source ngx-lua.gdb
source luajit21.py
source ngx-raw-req.py
set python print-stack full
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但其实一般而言我们都是用root用户的，所以在sudo或者直接是root用户下时，需要重新写~/.gdbinit，这时应该是在/root/.gdbinit了&lt;/p&gt;

&lt;p&gt;6、/usr/local/bin/gdb -p 12345
7、lgcstat&lt;/p&gt;

&lt;p&gt;发现报一些函数或者变量找不到，比如Lgref找不到，这个原因是相关软件没有把用 -g 选项把符号编译进去&lt;/p&gt;

&lt;p&gt;8、对于LuaJit而言，make CCDEBUG=-g -B -j8
9、对于lua-cjson而言，make CCDEBUG=-g -B -j8
10、对于tengine、nginx或者openresty而言，CFLAGS=&amp;ldquo;-g -O2&amp;rdquo; ./configure&lt;/p&gt;

&lt;p&gt;11、自此就可以愉快的玩耍了。这些工具还是很有意思的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>effective tips in daily work</title>
      <link>https://bg2bkk.github.io/post/effective%20tips%20in%20daily%20work/</link>
      <pubDate>Thu, 24 Mar 2016 16:36:33 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/effective%20tips%20in%20daily%20work/</guid>
      <description>

&lt;h2 id=&#34;git修改默认分支名:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;git修改默认分支名&lt;/h2&gt;

&lt;p&gt;在develop分支改动太大了，导致merge 到master分支时非常被动，这个时候我想，干脆将develop分支作为分支好了。还好碰到&lt;a href=&#34;http://stackoverflow.com/questions/1485578/change-a-git-remote-head-to-point-to-something-besides-master&#34;&gt;stackoverflow的一个帖子&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;git branch -m master oldmaster&lt;/li&gt;
&lt;li&gt;git branch -m develop master&lt;/li&gt;
&lt;li&gt;git push -f origin master&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;另一个方法是从github的&lt;a href=&#34;https://help.github.com/articles/setting-the-default-branch/&#34;&gt;项目主页上更改&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;编译openssl-1-0-2g:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;编译openssl 1.0.2g&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./config shared -fPIC zlib-dynamic &amp;amp;&amp;amp; make depend -j   &amp;amp;&amp;amp; make -j
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;编译nginx-tengine-cpp模块:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;编译nginx/tengine: CPP模块&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./configure --add-module=../cpp_module  --with-ld-opt=&amp;quot;-lstdc++&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;curl-i-和-i的区别:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;curl -i 和 -I的区别&lt;/h2&gt;

&lt;p&gt;man page:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;	-i, --include
		(HTTP) Include the HTTP-header in the output. The HTTP-header includes things like server-name, date of the document, HTTP-version and more...
		
	-I, --head
		(HTTP/FTP/FILE) Fetch the HTTP-header only! HTTP-servers feature the command HEAD which this uses to get nothing but the header of a document. When used on an FTP or FILE file, curl displays the file size and last modification time only.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-i选项会打印出HTTP头部的一些信息，这个选项是curl软件的选项，这些信息本来就是存在的&lt;/p&gt;

&lt;p&gt;-I选项会发送HEAD请求，获取信息&lt;/p&gt;

&lt;h2 id=&#34;linux系统如何将父子进程一起kill掉:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;linux系统如何将父子进程一起kill掉&lt;/h2&gt;

&lt;p&gt;对于普通进程而言，kill掉父进程将会连带着把子进程kill掉；而对于daemon等类型进程而言，kill掉父进程，子进程会被daemon接管，所以如果想父子一起kill掉的话，不能直接kill父进程。&lt;/p&gt;

&lt;p&gt;有&lt;a href=&#34;http://blog.csdn.net/lalaguozhe/article/details/11142855&#34;&gt;两种方法&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;kill &amp;ndash; -PPID&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;PPID前面有&lt;strong&gt;&lt;em&gt;-&lt;/em&gt;&lt;/strong&gt;号，可以将父子进程kill掉&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用exec或者xargs来kill掉他们&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;dns查询中-域名是否可以有多个cname呢:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;dns查询中，域名是否可以有多个cname呢？&lt;/h2&gt;

&lt;p&gt;不可以
    * &lt;a href=&#34;http://serverfault.com/questions/574072/can-we-have-multiple-cnames-for-a-single-name&#34;&gt;http://serverfault.com/questions/574072/can-we-have-multiple-cnames-for-a-single-name&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;git代理访问:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;git代理访问&lt;/h2&gt;

&lt;p&gt;git config &amp;ndash;global http.proxy 10.8.0.1:8118&lt;/p&gt;

&lt;h2 id=&#34;ubuntu操作-挂载-格式化sd卡:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;ubuntu操作、挂载、格式化SD卡&lt;/h2&gt;

&lt;p&gt;玩树莓派等板子的时候，需要从host机器将os镜像烧进sd卡，然后启动。那么ubuntu如何操作呢？&lt;/p&gt;

&lt;p&gt;fdisk -l命令可以用来查看系统中的存储硬件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;

Disk /dev/sda: 111.8 GiB, 120034123776 bytes, 234441648 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: gpt
Disk identifier: C27256BB-CE04-48C2-96F4-8F79FAE2AE87

Device     Start       End   Sectors   Size Type
/dev/sda1   2048 234440703 234438656 111.8G Linux filesystem


Disk /dev/sdb: 167.7 GiB, 180045766656 bytes, 351651888 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x42b438a2

Device     Boot     Start       End   Sectors  Size Id Type
/dev/sdb1  *         2048 105887743 105885696 50.5G  7 HPFS/NTFS/exFAT
/dev/sdb2       105887744 187807665  81919922 39.1G 83 Linux
/dev/sdb3       187807744 228767743  40960000 19.5G  7 HPFS/NTFS/exFAT
/dev/sdb4       228769790 351649791 122880002 58.6G  f W95 Ext&#39;d (LBA)
/dev/sdb5       228769792 351649791 122880000 58.6G  7 HPFS/NTFS/exFAT


Disk /dev/sdc: 14.9 GiB, 16021192704 bytes, 31291392 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x00000000

Device     Boot Start      End  Sectors  Size Id Type
/dev/sdc1        8192 31291391 31283200 14.9G  c W95 FAT32 (LBA)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果sd卡（tf卡）通过usb 读卡器接入电脑，则会显示为 /dev/sdc&lt;/p&gt;

&lt;p&gt;如果是标准sd卡（大卡），则会显示为 /dev/mmblck0&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
Disk /dev/mmcblk0: 14.9 GiB, 16021192704 bytes, 31291392 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x00000000

Device         Boot Start      End  Sectors  Size Id Type
/dev/mmcblk0p1       8192 31291391 31283200 14.9G  c W95 FAT32 (LBA)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;推荐使用USB读卡器，速度较为快一些。&lt;/p&gt;

&lt;h2 id=&#34;lua库文件的加载路径:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;Lua库文件的加载路径&lt;/h2&gt;

&lt;p&gt;Lua 提供一个名为 &lt;a href=&#34;http://www.lua.org/manual/5.1/manual.html#pdf-require&#34;&gt;require&lt;/a&gt; 的函数来加载模块，使用也很简单，它只有一个参数，这个参数就是要指定加载的模块名，&lt;a href=&#34;http://dhq.me/lua-learning-notes-package-and-module&#34;&gt;例如&lt;/a&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&amp;quot;&amp;lt;模块名&amp;gt;&amp;quot;)
-- 或者是
-- require &amp;quot;&amp;lt;模块名&amp;gt;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后会返回一个由模块常量或函数组成的 table，并且还会定义一个包含该 table 的全局变量。&lt;/p&gt;

&lt;p&gt;或者给加载的模块定义一个别名变量，方便调用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local m = require(&amp;quot;module&amp;quot;)
print(m.constant)
m.func3()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于自定义的模块，模块文件不是放在哪个文件目录都行，函数 require 有它自己的文件路径加载策略，它会尝试从 Lua 文件或 C 程序库中加载模块。&lt;/p&gt;

&lt;p&gt;require 用于搜索 Lua 文件的路径是存放在全局变量 package.path 中，当 Lua 启动后，会以环境变量 LUA_PATH 的值来初始这个环境变量。如果没有找到该环境变量，则使用一个编译时定义的默认路径来初始化。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
Lua 5.1.5  Copyright (C) 1994-2012 Lua.org, PUC-Rio
&amp;gt;  print(package.path)
~/lua/?.lua;/usr/local/share/lua/5.1/?.lua;/home/huang/workspace/luactor/?.lua;./?.lua;/usr/local/share/lua/5.1/?.lua;/usr/local/share/lua/5.1/?/init.lua;/usr/local/lib/lua/5.1/?.lua;/usr/local/lib/lua/5.1/?/init.lua;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果没有 LUA_PATH 这个环境变量，也可以自定义设置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;huang@ThinkPad-X220:~/workspace/luapkg/luasocket-2.0.2$ export LUA_PATH=&amp;quot;4;;&amp;quot;
huang@ThinkPad-X220:~/workspace/luapkg/luasocket-2.0.2$ lua
Lua 5.1.5  Copyright (C) 1994-2012 Lua.org, PUC-Rio
&amp;gt;  print(package.path)
4;./?.lua;/usr/local/share/lua/5.1/?.lua;/usr/local/share/lua/5.1/?/init.lua;/usr/local/lib/lua/5.1/?.lua;/usr/local/lib/lua/5.1/?/init.lua;
&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，随便加的环境变量&amp;rdquo;4;&amp;ldquo;写在了package.path中。&lt;/p&gt;

&lt;p&gt;而为什么4需要两个&amp;rsquo;；&amp;rsquo;号呢：文件路径以 &amp;ldquo;;&amp;rdquo; 号分隔，最后的 2 个 &amp;ldquo;;;&amp;rdquo; 表示新加的路径后面加上原来的默认路径。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;huang@ThinkPad-X220:~/workspace/luapkg/luasocket-2.0.2$ export LUA_PATH=&amp;quot;4;&amp;quot;
huang@ThinkPad-X220:~/workspace/luapkg/luasocket-2.0.2$ lua
Lua 5.1.5  Copyright (C) 1994-2012 Lua.org, PUC-Rio
&amp;gt; print(package.path)
4;
&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见如果只有一个；号，将只采用这个分号。&lt;/p&gt;

&lt;p&gt;如果找过目标文件，则会调用 package.loadfile 来加载模块。否则，就会去找 C 程序库。搜索的文件路径是从全局变量 package.cpath 获取，而这个变量则是通过环境变量 LUA_CPATH 来初始。搜索的策略跟上面的一样，只不过现在换成搜索的是 so 或 dll 类型的文件。如果找得到，那么 require 就会通过 package.loadlib 来加载它。&lt;/p&gt;

&lt;p&gt;我们也可以在lua代码中&lt;a href=&#34;https://github.com/rtsisyk/luafun&#34;&gt;动态修改package.path变量&lt;/a&gt;，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;package.path = &amp;quot;../?.lua;&amp;quot;..package.path
require &amp;quot;fun&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这点对于我们自己的lua project的设置来说无疑是很方便的。
&lt;a href=&#34;http://www.runoob.com/lua/lua-modules-packages.html&#34;&gt;参考链接&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;cpp调用c函数:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;cpp调用c函数&lt;/h2&gt;

&lt;p&gt;由于CPP在链接时与C不太一样，因此在调用C函数时，&lt;a href=&#34;http://www.cnblogs.com/skynet/archive/2010/07/10/1774964.html&#34;&gt;需要做一定处理。&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;将C函数的声明房子 &lt;strong&gt;&lt;em&gt;#ifdef __cplusplus&lt;/em&gt;&lt;/strong&gt; 块中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#ifdef __cplusplus
extern &amp;quot;C&amp;quot; {
#endif
 
/*.
 * c functions declarations
..*/

#ifdef __cplusplus
}
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;多少人在猜你机器的密码呢:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;多少人在猜你机器的密码呢&lt;/h2&gt;

&lt;p&gt;VPS在公网就是个待宰的肥肉，都想去登陆，那&lt;a href=&#34;https://plus.google.com/+AlbertSu2015/posts/Uu1vbeJY1Hw&#34;&gt;都谁猜我的IP了呢？&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo grep &amp;quot;Failed password for root&amp;quot; /var/log/auth.log | awk &#39;{print $11}&#39; | sort | uniq -c | sort -nr | more
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;grep的简单使用-与-或-非:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;grep的简单使用，与 或 非&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;或操作&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;grep -E &#39;123|abc&#39; filename  // 找出文件（filename）中包含123或者包含abc的行
egrep &#39;123|abc&#39; filename    // 用egrep同样可以实现
awk &#39;/123|abc/&#39; filename   // awk 的实现方式
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;与操作&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;grep pattern1 files | grep pattern2 ：显示既匹配 pattern1 又匹配 pattern2 的行。
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;其他操作&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
grep -i pattern files ：不区分大小写地搜索。默认情况区分大小写，
grep -l pattern files ：只列出匹配的文件名，
grep -L pattern files ：列出不匹配的文件名，
grep -w pattern files ：只匹配整个单词，而不是字符串的一部分（如匹配‘magic’，而不是‘magical’），
grep -v pattern files ：不匹配pattern
grep -C number pattern files ：匹配的上下文分别显示[number]行，
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;iptables的简单使用:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;iptables的简单使用&lt;/h2&gt;

&lt;p&gt;其实并不想写iptables相关的内容，因为用的不熟，但是一些常用的命令还是记一下吧&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://linux.cn/article-1586-1.html&#34;&gt;iptables的详细解释&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Linux系统中,防火墙(Firewall),网址转换(NAT),数据包(package)记录,流量统计,这些功能是由Netfilter子系统所提供的，而iptables是控制Netfilter的工具。iptables将许多复杂的规则组织成成容易控制的方式，以便管理员可以进行分组测试，或关闭、启动某组规则。
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;https://blog.phpgao.com/vps_iptables.html
http://www.tabyouto.com/bandwagon-vps-for-shadowsocks-was-hacked.html
http://my.oschina.net/yqc/blog/82111?fromerr=VxVIazGW
http://www.vpser.net/security/linux-iptables.html
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 列出所有规则
iptables -L -n

# 更新iptables规则，规则写在/etc/iptables.rules
iptables-restore &amp;lt; /etc/iptables.rules

# 保存iptables规则，规则写在/etc/iptables.rules
iptables-save &amp;gt; /etc/iptables.rules

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的是Debian/Ubuntu上iptables是不会保存规则的。&lt;/p&gt;

&lt;p&gt;需要按如下步骤进行，让网卡关闭是保存iptables规则，启动时加载iptables规则：&lt;/p&gt;

&lt;p&gt;创建/etc/network/if-post-down.d/iptables 文件，添加如下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash
iptables-save &amp;gt; /etc/iptables.rules
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行：chmod +x /etc/network/if-post-down.d/iptables 添加执行权限。&lt;/p&gt;

&lt;p&gt;创建/etc/network/if-pre-up.d/iptables 文件，添加如下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash
iptables-restore &amp;lt; /etc/iptables.rules
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行：chmod +x /etc/network/if-pre-up.d/iptables 添加执行权限。&lt;/p&gt;

&lt;p&gt;iptables的一些常用规则：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#允许ping
iptables -A INPUT -p icmp -m icmp --icmp-type 8 -j ACCEPT
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;vps简单的ssh登陆设置:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;VPS简单的ssh登陆设置&lt;/h2&gt;

&lt;p&gt;初次使用VPS，不懂得安全的重要性，直到扣款时候才心疼，这个时候，弱口令，密码登陆什么的，还是都放弃吧，只用ssh登陆，并且换一个自己的端口。&lt;a href=&#34;https://imququ.com/post/bandwagon-vps-and-basicly-usage.html&#34;&gt;参考链接&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;简单来说，任何一台主机想登陆VPS的主机都需要有本身的ssh公钥私钥&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd ~/.ssh/
ssh-keygen -t rsa -C &amp;quot;username@gmail.com&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后复制~/.ssh/id_rsa.pub中的内容，就是本机的公钥。&lt;/p&gt;

&lt;p&gt;将公钥添加到VPS服务器的/home/username/.ssh/authorized_keys中，本机就能以username用户名登陆VPS了&lt;/p&gt;

&lt;p&gt;然后在/etc/ssh/sshd_config中禁用禁用 VPS 的密码登录和 root 帐号登录，将以下两项改为no&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;PasswordAuthentication no
PermitRootLogin no

Port 11111

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;随后重启SSH服务&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo service ssh restart
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;vim删除空行:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;vim删除空行&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;从网页上copy下代码后，发现很多情况下有不想要的空行，非常影响阅读，通过&lt;a href=&#34;http://bbs.chinaunix.net/thread-510754-1-1.html&#34;&gt;vim的正则&lt;/a&gt;可以解决

&lt;ul&gt;
&lt;li&gt;Delete all blank lines (^ is start of line; \s* is zero or more whitespace characters; $ is end of line)&lt;/li&gt;
&lt;li&gt;删除所有空白行(^是行的开始，\s*是零个或者多个空白字符；$是行尾)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;:g/^\s*$/d
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ubuntu通过命令设置系统时间:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;ubuntu通过命令设置系统时间&lt;/h2&gt;

&lt;p&gt;在嵌入式开发中，在pcduino或者rpi板子上安装好linux后，系统时间是UTC时间1970年，对于有些软件来说可能影响安装，所以需要命令行修改date&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo date -s &amp;quot;13 DEC 2015 20:43&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ubuntu终端下中文设置:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;ubuntu终端下中文设置&lt;/h2&gt;

&lt;p&gt;在安装完ubuntu系统后，我们发现中文支持的不好，主要体现在locale的错误，&lt;a href=&#34;http://www.linuxidc.com/Linux/2015-08/122501.htm&#34;&gt;解决方法：&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;perl: warning: Setting locale failed.
perl: warning: Please check that your locale settings:
	LANGUAGE = (unset),
	LC_ALL = (unset),
	LC_PAPER = &amp;quot;zh_CN.UTF-8&amp;quot;,
	LC_ADDRESS = &amp;quot;zh_CN.UTF-8&amp;quot;,
	LC_MONETARY = &amp;quot;zh_CN.UTF-8&amp;quot;,
	LC_NUMERIC = &amp;quot;zh_CN.UTF-8&amp;quot;,
	LC_TELEPHONE = &amp;quot;zh_CN.UTF-8&amp;quot;,
	LC_IDENTIFICATION = &amp;quot;zh_CN.UTF-8&amp;quot;,
	LC_MEASUREMENT = &amp;quot;zh_CN.UTF-8&amp;quot;,
	LC_TIME = &amp;quot;zh_CN.UTF-8&amp;quot;,
	LC_NAME = &amp;quot;zh_CN.UTF-8&amp;quot;,
	LANG = &amp;quot;en_US.UTF-8&amp;quot;
    are supported and installed on your system.
perl: warning: Falling back to the standard locale (&amp;quot;C&amp;quot;).

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是因为中文包没有安装好的缘故，如下命令就可以解决：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;添加简体中文支持
sudo apt-get -y install language-pack-zh-hans language-pack-zh-hans-base

添加繁体中文支持
sudo apt-get -y install language-pack-zh-hant language-pack-zh-hant-base

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果还不行，先观察下locale的配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;huang@localhost:~$ locale
locale: Cannot set LC_CTYPE to default locale: No such file or directory
locale: Cannot set LC_MESSAGES to default locale: No such file or directory
locale: Cannot set LC_ALL to default locale: No such file or directory
LANG=en_US.UTF-8
LANGUAGE=
LC_CTYPE=&amp;quot;en_US.UTF-8&amp;quot;
LC_NUMERIC=zh_CN.UTF-8
LC_TIME=zh_CN.UTF-8
LC_COLLATE=&amp;quot;en_US.UTF-8&amp;quot;
LC_MONETARY=zh_CN.UTF-8
LC_MESSAGES=&amp;quot;en_US.UTF-8&amp;quot;
LC_PAPER=zh_CN.UTF-8
LC_NAME=zh_CN.UTF-8
LC_ADDRESS=zh_CN.UTF-8
LC_TELEPHONE=zh_CN.UTF-8
LC_MEASUREMENT=zh_CN.UTF-8
LC_IDENTIFICATION=zh_CN.UTF-8
LC_ALL=
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再重新配置下语言包&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;huang@localhost:~$  sudo locale-gen &amp;quot;en_US.UTF-8&amp;quot;
Generating locales...
  en_US.UTF-8... done
Generation complete.
huang@localhost:~$ sudo  pip install shadowsocks^C
huang@localhost:~$  sudo locale-gen &amp;quot;zh_CN.UTF-8&amp;quot;
Generating locales...
  zh_CN.UTF-8... done
Generation complete.
huang@localhost:~$ sudo dpkg-reconfigure locales
Generating locales...
  en_US.UTF-8... done
  zh_CN.UTF-8... up-to-date
  zh_HK.UTF-8... done
  zh_SG.UTF-8... done
  zh_TW.UTF-8... done
Generation complete.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般就都能解决&lt;/p&gt;

&lt;h2 id=&#34;linux终端下的颜色设置输出:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;Linux终端下的颜色设置输出&lt;/h2&gt;

&lt;p&gt;Linux终端下，如果有一个彩色的终端，可以明显提升人的阅读兴趣，通过printf的简单设置即可&lt;a href=&#34;http://www.w2bc.com/Article/39141&#34;&gt;实现彩色输出&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;\033[显示方式;前景色;背景色m

    显示方式、前景色、背景色至少一个存在即可。
    格式：\033[显示方式;前景色;背景色m
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;前景色  背景色  颜色
30  40  黑色
31  41  红色
32  42  绿色
33  43  黃色
34  44  蓝色
35  45  紫红色
36  46  青蓝色
37  47  白色


显示方式    意义
0   终端默认设置
1   高亮显示
4   使用下划线
5   闪烁
7   反白显示
8   不可见

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;\033[1;31;40m    &amp;lt;!--1-高亮显示 31-前景色红色  40-背景色黑色--&amp;gt;
\033[0m          &amp;lt;!--采用终端默认设置，即取消颜色设置--&amp;gt;

printf(&amp;quot;\033[1;31;40m&amp;quot;);
printf(&amp;quot;\033[0m&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;tsar监控系统负载和nginx运行情况:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;tsar监控系统负载和nginx运行情况&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/alibaba/tsar&#34;&gt;tsar&lt;/a&gt;是阿里巴巴发布的一款能够实时监控系统状态的命令行工具，并且支持第三方模块扩展，其中比较注明的是nginx模块。使用tsar时，可以将系统负载和nginx运行情况同步同时打出，可以用来定位系统瓶颈，所以广受好评。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;tsar -li1&lt;/em&gt;&lt;/strong&gt; 是其最经典的用法，可以将一般我们感兴趣的监控项每秒更新一次并输出&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Time              ---cpu-- ---mem-- ---tcp-- -----traffic---- --sda---  ---load- 
Time                util     util   retran    bytin  bytout     util     load1   
25/03/16-19:03:30   0.08    10.22     0.00     1.4K    1.2K     0.00     0.33  
25/03/16-19:03:31   0.08    10.21     0.00   424.00  468.00     0.00     0.33   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果想使能nginx模块，需要对其进行配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;1. mkdir /etc/tsar/conf.d
2. touch /etc/tsar/conf.d/nginx.conf

3. 写入如下内容并保存
mod_nginx on

####add it to tsar default output
output_stdio_mod mod_nginx

####add it to center db
#output_db_mod mod_nginx

####add it to nagios send
####set nagios threshold for alert
#output_nagios_mod mod_nginx

#threshold nginx.value1;N;N;N;N;
#threshold nginx.value2;N;N;N;N;
#threshold nginx.value3;N;N;N;N;

表示使能nginx模块，并使用stdio输出

4. tsar -li1

Time              ---cpu-- ---mem-- ---tcp-- -----traffic---- --sda---  ---load- ------------------nginx----------------- 
Time                util     util   retran    bytin  bytout     util     load1      qps      rt  sslqps  spdyps  sslhst   
25/03/16-19:06:19   0.08    11.40     7.14   302.00  546.00     0.00     0.02     1.00    0.00    0.00    0.00    0.00   

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;wrk在centos系统上的编译方法:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;wrk在CentOS系统上的编译方法&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/wg/wrk&#34;&gt;wrk&lt;/a&gt;作为一款可以内嵌lua脚本的，支持多线程的压测工具，受到了广泛欢迎。在高版本CentOS 7上，直接在wrk目录下执行make，可以首先编译deps/luajit，得到deps/luajit/libluajit.a，然而在低版本上，CentOS 6.5系统中，会报一些莫名奇妙的错误。&lt;/p&gt;

&lt;p&gt;解决方法是，查看wrk的Makefile，发现wrk依赖于luajit，那么首先进入deps/luajit编译它，并且是静态编译&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd wrk
cd deps/luajit
make -j24 BUILDMODE=static

cd ../..
make -j24

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;rpmbuild环境的快速初始化:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;rpmbuild环境的快速初始化&lt;/h2&gt;

&lt;p&gt;需要将代码打包为CentOS的RPM包时，可以先自己在本地新建一个环境&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;1. mkdir -p ~/rpmbuild/{SOURCES,BUILD,BUILDROOT,RPMS,SRPMS,SPECS}
2. 将代打包的代码压缩包 software.tar.gz 放入SOURCES文件夹
3. 将 software.spec 放入SPECS文件夹
4. rpmbuild -ba path/to/software.spec 即可
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;git记住密码-不用每次都输密码才登入:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;git记住密码，不用每次都输密码才登入&lt;/h2&gt;

&lt;p&gt;git有两种方式，一种是ssh方式，配置公钥私钥，对于新手而言还是比较麻烦的；另一种是http方式，这里有一个办法可以让git记住密码，避免每次都需要输入密码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;1. touch ~/.git-credentials
2. 将  https://{username}:{password}@github.com  写入该文件
3. git config --global credential.helper store  就可以使得git记住密码了
4. 此时查看 ~/.gitconfig，发现多了一项
    
    [credential] 
    helper = store 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;centos系统上某些软件-比如gcc-python等版本过低的解决方案:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;centos系统上某些软件，比如gcc、python等版本过低的解决方案&lt;/h2&gt;

&lt;p&gt;在CentOS Server上，经常会遇到某些软件依赖版本过低的问题，比如CentOS 6.5的python是2.7版本的，gcc是4.2版本的，那么我们如何获得一个干净的、与原版本无冲突的运行环境呢。CentOS系提供了一个叫SCL的工具，可以帮我们实现目的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sudo wget http://people.centos.org/tru/devtools-1.1/devtools-1.1.repo -P /etc/yum.repos.d
$ sudo sh -c &#39;echo &amp;quot;enabled=1&amp;quot; &amp;gt;&amp;gt; /etc/yum.repos.d/devtools-1.1.repo&#39;
$ sudo yum install devtoolset-1.1
$ scl enable devtoolset-1.1 bash
$ gcc --version
# 通过devtoolset工具可以暂时提高gcc版本，而不更改之前服务器的配置，这个很有效果，高版本的gcc会智能保留symbol。
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# CentOS 6.5
sudo yum install centos-release-SCL
sudo yum install python27
scl enable python27 bash
python --version
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ubuntu系统上某些软件-比如gcc等版本过高的解决方案:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;ubuntu系统上某些软件，比如gcc等版本过高的解决方案&lt;/h2&gt;

&lt;p&gt;与CentOS相反，debian系发行版的软件版本都很高，Ubuntu 16.04的gcc 版本已经到了5.2，然而编译一些早期linux内核的话，需要gcc-4.7左右的版本，这时候我们怎么办呢，有两个方法：
* 通过apt安装低版本gcc
    * sudo apt-get install gcc-4.7
    * 在编译linux 内核时， make CC=gcc-4.7 即可
* update-alternatives可以帮忙更改符号链接，指向不同版本的gcc
    * &lt;a href=&#34;http://www.metsky.com/archives/607.html&#34;&gt;参考链接1&lt;/a&gt;
    * &lt;a href=&#34;http://blog.csdn.net/zyxlinux888/article/details/6708775&#34;&gt;参考链接2&lt;/a&gt; &lt;a href=&#34;http://blog.csdn.net/zyxlinux888/article/details/6709036&#34;&gt;附赠&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;python的matplotlib库实现绘制图标:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;python的matplotlib库实现绘制图标&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;sudo apt-get install python-matplotlib&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://matplotlib.org/index.html&#34;&gt;参考链接&lt;/a&gt;
&lt;a href=&#34;http://matplotlib.org/examples/index.html&#34;&gt;example&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;python使用requests库发送http请求:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;python使用requests库发送http请求&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://cn.python-requests.org/zh_CN/latest/user/quickstart.html#json&#34;&gt;参考链接&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;python解析命令行参数-argparse:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;python解析命令行参数：argparse&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.xiayf.cn/2013/03/30/argparse/&#34;&gt;参考链接&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;git比较两次commit的差异:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;git比较两次commit的差异&lt;/h2&gt;

&lt;p&gt;通过比较两次commit的代码差异，能够快速理解此次commit的目的，理解作者意图&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;git log&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;查看commit历史
```bash
commit 2279c3f4a8a42e696a0f34e6e9b6289487da92c1
Author: bg2bkk &lt;a href=&#34;mailto:bg2bkk@gmail.com&#34;&gt;bg2bkk@gmail.com&lt;/a&gt;
Date:   Sun Mar 13 09:12:26 2016 +0800&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;add SO_REUSEADDR和SO_REUSEPORT.md&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;commit 2b9d85f8427c5ca9e4f9c128c22acd280eb94405
Author: bg2bkk &lt;a href=&#34;mailto:bg2bkk@gmail.com&#34;&gt;bg2bkk@gmail.com&lt;/a&gt;
Date:   Sat Mar 12 01:16:00 2016 +0800&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;add 采用二级指针实现单链表操作 单链表翻转 删除单链表结点
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
* git diff commit 2279c3f4a8a42e696a0f34e6e9b6289487da92c1 2b9d85f8427c5ca9e4f9c128c22acd280eb94405
    
git返回强制返回某次提交
----------------------------

* git log
* git reset 5f4769a98985b5acfea45462df27830e51a75145 --hard
    * 可见commit号很重要

iptables允许端口被外网访问
------------------------------

防火墙设置，配置1985端口可以被外网访问 

* sudo iptables -A INPUT -m state --state NEW -m tcp -p tcp --dport 1985 -j ACCEPT


tcpdump过滤指定标志的packet
------------------------------

```bash
# tcp包里有个flags字段表示包的类型，tcpdump可以根据该字段抓取相应类型的包：
# tcp[13] 就是 TCP flags (URG,ACK,PSH,RST,SYN,FIN)
# Unskilled 32
# Attackers 16
# Pester     8
# Real       4
# Security   2
# Folks      1

#抓取fin包：
tcpdump -ni any port 9001 and &#39;tcp[13] &amp;amp; 1 != 0 &#39; -s0  -w fin.cap -vvv
#抓取syn+fin包：
tcpdump -ni any port 9001 and &#39;tcp[13] &amp;amp; 3 != 0 &#39; -s0  -w syn_fin.cap -vvv
#抓取rst包：
tcpdump -ni any port 9001 and &#39;tcp[13] &amp;amp; 4 != 0 &#39; -s0  -w rst.cap -vvv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://babyhe.blog.51cto.com/1104064/1395489&#34;&gt;参考链接&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;查看进程的内存占用情况:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;查看进程的内存占用情况&lt;/h2&gt;

&lt;p&gt;用Ternary Search Tree代替Trie Tree后，我想知道我的进程内存占用有多大区别。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ps -e -o &amp;lsquo;pid,comm,args,pcpu,rsz,vsz,stime,user,uid&amp;rsquo; | grep MyDict&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;rsz是实际占用内存，单位是KB&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;pmap -d pid&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>New evolvement of Epoll</title>
      <link>https://bg2bkk.github.io/post/New%20Evolvement%20of%20Epoll/</link>
      <pubDate>Tue, 22 Mar 2016 01:48:41 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/New%20Evolvement%20of%20Epoll/</guid>
      <description>

&lt;h2 id=&#34;epoll在linux-内核中的新发展:b489f0f2178b22438ad2d1ac9c25dd2c&#34;&gt;EPOLL在linux 内核中的新发展&lt;/h2&gt;

&lt;p&gt;Epoll是linux专有的系统调用，用于快速地高效轮询大规模文件描述符fd。这个API在kernel-2.5版本时就已经合并，并使用至今。即使如此，epoll和其他接口一样，仍然有提升空间。现在有两个patch为epoll系列系统调用添加了新的功能。&lt;/p&gt;

&lt;h2 id=&#34;epoll概述:b489f0f2178b22438ad2d1ac9c25dd2c&#34;&gt;epoll概述&lt;/h2&gt;

&lt;p&gt;epoll的功能与select或者poll类似，但是epoll在应对轮询处理大规模文件描述符时拥有更灵活的选项和更高的性能。每次调用select和poll，都会将被轮询的fd集合复制，生成新的fd集合，所以内核需要检查每一个描述符是否合法，是否IO就绪，然后将执行监听的进程添加到相应的唤醒等待队列。但实际上，一般情况下，在两次select或者poll调用之间，有事件产生的fd并不多，所以对每个fd都进行前述流程实际上有很多不必要的重复性操作。Epoll将设置被监听fd和轮询fd是否就绪这两个任务分开，从而解决这一问题。&lt;/p&gt;

&lt;p&gt;使用epoll的话，必须首先新建epoll fd用于轮询，新建epfd通过如下调用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;    #include &amp;lt;sys/poll.h&amp;gt;

    int epoll_create(int size);
    int epoll_create1(int flags);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;两者都返回epoll fd，而epoll_create()的size参数已经不再有意义，epoll_create1()的flag参数可以设置epfd的CLOSE_ON_EXEC标志。&lt;/p&gt;

&lt;p&gt;第二步是添加所有被监听的fd，通过调用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;    int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参数op是EPOLL_CTL_ADD时，fd将被添加进epfd轮询的fd集合中，event参数用于指定哪个类型的事件被轮询，读事件、写事件或者其他事件，详情参考&lt;a href=&#34;http://man7.org/linux/man-pages/man2/epoll_ctl.2.html&#34;&gt;man page&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;最后，等待集合中fd是否就绪的工作由以下函数实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;    int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
    int epoll_pwait(int epfd, struct epoll_event *events, int maxevents, 
                                                int timeout, const sigset_t *sigmask);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有事件发生时，epoll_wait将返回，产生的时间存在参数events中，最多maxevents个事件。如果timeout时间内没有事件发生，epoll_wait也将返回，timeout的单位是ms。epoll_pwait可以使用信号集sigmask来屏蔽特定信号，可以使应用程序安全的等待fd就绪或者捕获信号。二者的关系和select与pselect关系一样。&lt;/p&gt;

&lt;h2 id=&#34;patch-1-epoll-ctl-batch-和-epoll-pwait1:b489f0f2178b22438ad2d1ac9c25dd2c&#34;&gt;patch 1：epoll_ctl_batch() 和 epoll_pwait1()&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lwn.net/Articles/633195/&#34;&gt;Fam Zheng为epoll引入了两个新的系统调用&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;Fam的第一个系统调用是&lt;strong&gt;&lt;em&gt;epoll_ctl_batch&lt;/em&gt;&lt;/strong&gt;，用来解决一个性能问题：每次调用epoll_ctl，都只能添加、修改和删除一个fd，如果有大量fd需要修改，那么需要调用相应次数的epoll_ctl来实现，这会导致大量系统调用发生，而这个场景却是经常发生的。Fam引入的epoll_ctl_batch()通过在一个系统调用中添加多个fd来解决这个问题：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;    int epoll_ctl_batch(int epfd, int flags, int ncmds, struct epoll_ctl_cmd *cmds);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结构体epoll_ctl_cmd用于描述一个待添加的事件，可以看作是epoll_ctl参数的一次打包：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct epoll_ctl_cmd {
      /* Reserved flags for future extension, must be 0. */
      int flags;
      /* The same as epoll_ctl() op parameter. */
      int op;
      /* The same as epoll_ctl() fd parameter. */
      int fd;
      /* The same as the &amp;quot;events&amp;quot; field in struct epoll_event. */
      uint32_t events;
      /* The same as the &amp;quot;data&amp;quot; field in struct epoll_event. */
      uint64_t data;
      /* Output field, will be set to the return code after this
       * command is executed by kernel */
      int result;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将一个epoll_ctl_cmd数组cmds传入，则epoll_ctl_batch可以在一次系统调用中添加多个fd。&lt;/p&gt;

&lt;p&gt;Fam的第二个系统调用是&lt;strong&gt;&lt;em&gt;epoll_pwait1&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;    struct epoll_wait_params{
        int clockid;
        struct timespec timeout;
        sigset_t *sigmask;
        size_t sigsetsize;
    }

    int epoll_pwait(int epfd, int flags, struct epoll_event *events, int maxevents, 
                                                struct epoll_wait_params *params);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;本版本的epoll_pwait1()添加了一个flags参数，但是并未定义任何flag值，所以flags置为0即可。其他参数，包括时间控制、信号屏蔽设置，都写在params参数中，目的是为应用程序提供更精细的时间控制。对于epoll_wait()来说，毫秒级的时钟分辨率已经被证明在一些场景中过于粗糙，新的系统供调用提供了纳秒级别的精度，解决了这个问题。&lt;/p&gt;

&lt;h2 id=&#34;patch2-多线程环境下更好的性能-解决-惊群-问题:b489f0f2178b22438ad2d1ac9c25dd2c&#34;&gt;patch2: 多线程环境下更好的性能，解决“惊群”问题&lt;/h2&gt;

&lt;p&gt;Jason Baron（Akamai公司）主要解决一个相对来说不那么常见的场景下，epoll现有的一个问题。通常情况下，一个给定的fd只被一个进程轮询，但是在Jason的场景中，会有多个进程轮询同一个fd集合。在这个场景设定下，一个fd有事件产生时将会唤醒所有监听进程，即使最后只有一个进程能够得到处理该事件的机会，这就是所谓的“惊群”问题。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://lwn.net/Articles/632590/&#34;&gt;Jason的解决方案&lt;/a&gt;是通过epoll_ctl向被轮询的fd再添加两个新的flag，第一个是&lt;strong&gt;&lt;em&gt;EPOLLEXCLUSIVE&lt;/em&gt;&lt;/strong&gt;，保证只有一个进程能被唤醒然后处理事件。该flag使得，有事件发生时，简单的用add_wait_queue_exclusive()代替add_wait_queue()，互斥的将进程放入等待队列中。很明显，所有轮询同一个fd的进程都要使用互斥模式来实现只有一个进程唤醒的效果。&lt;/p&gt;

&lt;p&gt;不过，这个变化没有完全解决问题，因为这会导致当有事件发生时，唤醒的都是同一个进程。由于Epoll存在的一个原因是，在两次epoll_wait()调用之间,，进程能留在epfd的等待唤醒队列中，处于等待队列头部的进程仍然在队列头部，所以这个进程将被唤醒并处理所有互斥模式的fd（这句翻译我有疑问）。但是我们的目的是，多个进程轮询同一fd集合时，能够散开执行，而每次都唤醒的是同一个进程与此相悖。为解决这个问题，Jason添加了另一个flag，叫做 EPOLLROUNDROBIN，使得内核按顺序处理唤醒每个进程。&lt;/p&gt;

&lt;p&gt;引入一个新的等待队列函数用来支持实现这种方式&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;    void add_wait_queue_rr(wait_queue_head_t *q, wait_queue_t *wait);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用该函数后，当wait返回时，只有一个进程被唤醒，效果和add_wait_queue_exclusive()一样。但是，这个被唤醒的进程，将被从队列头移到队列尾，直到它前面的所有进程都得到唤醒机会后，才能再次被唤醒。&lt;/p&gt;

&lt;p&gt;Jason的提交patch的同时也提交了一个用于压测的程序，压测结果显示，互斥模式使得执行时间降低了50%，当有大量的唤醒发生时，“惊群”效应带来的性能损耗就不会发生了。&lt;/p&gt;

&lt;h2 id=&#34;结语:b489f0f2178b22438ad2d1ac9c25dd2c&#34;&gt;结语&lt;/h2&gt;

&lt;p&gt;以上提到的两个patch已经被多次review和comments，Fam的patch自从&lt;a href=&#34;https://lwn.net/Articles/630097/&#34;&gt;1月份提出&lt;/a&gt;后进行了多次修改。现在的编辑们对API相关的patch投入了越来越多的关注和审视，这是对的，因为API将会长期有效，(API lives forever),甚至是永远有效。所以最好在向用户推出之前就搞定所有bug，以提供永久支持的态度提交。这些patch目前看来已经接近就绪，可能将会在下一个窗口中合并。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Linux C 终端编程之代码自动补全</title>
      <link>https://bg2bkk.github.io/post/Linux%20C%20%E7%BB%88%E7%AB%AF%E7%BC%96%E7%A8%8B%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8/</link>
      <pubDate>Tue, 22 Mar 2016 01:48:07 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/Linux%20C%20%E7%BB%88%E7%AB%AF%E7%BC%96%E7%A8%8B%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8/</guid>
      <description>&lt;p&gt;curses&lt;/p&gt;

&lt;p&gt;readline&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>7层上线过程</title>
      <link>https://bg2bkk.github.io/post/7%E5%B1%82%E4%B8%8A%E7%BA%BF%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Wed, 16 Mar 2016 09:50:21 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/7%E5%B1%82%E4%B8%8A%E7%BA%BF%E8%BF%87%E7%A8%8B/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;排错，每个location设置cache时需要自己起名&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;local sysConfig = ngx.shared[ngx.var.sysConfig]&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;tcpcopy&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;sudo iptables -I OUTPUT -p tcp &amp;ndash;sport 8030 -j QUEUE&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ab和dyupsc，与前台的交互&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;设置runtime，无论成功与否，都会清除原系统中的runtime设置&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;列出所有policy&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;runtime_set 时的 policyid 以及 policygroupid&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;policy的upstream 和 dyupsc的upstream 重叠&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;TODO LIST&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;重新排版优化diversion.lua&lt;/li&gt;
&lt;li&gt;测试shared dict做策略数据库性能&lt;/li&gt;
&lt;li&gt;测试shared tree做策略数据库性能&lt;/li&gt;
&lt;li&gt;log级别设置&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>openresty学习过程中的一些tips</title>
      <link>https://bg2bkk.github.io/post/openresty%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9Btips/</link>
      <pubDate>Mon, 14 Mar 2016 16:36:14 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/openresty%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9Btips/</guid>
      <description>

&lt;h2 id=&#34;ngx-lua获取post字段参数:d90c926ba9cb9e1e62be5d1b7a7aa7fb&#34;&gt;ngx_lua获取post字段参数&lt;/h2&gt;

&lt;p&gt;在用户请求为POST方式时，如果想获取post中的各参数字段，比如post数据为 &amp;ldquo;uid=100&amp;amp;ip=10.13.112.53&amp;rdquo;，此时想获取该字段的话，可以调用&lt;a href=&#34;https://github.com/openresty/lua-nginx-module#ngxreqget_post_args&#34;&gt;ngx.req.get_post_args&lt;/a&gt;函数。按惯例返回table类型，post数据的各字段为table的key&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;function get_uid()
	local args = ngx.req.get_post_args()
	local uid = args[&#39;uid&#39;]
	return uid
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于HTTP的POST提交数据的方式，网上有很多讨论&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://imququ.com/post/four-ways-to-post-data-in-http.html&#34;&gt;四种常见的POST提交数据方式&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;application/x-www-form-urlencoded&lt;/li&gt;
&lt;li&gt;multipart/form-data&lt;/li&gt;
&lt;li&gt;application/json&lt;/li&gt;
&lt;li&gt;text/xml&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;HTTP &lt;a href=&#34;http://jaseywang.me/2012/03/03/http-headers-%E9%83%A8%E5%88%86%E5%AD%97%E6%AE%B5%E7%AC%94%E8%AE%B0/&#34;&gt;header头的一些字段&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ngx_lua同样提供了读写HTTP请求中&lt;a href=&#34;https://github.com/openresty/lua-nginx-module#ngxreqget_uri_args&#34;&gt;uri参数&lt;/a&gt;，读写HTTP请求中的&lt;a href=&#34;https://github.com/openresty/lua-nginx-module#ngxreqget_uri_args&#34;&gt;HEADER头部&lt;/a&gt;，这些在ngx_lua开发中为我们提供了丰富的工具，非常好的功能。&lt;/p&gt;

&lt;p&gt;最后回到主题，当我读出uid字段后，有时候会发现报错&amp;rdquo;requesty body in temp file not supported&amp;rdquo;，原因在于nginx会将用户请求的body字段缓存起来，如果超出缓存大小，则将用户body数据写到文件中；而ngx.req.get_post_args()是不支持从文件中读取数据的。因此解决办法是：适当加大 &lt;a href=&#34;http://wiki.nginx.org/HttpCoreModule#client_body_buffer_size&#34;&gt;nginx 的 client_body_buffer_size 配置&lt;/a&gt;, 当 client_body_buffer_size 配置为和 client_max_body_size 一样大时，nginx就不会把请求体缓冲到文件系统了（但也要仔细内存占用）。&lt;/p&gt;

&lt;p&gt;对于client_max_body_size来说，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Syntax:		client_max_body_size size;
Default:	client_max_body_size 1m;
Context:	http, server, location

Sets the maximum allowed size of the client request body, specified in the “Content-Length” request header field. If the size in a request exceeds the configured value, the 413 (Request Entity Too Large) error is returned to the client. Please be aware that browsers cannot correctly display this error. Setting size to 0 disables checking of client request body size.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;设置允许的client body最大值，对http server来说是种保护。&lt;/p&gt;

&lt;p&gt;对于client_body_buffer_size来说，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Syntax:		client_body_buffer_size size;
Default:	client_body_buffer_size 8k|16k;
Context:	http, server, location

Sets buffer size for reading client request body. In case the request body is larger than the buffer, the whole body or only its part is written to a temporary file. By default, buffer size is equal to two memory pages. This is 8K on x86, other 32-bit platforms, and x86-64. It is usually 16K on other 64-bit platforms.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果client body size大于默认值，则nginx将会把body缓存在文件中。将client body buffer size设置为和client_max_body_size一样大，nginx将不会把它写进文件中。&lt;/p&gt;

&lt;h2 id=&#34;ngx-lua中判断table为空:d90c926ba9cb9e1e62be5d1b7a7aa7fb&#34;&gt;ngx_lua中判断table为空&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;lua的table中，有两类kv，一类是以数字为index，比如{&amp;lsquo;abc&amp;rsquo;, &amp;lsquo;efg&amp;rsquo;}中，{k=1, v=abc}, {k=2, v=efg}，另一类以自己kv存储，比如{[&amp;lsquo;abc&amp;rsquo;] = &amp;lsquo;efg&amp;rsquo;}，k为abc的元素，v为efg&lt;/li&gt;
&lt;li&gt;#table中，#标识符是返回以数字为index的key，从1开始算，连续的key的数量&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local t = {}
t[1] = &#39;a&#39;
t[2] = &#39;b&#39;
t[20] = &#39;c&#39;

print(#t)
2
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;因此#号不能获得table的真实大小，也不能用于判断table是否为空&lt;/li&gt;
&lt;li&gt;table.maxn(tab)，maxn返回table中以数字为key的元素中，数字最大的那个&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local t = {}
t[1] = &#39;a&#39;
t[2] = &#39;b&#39;
t[20] = &#39;c&#39;

print(table.maxn(t))
20
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;next就是pairs遍历table时用来取下一个内容的函数，因此next(tab)可以用来判断table是否为空，如果next(tab)返回为nil的话，说明第一个元素不存在，所以该table为空&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://moonbingbing.gitbooks.io/openresty-best-practices/content/lua/not_nill.html&#34;&gt;参考链接&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;ngx-lua中的参数获得:d90c926ba9cb9e1e62be5d1b7a7aa7fb&#34;&gt;ngx_lua中的参数获得&lt;/h2&gt;

&lt;p&gt;ngx_lua中获得req参数有如下几个方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ngx.var.arg_city 获取city参数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;host:port/uri?city=abc    &lt;strong&gt;&lt;em&gt;ngx.var.arg_city = abc&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;host:port/uri?city=       &lt;strong&gt;&lt;em&gt;ngx.var.arg_city = &amp;ldquo;&lt;/em&gt;&lt;/strong&gt;, and its length is 0&lt;/li&gt;
&lt;li&gt;host:port/uri?city        &lt;strong&gt;&lt;em&gt;ngx.var.arg_city = nil&lt;/em&gt;&lt;/strong&gt;，cause it doesn&amp;rsquo;t exist yet&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ngx.req.get_headers()[&amp;lsquo;city&amp;rsquo;]，获取http请求头中的city参数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;host:port/uri -H &amp;lsquo;city:abc&amp;rsquo;   &lt;strong&gt;&lt;em&gt;结果为abc&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;host:port/uri -H &amp;lsquo;city:&amp;rsquo;      &lt;strong&gt;&lt;em&gt;结果为nil&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://groups.google.com/forum/#!topic/openresty/fQvG_TvDAvU&#34;&gt;thread&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;虽然init_worker_by_lua阶段不能使用cosocket，不过可以先通过一个timer（定时时间为0让其立即调用）来发出对外的socket io操作，以实现一些初始化的目的。&lt;/li&gt;
&lt;li&gt;openresty的两个缓存中，ngx shared dict是跨worker共享的，是一个单纯的kv缓存；预计接下来会有patch能够支持lpush等redis操作；lua-resty-lrucache是每个worker的Lua VM空间内缓存，不能跨worker共享，优点是可以存储所有lua对象，比如table，而不需要序列化和反序列化&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;worker 启动时，upstream 是空的，即 _M.data={}，所以这个时候是不能提供服务的。所以每次 reload config 都会导致一段时间内服务不可访问。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在 init_worker_by_lua 执行 cosocket 相关的 API 是不允许的（后期可能会添加支持），但可以调用标准 SOCKET 完成初始化加载，例如借助 luasocket 完成数据源获取并初始化 _M 。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不清楚 init_worker_by_lua 里是否可以进行文件操作？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;是可以的，这个确定。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在ngx lua性能分析方面，agentzh提出一系列的工具，主要是nginx-systemtap-toolkit和stapxx两个工程。我们使用的脚本，&lt;a href=&#34;https://groups.google.com/forum/#!topic/openresty/bOwgPymXQzg&#34;&gt;说明文档&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;引用：
	我们有一整套的基于 systemtap 的工具链可以用于在线或者离线的性能分析。 
	你的 nginx 进程的 CPU 使用率如果很高的话，可以使用 C 级别的 on-CPU 时间火焰图工具对你最忙的 nginx worker 进程进行采样： 
	    https://github.com/agentzh/nginx-systemtap-toolkit#sample-bt 
	如果你的 nginx 进程的 CPU 很低，但请求延时很高，则有两种可能： 
	1. 你的 nginx 阻塞在了某些阻塞的 IO 操作（比如文件 IO）或者系统的同步锁上，此时你可以使用 C 级别的 off-CPU 
	时间火焰图工具对某个典型的 nginx worker 进程进行采样： 
	   https://github.com/agentzh/nginx-systemtap-toolkit#sample-bt-off-cpu 
	如果你发现 Lua 代码占用了大部分的 CPU 时间，则可以进一步使用 ngx-lua-exec-time 工具加以确认： 
	    https://github.com/agentzh/stapxx#ngx-lua-exec-time 
	进一步地，你可以使用 Lua 代码级别的 on-CPU 火焰图工具在 Lua 层面上分析 CPU 时间的分布。如果你使用的是 LuaJIT 
	2.0.x，则可以使用下面这个工具进行采样： 
	    https://github.com/agentzh/nginx-systemtap-toolkit#ngx-sample-lua-bt 
	如果你使用的是 LuaJIT 2.1，则可以使用 lj-lua-stacks 工具进行采样： 
	    https://github.com/agentzh/stapxx#lj-lua-stacks 
	2. 你的 nginx 通过 ngx_lua 的 cosocket 或者 ngx_proxy 这样的 upstream 
	模块和上游服务进行通信时，上游服务的延时过大。此时你可以分别使用 
	ngx-lua-tcp-recv-time、ngx-lua-udp-recv-time 以及 ngx-single-req-latency 
	工具进行分析： 
	    https://github.com/agentzh/stapxx#ngx-lua-tcp-recv-time 
	    https://github.com/agentzh/stapxx#ngx-lua-udp-recv-time 
	    https://github.com/agentzh/stapxx#ngx-single-req-latency  



    - 我们主要使用四个工具来生成火焰图以分析性能，sample-bt、sample-bt-off-cpu、ngx-sample-lua-bt 和 lj-lua-stacks。
    - 实际使用中命令：
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;1、sudo ./sample-bt -p 8736 -t 20 -u -a &#39;-DMAXSKIPPED=10000&#39; &amp;gt; a.bt
2、sudo ./sample-bt-off-cpu -p 8736 -t 20 -u &amp;gt; b.bt
3、sudo ./ngx-sample-lua-bt --luajit20 -p 44252 -t 20 &amp;gt; c.bt
4、sudo ./samples/lj-lua-stacks.sxx --skip-badvars -x 44250 -I tapset/ &amp;gt; d.bt
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;- 通过a.bt生成火焰图
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;	../FlameGraph/stackcollapse-stap.pl a.bt | ../FlameGraph/flamegraph.pl &amp;gt; a.svg
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;- 通过脚本ngx-lua-conn-pools来追踪ngx lua connection pool的工作情况。        
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;    sudo ./ngx-lua-conn-pools  --luajit20 -p 28261
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>